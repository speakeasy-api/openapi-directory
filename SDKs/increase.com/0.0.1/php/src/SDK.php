<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class SDK
{
	public const SERVERS = [
		'https://api.increase.com',
		'https://sandbox.increase.com',
	];
  		
	// SDK private variables namespaced with _ to avoid conflicts with API models
	private ?\GuzzleHttp\ClientInterface $_defaultClient;
	private ?\GuzzleHttp\ClientInterface $_securityClient;
	private ?Models\Shared\Security $_security;
	private string $_serverUrl;
	private string $_language = 'php';
	private string $_sdkVersion = '0.0.1';
	private string $_genVersion = 'internal';

	/**
	 * Returns a new instance of the SDK builder used to configure and create the SDK instance.
	 * 
	 * @return SDKBuilder
	 */
	public static function builder(): SDKBuilder
	{
		return new SDKBuilder();
	}

	/**
	 * @param \GuzzleHttp\ClientInterface|null $client	 
	 * @param Models\Shared\Security|null $security
	 * @param string $serverUrl
	 * @param array<string, string>|null $params
	 */
	public function __construct(?\GuzzleHttp\ClientInterface $client, ?Models\Shared\Security $security, string $serverUrl, ?array $params)
	{
		$this->_defaultClient = $client;
		
		if ($this->_defaultClient === null) {
			$this->_defaultClient = new \GuzzleHttp\Client([
				'timeout' => 60,
			]);
		}

		$this->_securityClient = null;
		if ($security !== null) {
			$this->_security = $security;
			$this->_securityClient = Utils\Utils::configureSecurityClient($this->_defaultClient, $this->_security);
		}
		
		if ($this->_securityClient === null) {
			$this->_securityClient = $this->_defaultClient;
		}

		if (!empty($serverUrl)) {
			$this->_serverUrl = Utils\Utils::templateUrl($serverUrl, $params);
		}
		
		if (empty($this->_serverUrl)) {
			$this->_serverUrl = $this::SERVERS[0];
		}
	}
	
    /**
     * Action a Real-Time Decision
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ActionARealTimeDecisionRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ActionARealTimeDecisionResponse
     */
	public function actionARealTimeDecision(
        \OpenAPI\OpenAPI\Models\Operations\ActionARealTimeDecisionRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ActionARealTimeDecisionResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/real_time_decisions/{real_time_decision_id}/action', \OpenAPI\OpenAPI\Models\Operations\ActionARealTimeDecisionRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "actionARealTimeDecisionParameters", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ActionARealTimeDecisionResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->realTimeDecision = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\RealTimeDecision', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Approve a Check Transfer
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ApproveACheckTransferRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ApproveACheckTransferResponse
     */
	public function approveACheckTransfer(
        \OpenAPI\OpenAPI\Models\Operations\ApproveACheckTransferRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ApproveACheckTransferResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/check_transfers/{check_transfer_id}/approve', \OpenAPI\OpenAPI\Models\Operations\ApproveACheckTransferRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ApproveACheckTransferResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->checkTransfer = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CheckTransfer', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Approve a Wire Transfer
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ApproveAWireTransferRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ApproveAWireTransferResponse
     */
	public function approveAWireTransfer(
        \OpenAPI\OpenAPI\Models\Operations\ApproveAWireTransferRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ApproveAWireTransferResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/wire_transfers/{wire_transfer_id}/approve', \OpenAPI\OpenAPI\Models\Operations\ApproveAWireTransferRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ApproveAWireTransferResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->wireTransfer = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\WireTransfer', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Approve an Account Transfer
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ApproveAnAccountTransferRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ApproveAnAccountTransferResponse
     */
	public function approveAnAccountTransfer(
        \OpenAPI\OpenAPI\Models\Operations\ApproveAnAccountTransferRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ApproveAnAccountTransferResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/account_transfers/{account_transfer_id}/approve', \OpenAPI\OpenAPI\Models\Operations\ApproveAnAccountTransferRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ApproveAnAccountTransferResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->accountTransfer = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AccountTransfer', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Approve an ACH Transfer
     * 
     * Approves an ACH Transfer in a pending_approval state.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ApproveAnAchTransferRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ApproveAnAchTransferResponse
     */
	public function approveAnAchTransfer(
        \OpenAPI\OpenAPI\Models\Operations\ApproveAnAchTransferRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ApproveAnAchTransferResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ach_transfers/{ach_transfer_id}/approve', \OpenAPI\OpenAPI\Models\Operations\ApproveAnAchTransferRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ApproveAnAchTransferResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->achTransfer = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AchTransfer', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Cancel a pending ACH Transfer
     * 
     * Cancels an ACH Transfer in a pending_approval state.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CancelAPendingAchTransferRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CancelAPendingAchTransferResponse
     */
	public function cancelAPendingAchTransfer(
        \OpenAPI\OpenAPI\Models\Operations\CancelAPendingAchTransferRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CancelAPendingAchTransferResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ach_transfers/{ach_transfer_id}/cancel', \OpenAPI\OpenAPI\Models\Operations\CancelAPendingAchTransferRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CancelAPendingAchTransferResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->achTransfer = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AchTransfer', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Cancel a pending Check Transfer
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CancelAPendingCheckTransferRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CancelAPendingCheckTransferResponse
     */
	public function cancelAPendingCheckTransfer(
        \OpenAPI\OpenAPI\Models\Operations\CancelAPendingCheckTransferRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CancelAPendingCheckTransferResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/check_transfers/{check_transfer_id}/cancel', \OpenAPI\OpenAPI\Models\Operations\CancelAPendingCheckTransferRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CancelAPendingCheckTransferResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->checkTransfer = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CheckTransfer', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Cancel a pending Wire Transfer
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CancelAPendingWireTransferRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CancelAPendingWireTransferResponse
     */
	public function cancelAPendingWireTransfer(
        \OpenAPI\OpenAPI\Models\Operations\CancelAPendingWireTransferRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CancelAPendingWireTransferResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/wire_transfers/{wire_transfer_id}/cancel', \OpenAPI\OpenAPI\Models\Operations\CancelAPendingWireTransferRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CancelAPendingWireTransferResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->wireTransfer = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\WireTransfer', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Cancel an Account Transfer
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CancelAnAccountTransferRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CancelAnAccountTransferResponse
     */
	public function cancelAnAccountTransfer(
        \OpenAPI\OpenAPI\Models\Operations\CancelAnAccountTransferRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CancelAnAccountTransferResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/account_transfers/{account_transfer_id}/cancel', \OpenAPI\OpenAPI\Models\Operations\CancelAnAccountTransferRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CancelAnAccountTransferResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->accountTransfer = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AccountTransfer', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Close an Account
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CloseAnAccountRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CloseAnAccountResponse
     */
	public function closeAnAccount(
        \OpenAPI\OpenAPI\Models\Operations\CloseAnAccountRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CloseAnAccountResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/accounts/{account_id}/close', \OpenAPI\OpenAPI\Models\Operations\CloseAnAccountRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CloseAnAccountResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->account = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Account', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Complete a Sandbox Account Transfer
     * 
     * If your account is configured to require approval for each transfer, this endpoint simulates the approval of an [Account Transfer](#account-transfers). You can also approve sandbox Account Transfers in the dashboard. This transfer must first have a `status` of `pending_approval`.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CompleteASandboxAccountTransferRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CompleteASandboxAccountTransferResponse
     */
	public function completeASandboxAccountTransfer(
        \OpenAPI\OpenAPI\Models\Operations\CompleteASandboxAccountTransferRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CompleteASandboxAccountTransferResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/simulations/account_transfers/{account_transfer_id}/complete', \OpenAPI\OpenAPI\Models\Operations\CompleteASandboxAccountTransferRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CompleteASandboxAccountTransferResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->accountTransfer = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AccountTransfer', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Complete a Sandbox Real Time Payments Transfer
     * 
     * Simulates submission of a Real Time Payments transfer and handling the response from the destination financial institution. This transfer must first have a `status` of `pending_submission`.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CompleteASandboxRealTimePaymentsTransferRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CompleteASandboxRealTimePaymentsTransferResponse
     */
	public function completeASandboxRealTimePaymentsTransfer(
        \OpenAPI\OpenAPI\Models\Operations\CompleteASandboxRealTimePaymentsTransferRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CompleteASandboxRealTimePaymentsTransferResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/simulations/real_time_payments_transfers/{real_time_payments_transfer_id}/complete', \OpenAPI\OpenAPI\Models\Operations\CompleteASandboxRealTimePaymentsTransferRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "completeASandboxRealTimePaymentsTransferParameters", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CompleteASandboxRealTimePaymentsTransferResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->realTimePaymentsTransfer = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\RealTimePaymentsTransfer', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create a Bookkeeping Account
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\CreateABookkeepingAccountParameters $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateABookkeepingAccountResponse
     */
	public function createABookkeepingAccount(
        \OpenAPI\OpenAPI\Models\Shared\CreateABookkeepingAccountParameters $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateABookkeepingAccountResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/bookkeeping_accounts');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateABookkeepingAccountResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->bookkeepingAccount = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\BookkeepingAccount', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create a Bookkeeping Entry Set
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\CreateABookkeepingEntrySetParameters $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateABookkeepingEntrySetResponse
     */
	public function createABookkeepingEntrySet(
        \OpenAPI\OpenAPI\Models\Shared\CreateABookkeepingEntrySetParameters $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateABookkeepingEntrySetResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/bookkeeping_entry_sets');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateABookkeepingEntrySetResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->bookkeepingEntrySet = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\BookkeepingEntrySet', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create a Card
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\CreateACardParameters $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateACardResponse
     */
	public function createACard(
        \OpenAPI\OpenAPI\Models\Shared\CreateACardParameters $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateACardResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/cards');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateACardResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->card = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Card', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create a Card Dispute
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\CreateACardDisputeParameters $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateACardDisputeResponse
     */
	public function createACardDispute(
        \OpenAPI\OpenAPI\Models\Shared\CreateACardDisputeParameters $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateACardDisputeResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/card_disputes');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateACardDisputeResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->cardDispute = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CardDispute', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create a Card Profile
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\CreateACardProfileParameters $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateACardProfileResponse
     */
	public function createACardProfile(
        \OpenAPI\OpenAPI\Models\Shared\CreateACardProfileParameters $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateACardProfileResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/card_profiles');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateACardProfileResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->cardProfile = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CardProfile', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create a Check Deposit
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\CreateACheckDepositParameters $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateACheckDepositResponse
     */
	public function createACheckDeposit(
        \OpenAPI\OpenAPI\Models\Shared\CreateACheckDepositParameters $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateACheckDepositResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/check_deposits');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateACheckDepositResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->checkDeposit = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CheckDeposit', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create a Check Transfer
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\CreateACheckTransferParameters $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateACheckTransferResponse
     */
	public function createACheckTransfer(
        \OpenAPI\OpenAPI\Models\Shared\CreateACheckTransferParameters $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateACheckTransferResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/check_transfers');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateACheckTransferResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->checkTransfer = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CheckTransfer', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create a File
     * 
     * To upload a file to Increase, you'll need to send a request of Content-Type `multipart/form-data`. The request should contain the file you would like to upload, as well as the parameters for creating a file.
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\CreateAFileParameters $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateAFileResponse
     */
	public function createAFile(
        \OpenAPI\OpenAPI\Models\Shared\CreateAFileParameters $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateAFileResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/files');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "multipart");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateAFileResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->file = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\File', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create a Limit
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\CreateALimitParameters $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateALimitResponse
     */
	public function createALimit(
        \OpenAPI\OpenAPI\Models\Shared\CreateALimitParameters $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateALimitResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/limits');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateALimitResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->limit = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Limit', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create a Real Time Payments Transfer
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\CreateARealTimePaymentsTransferParameters $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateARealTimePaymentsTransferResponse
     */
	public function createARealTimePaymentsTransfer(
        \OpenAPI\OpenAPI\Models\Shared\CreateARealTimePaymentsTransferParameters $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateARealTimePaymentsTransferResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/real_time_payments_transfers');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateARealTimePaymentsTransferResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->realTimePaymentsTransfer = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\RealTimePaymentsTransfer', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create a supplemental document for an Entity
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateASupplementalDocumentForAnEntityRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateASupplementalDocumentForAnEntityResponse
     */
	public function createASupplementalDocumentForAnEntity(
        \OpenAPI\OpenAPI\Models\Operations\CreateASupplementalDocumentForAnEntityRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateASupplementalDocumentForAnEntityResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/entities/{entity_id}/supplemental_documents', \OpenAPI\OpenAPI\Models\Operations\CreateASupplementalDocumentForAnEntityRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "createASupplementalDocumentForAnEntityParameters", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateASupplementalDocumentForAnEntityResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->entity = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Entity', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create a Wire Drawdown Request
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\CreateAWireDrawdownRequestParameters $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateAWireDrawdownRequestResponse
     */
	public function createAWireDrawdownRequest(
        \OpenAPI\OpenAPI\Models\Shared\CreateAWireDrawdownRequestParameters $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateAWireDrawdownRequestResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/wire_drawdown_requests');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateAWireDrawdownRequestResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->wireDrawdownRequest = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\WireDrawdownRequest', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create a Wire Transfer
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\CreateAWireTransferParameters $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateAWireTransferResponse
     */
	public function createAWireTransfer(
        \OpenAPI\OpenAPI\Models\Shared\CreateAWireTransferParameters $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateAWireTransferResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/wire_transfers');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateAWireTransferResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->wireTransfer = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\WireTransfer', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create an Account
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\CreateAnAccountParameters $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateAnAccountResponse
     */
	public function createAnAccount(
        \OpenAPI\OpenAPI\Models\Shared\CreateAnAccountParameters $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateAnAccountResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/accounts');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateAnAccountResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->account = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Account', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create an Account Number
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\CreateAnAccountNumberParameters $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateAnAccountNumberResponse
     */
	public function createAnAccountNumber(
        \OpenAPI\OpenAPI\Models\Shared\CreateAnAccountNumberParameters $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateAnAccountNumberResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/account_numbers');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateAnAccountNumberResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->accountNumber = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AccountNumber', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create an Account Transfer
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\CreateAnAccountTransferParameters $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateAnAccountTransferResponse
     */
	public function createAnAccountTransfer(
        \OpenAPI\OpenAPI\Models\Shared\CreateAnAccountTransferParameters $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateAnAccountTransferResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/account_transfers');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateAnAccountTransferResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->accountTransfer = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AccountTransfer', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create an ACH Prenotification
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\CreateAnAchPrenotificationParameters $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateAnAchPrenotificationResponse
     */
	public function createAnAchPrenotification(
        \OpenAPI\OpenAPI\Models\Shared\CreateAnAchPrenotificationParameters $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateAnAchPrenotificationResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ach_prenotifications');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateAnAchPrenotificationResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->achPrenotification = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AchPrenotification', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create an ACH Return
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\CreateAnAchReturnParameters $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateAnAchReturnResponse
     */
	public function createAnAchReturn(
        \OpenAPI\OpenAPI\Models\Shared\CreateAnAchReturnParameters $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateAnAchReturnResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/inbound_ach_transfer_returns');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateAnAchReturnResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->inboundAchTransferReturn = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\InboundAchTransferReturn', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create an ACH Transfer
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\CreateAnAchTransferParameters $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateAnAchTransferResponse
     */
	public function createAnAchTransfer(
        \OpenAPI\OpenAPI\Models\Shared\CreateAnAchTransferParameters $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateAnAchTransferResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ach_transfers');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateAnAchTransferResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->achTransfer = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AchTransfer', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create an Entity
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\CreateAnEntityParameters $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateAnEntityResponse
     */
	public function createAnEntity(
        \OpenAPI\OpenAPI\Models\Shared\CreateAnEntityParameters $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateAnEntityResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/entities');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateAnEntityResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->entity = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Entity', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create an Event Subscription
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\CreateAnEventSubscriptionParameters $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateAnEventSubscriptionResponse
     */
	public function createAnEventSubscription(
        \OpenAPI\OpenAPI\Models\Shared\CreateAnEventSubscriptionParameters $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateAnEventSubscriptionResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/event_subscriptions');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateAnEventSubscriptionResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->eventSubscription = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\EventSubscription', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create an Export
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\CreateAnExportParameters $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateAnExportResponse
     */
	public function createAnExport(
        \OpenAPI\OpenAPI\Models\Shared\CreateAnExportParameters $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateAnExportResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/exports');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateAnExportResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->export = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Export', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create an External Account
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\CreateAnExternalAccountParameters $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateAnExternalAccountResponse
     */
	public function createAnExternalAccount(
        \OpenAPI\OpenAPI\Models\Shared\CreateAnExternalAccountParameters $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateAnExternalAccountResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/external_accounts');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateAnExternalAccountResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->externalAccount = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ExternalAccount', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Deposit a Sandbox Check Transfer
     * 
     * Simulates a [Check Transfer](#check-transfers) being deposited at a bank. This transfer must first have a `status` of `mailed`.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DepositASandboxCheckTransferRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DepositASandboxCheckTransferResponse
     */
	public function depositASandboxCheckTransfer(
        \OpenAPI\OpenAPI\Models\Operations\DepositASandboxCheckTransferRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DepositASandboxCheckTransferResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/simulations/check_transfers/{check_transfer_id}/deposit', \OpenAPI\OpenAPI\Models\Operations\DepositASandboxCheckTransferRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DepositASandboxCheckTransferResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->checkTransfer = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CheckTransfer', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List Account Numbers
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ListAccountNumbersRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ListAccountNumbersResponse
     */
	public function listAccountNumbers(
        \OpenAPI\OpenAPI\Models\Operations\ListAccountNumbersRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ListAccountNumbersResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/account_numbers');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ListAccountNumbersRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ListAccountNumbersResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->accountNumberList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AccountNumberList', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List Account Statements
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ListAccountStatementsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ListAccountStatementsResponse
     */
	public function listAccountStatements(
        \OpenAPI\OpenAPI\Models\Operations\ListAccountStatementsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ListAccountStatementsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/account_statements');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ListAccountStatementsRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ListAccountStatementsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->accountStatementList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AccountStatementList', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List Account Transfers
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ListAccountTransfersRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ListAccountTransfersResponse
     */
	public function listAccountTransfers(
        \OpenAPI\OpenAPI\Models\Operations\ListAccountTransfersRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ListAccountTransfersResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/account_transfers');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ListAccountTransfersRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ListAccountTransfersResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->accountTransferList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AccountTransferList', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List Accounts
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ListAccountsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ListAccountsResponse
     */
	public function listAccounts(
        \OpenAPI\OpenAPI\Models\Operations\ListAccountsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ListAccountsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/accounts');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ListAccountsRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ListAccountsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->accountList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AccountList', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List ACH Prenotifications
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ListAchPrenotificationsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ListAchPrenotificationsResponse
     */
	public function listAchPrenotifications(
        \OpenAPI\OpenAPI\Models\Operations\ListAchPrenotificationsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ListAchPrenotificationsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ach_prenotifications');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ListAchPrenotificationsRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ListAchPrenotificationsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->achPrenotificationList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AchPrenotificationList', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List ACH Transfers
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ListAchTransfersRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ListAchTransfersResponse
     */
	public function listAchTransfers(
        \OpenAPI\OpenAPI\Models\Operations\ListAchTransfersRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ListAchTransfersResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ach_transfers');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ListAchTransfersRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ListAchTransfersResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->achTransferList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AchTransferList', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List Bookkeeping Accounts
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ListBookkeepingAccountsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ListBookkeepingAccountsResponse
     */
	public function listBookkeepingAccounts(
        \OpenAPI\OpenAPI\Models\Operations\ListBookkeepingAccountsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ListBookkeepingAccountsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/bookkeeping_accounts');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ListBookkeepingAccountsRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ListBookkeepingAccountsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->bookkeepingAccountList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\BookkeepingAccountList', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List Bookkeeping Entries
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ListBookkeepingEntriesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ListBookkeepingEntriesResponse
     */
	public function listBookkeepingEntries(
        \OpenAPI\OpenAPI\Models\Operations\ListBookkeepingEntriesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ListBookkeepingEntriesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/bookkeeping_entries');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ListBookkeepingEntriesRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ListBookkeepingEntriesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->bookkeepingEntryList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\BookkeepingEntryList', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List Card Disputes
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ListCardDisputesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ListCardDisputesResponse
     */
	public function listCardDisputes(
        \OpenAPI\OpenAPI\Models\Operations\ListCardDisputesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ListCardDisputesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/card_disputes');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ListCardDisputesRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ListCardDisputesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->cardDisputeList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CardDisputeList', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List Card Profiles
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ListCardProfilesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ListCardProfilesResponse
     */
	public function listCardProfiles(
        \OpenAPI\OpenAPI\Models\Operations\ListCardProfilesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ListCardProfilesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/card_profiles');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ListCardProfilesRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ListCardProfilesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->cardProfileList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CardProfileList', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List Cards
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ListCardsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ListCardsResponse
     */
	public function listCards(
        \OpenAPI\OpenAPI\Models\Operations\ListCardsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ListCardsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/cards');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ListCardsRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ListCardsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->cardList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CardList', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List Check Deposits
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ListCheckDepositsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ListCheckDepositsResponse
     */
	public function listCheckDeposits(
        \OpenAPI\OpenAPI\Models\Operations\ListCheckDepositsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ListCheckDepositsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/check_deposits');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ListCheckDepositsRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ListCheckDepositsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->checkDepositList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CheckDepositList', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List Check Transfers
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ListCheckTransfersRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ListCheckTransfersResponse
     */
	public function listCheckTransfers(
        \OpenAPI\OpenAPI\Models\Operations\ListCheckTransfersRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ListCheckTransfersResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/check_transfers');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ListCheckTransfersRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ListCheckTransfersResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->checkTransferList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CheckTransferList', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List Declined Transactions
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ListDeclinedTransactionsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ListDeclinedTransactionsResponse
     */
	public function listDeclinedTransactions(
        \OpenAPI\OpenAPI\Models\Operations\ListDeclinedTransactionsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ListDeclinedTransactionsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/declined_transactions');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ListDeclinedTransactionsRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ListDeclinedTransactionsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->declinedTransactionList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\DeclinedTransactionList', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List Digital Wallet Tokens
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ListDigitalWalletTokensRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ListDigitalWalletTokensResponse
     */
	public function listDigitalWalletTokens(
        \OpenAPI\OpenAPI\Models\Operations\ListDigitalWalletTokensRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ListDigitalWalletTokensResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/digital_wallet_tokens');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ListDigitalWalletTokensRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ListDigitalWalletTokensResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->digitalWalletTokenList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\DigitalWalletTokenList', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List Documents
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ListDocumentsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ListDocumentsResponse
     */
	public function listDocuments(
        \OpenAPI\OpenAPI\Models\Operations\ListDocumentsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ListDocumentsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/documents');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ListDocumentsRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ListDocumentsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->documentList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\DocumentList', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List Entities
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ListEntitiesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ListEntitiesResponse
     */
	public function listEntities(
        \OpenAPI\OpenAPI\Models\Operations\ListEntitiesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ListEntitiesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/entities');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ListEntitiesRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ListEntitiesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->entityList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\EntityList', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List Event Subscriptions
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ListEventSubscriptionsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ListEventSubscriptionsResponse
     */
	public function listEventSubscriptions(
        \OpenAPI\OpenAPI\Models\Operations\ListEventSubscriptionsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ListEventSubscriptionsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/event_subscriptions');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ListEventSubscriptionsRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ListEventSubscriptionsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->eventSubscriptionList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\EventSubscriptionList', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List Events
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ListEventsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ListEventsResponse
     */
	public function listEvents(
        \OpenAPI\OpenAPI\Models\Operations\ListEventsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ListEventsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/events');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ListEventsRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ListEventsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->eventList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\EventList', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List Exports
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ListExportsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ListExportsResponse
     */
	public function listExports(
        \OpenAPI\OpenAPI\Models\Operations\ListExportsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ListExportsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/exports');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ListExportsRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ListExportsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->exportList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ExportList', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List External Accounts
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ListExternalAccountsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ListExternalAccountsResponse
     */
	public function listExternalAccounts(
        \OpenAPI\OpenAPI\Models\Operations\ListExternalAccountsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ListExternalAccountsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/external_accounts');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ListExternalAccountsRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ListExternalAccountsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->externalAccountList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ExternalAccountList', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List Files
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ListFilesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ListFilesResponse
     */
	public function listFiles(
        \OpenAPI\OpenAPI\Models\Operations\ListFilesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ListFilesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/files');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ListFilesRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ListFilesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->fileList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\FileList', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List Inbound ACH Transfer Returns
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ListInboundAchTransferReturnsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ListInboundAchTransferReturnsResponse
     */
	public function listInboundAchTransferReturns(
        \OpenAPI\OpenAPI\Models\Operations\ListInboundAchTransferReturnsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ListInboundAchTransferReturnsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/inbound_ach_transfer_returns');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ListInboundAchTransferReturnsRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ListInboundAchTransferReturnsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->inboundAchTransferReturnList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\InboundAchTransferReturnList', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List Inbound Wire Drawdown Requests
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ListInboundWireDrawdownRequestsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ListInboundWireDrawdownRequestsResponse
     */
	public function listInboundWireDrawdownRequests(
        \OpenAPI\OpenAPI\Models\Operations\ListInboundWireDrawdownRequestsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ListInboundWireDrawdownRequestsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/inbound_wire_drawdown_requests');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ListInboundWireDrawdownRequestsRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ListInboundWireDrawdownRequestsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->inboundWireDrawdownRequestList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\InboundWireDrawdownRequestList', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List Limits
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ListLimitsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ListLimitsResponse
     */
	public function listLimits(
        \OpenAPI\OpenAPI\Models\Operations\ListLimitsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ListLimitsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/limits');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ListLimitsRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ListLimitsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->limitList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\LimitList', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List OAuth Connections
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ListOauthConnectionsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ListOauthConnectionsResponse
     */
	public function listOauthConnections(
        \OpenAPI\OpenAPI\Models\Operations\ListOauthConnectionsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ListOauthConnectionsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/oauth_connections');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ListOauthConnectionsRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ListOauthConnectionsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->oauthConnectionList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\OauthConnectionList', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List Pending Transactions
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ListPendingTransactionsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ListPendingTransactionsResponse
     */
	public function listPendingTransactions(
        \OpenAPI\OpenAPI\Models\Operations\ListPendingTransactionsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ListPendingTransactionsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/pending_transactions');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ListPendingTransactionsRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ListPendingTransactionsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->pendingTransactionList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\PendingTransactionList', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List Programs
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ListProgramsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ListProgramsResponse
     */
	public function listPrograms(
        \OpenAPI\OpenAPI\Models\Operations\ListProgramsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ListProgramsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/programs');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ListProgramsRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ListProgramsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->programList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ProgramList', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List Real Time Payments Transfers
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ListRealTimePaymentsTransfersRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ListRealTimePaymentsTransfersResponse
     */
	public function listRealTimePaymentsTransfers(
        \OpenAPI\OpenAPI\Models\Operations\ListRealTimePaymentsTransfersRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ListRealTimePaymentsTransfersResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/real_time_payments_transfers');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ListRealTimePaymentsTransfersRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ListRealTimePaymentsTransfersResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->realTimePaymentsTransferList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\RealTimePaymentsTransferList', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List Routing Numbers
     * 
     * You can use this API to confirm if a routing number is valid, such as when a user is providing you with bank account details. Since routing numbers uniquely identify a bank, this will always return 0 or 1 entry. In Sandbox, the only valid routing number for this method is 110000000.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ListRoutingNumbersRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ListRoutingNumbersResponse
     */
	public function listRoutingNumbers(
        \OpenAPI\OpenAPI\Models\Operations\ListRoutingNumbersRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ListRoutingNumbersResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/routing_numbers');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ListRoutingNumbersRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ListRoutingNumbersResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->routingNumberList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\RoutingNumberList', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List Transactions
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ListTransactionsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ListTransactionsResponse
     */
	public function listTransactions(
        \OpenAPI\OpenAPI\Models\Operations\ListTransactionsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ListTransactionsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/transactions');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ListTransactionsRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ListTransactionsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->transactionList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\TransactionList', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List Wire Drawdown Requests
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ListWireDrawdownRequestsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ListWireDrawdownRequestsResponse
     */
	public function listWireDrawdownRequests(
        \OpenAPI\OpenAPI\Models\Operations\ListWireDrawdownRequestsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ListWireDrawdownRequestsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/wire_drawdown_requests');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ListWireDrawdownRequestsRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ListWireDrawdownRequestsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->wireDrawdownRequestList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\WireDrawdownRequestList', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List Wire Transfers
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ListWireTransfersRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ListWireTransfersResponse
     */
	public function listWireTransfers(
        \OpenAPI\OpenAPI\Models\Operations\ListWireTransfersRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ListWireTransfersResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/wire_transfers');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ListWireTransfersRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ListWireTransfersResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->wireTransferList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\WireTransferList', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Look up the balance for an Account
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\LookUpTheBalanceForAnAccountParameters $request
     * @return \OpenAPI\OpenAPI\Models\Operations\LookUpTheBalanceForAnAccountResponse
     */
	public function lookUpTheBalanceForAnAccount(
        \OpenAPI\OpenAPI\Models\Shared\LookUpTheBalanceForAnAccountParameters $request,
    ): \OpenAPI\OpenAPI\Models\Operations\LookUpTheBalanceForAnAccountResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/balance_lookups');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\LookUpTheBalanceForAnAccountResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->balanceLookup = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\BalanceLookup', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Mail a Sandbox Check Transfer
     * 
     * Simulates the mailing of a [Check Transfer](#check-transfers), which happens once per weekday in production but can be sped up in sandbox. This transfer must first have a `status` of `pending_approval` or `pending_submission`.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\MailASandboxCheckTransferRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\MailASandboxCheckTransferResponse
     */
	public function mailASandboxCheckTransfer(
        \OpenAPI\OpenAPI\Models\Operations\MailASandboxCheckTransferRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\MailASandboxCheckTransferResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/simulations/check_transfers/{check_transfer_id}/mail', \OpenAPI\OpenAPI\Models\Operations\MailASandboxCheckTransferRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\MailASandboxCheckTransferResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->checkTransfer = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CheckTransfer', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Reject a Sandbox Check Deposit
     * 
     * Simulates the rejection of a [Check Deposit](#check-deposits) by Increase due to factors like poor image quality. This Check Deposit must first have a `status` of `pending`.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RejectASandboxCheckDepositRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RejectASandboxCheckDepositResponse
     */
	public function rejectASandboxCheckDeposit(
        \OpenAPI\OpenAPI\Models\Operations\RejectASandboxCheckDepositRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RejectASandboxCheckDepositResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/simulations/check_deposits/{check_deposit_id}/reject', \OpenAPI\OpenAPI\Models\Operations\RejectASandboxCheckDepositRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RejectASandboxCheckDepositResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->checkDeposit = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CheckDeposit', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Request a stop payment on a Check Transfer
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RequestAStopPaymentOnACheckTransferRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RequestAStopPaymentOnACheckTransferResponse
     */
	public function requestAStopPaymentOnACheckTransfer(
        \OpenAPI\OpenAPI\Models\Operations\RequestAStopPaymentOnACheckTransferRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RequestAStopPaymentOnACheckTransferResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/check_transfers/{check_transfer_id}/stop_payment', \OpenAPI\OpenAPI\Models\Operations\RequestAStopPaymentOnACheckTransferRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RequestAStopPaymentOnACheckTransferResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->checkTransfer = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CheckTransfer', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Retrieve a Card
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RetrieveACardRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RetrieveACardResponse
     */
	public function retrieveACard(
        \OpenAPI\OpenAPI\Models\Operations\RetrieveACardRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RetrieveACardResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/cards/{card_id}', \OpenAPI\OpenAPI\Models\Operations\RetrieveACardRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RetrieveACardResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->card = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Card', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Retrieve a Card Dispute
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RetrieveACardDisputeRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RetrieveACardDisputeResponse
     */
	public function retrieveACardDispute(
        \OpenAPI\OpenAPI\Models\Operations\RetrieveACardDisputeRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RetrieveACardDisputeResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/card_disputes/{card_dispute_id}', \OpenAPI\OpenAPI\Models\Operations\RetrieveACardDisputeRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RetrieveACardDisputeResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->cardDispute = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CardDispute', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Retrieve a Card Profile
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RetrieveACardProfileRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RetrieveACardProfileResponse
     */
	public function retrieveACardProfile(
        \OpenAPI\OpenAPI\Models\Operations\RetrieveACardProfileRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RetrieveACardProfileResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/card_profiles/{card_profile_id}', \OpenAPI\OpenAPI\Models\Operations\RetrieveACardProfileRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RetrieveACardProfileResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->cardProfile = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CardProfile', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Retrieve a Check Deposit
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RetrieveACheckDepositRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RetrieveACheckDepositResponse
     */
	public function retrieveACheckDeposit(
        \OpenAPI\OpenAPI\Models\Operations\RetrieveACheckDepositRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RetrieveACheckDepositResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/check_deposits/{check_deposit_id}', \OpenAPI\OpenAPI\Models\Operations\RetrieveACheckDepositRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RetrieveACheckDepositResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->checkDeposit = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CheckDeposit', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Retrieve a Check Transfer
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RetrieveACheckTransferRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RetrieveACheckTransferResponse
     */
	public function retrieveACheckTransfer(
        \OpenAPI\OpenAPI\Models\Operations\RetrieveACheckTransferRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RetrieveACheckTransferResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/check_transfers/{check_transfer_id}', \OpenAPI\OpenAPI\Models\Operations\RetrieveACheckTransferRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RetrieveACheckTransferResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->checkTransfer = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CheckTransfer', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Retrieve a Declined Transaction
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RetrieveADeclinedTransactionRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RetrieveADeclinedTransactionResponse
     */
	public function retrieveADeclinedTransaction(
        \OpenAPI\OpenAPI\Models\Operations\RetrieveADeclinedTransactionRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RetrieveADeclinedTransactionResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/declined_transactions/{declined_transaction_id}', \OpenAPI\OpenAPI\Models\Operations\RetrieveADeclinedTransactionRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RetrieveADeclinedTransactionResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->declinedTransaction = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\DeclinedTransaction', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Retrieve a Digital Wallet Token
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RetrieveADigitalWalletTokenRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RetrieveADigitalWalletTokenResponse
     */
	public function retrieveADigitalWalletToken(
        \OpenAPI\OpenAPI\Models\Operations\RetrieveADigitalWalletTokenRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RetrieveADigitalWalletTokenResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/digital_wallet_tokens/{digital_wallet_token_id}', \OpenAPI\OpenAPI\Models\Operations\RetrieveADigitalWalletTokenRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RetrieveADigitalWalletTokenResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->digitalWalletToken = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\DigitalWalletToken', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Retrieve a Document
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RetrieveADocumentRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RetrieveADocumentResponse
     */
	public function retrieveADocument(
        \OpenAPI\OpenAPI\Models\Operations\RetrieveADocumentRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RetrieveADocumentResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/documents/{document_id}', \OpenAPI\OpenAPI\Models\Operations\RetrieveADocumentRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RetrieveADocumentResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->document = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Document', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Retrieve a File
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RetrieveAFileRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RetrieveAFileResponse
     */
	public function retrieveAFile(
        \OpenAPI\OpenAPI\Models\Operations\RetrieveAFileRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RetrieveAFileResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/files/{file_id}', \OpenAPI\OpenAPI\Models\Operations\RetrieveAFileRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RetrieveAFileResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->file = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\File', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Retrieve a Limit
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RetrieveALimitRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RetrieveALimitResponse
     */
	public function retrieveALimit(
        \OpenAPI\OpenAPI\Models\Operations\RetrieveALimitRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RetrieveALimitResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/limits/{limit_id}', \OpenAPI\OpenAPI\Models\Operations\RetrieveALimitRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RetrieveALimitResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->limit = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Limit', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Retrieve a Pending Transaction
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RetrieveAPendingTransactionRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RetrieveAPendingTransactionResponse
     */
	public function retrieveAPendingTransaction(
        \OpenAPI\OpenAPI\Models\Operations\RetrieveAPendingTransactionRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RetrieveAPendingTransactionResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/pending_transactions/{pending_transaction_id}', \OpenAPI\OpenAPI\Models\Operations\RetrieveAPendingTransactionRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RetrieveAPendingTransactionResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->pendingTransaction = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\PendingTransaction', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Retrieve a Program
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RetrieveAProgramRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RetrieveAProgramResponse
     */
	public function retrieveAProgram(
        \OpenAPI\OpenAPI\Models\Operations\RetrieveAProgramRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RetrieveAProgramResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/programs/{program_id}', \OpenAPI\OpenAPI\Models\Operations\RetrieveAProgramRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RetrieveAProgramResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->program = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Program', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Retrieve a Real-Time Decision
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RetrieveARealTimeDecisionRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RetrieveARealTimeDecisionResponse
     */
	public function retrieveARealTimeDecision(
        \OpenAPI\OpenAPI\Models\Operations\RetrieveARealTimeDecisionRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RetrieveARealTimeDecisionResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/real_time_decisions/{real_time_decision_id}', \OpenAPI\OpenAPI\Models\Operations\RetrieveARealTimeDecisionRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RetrieveARealTimeDecisionResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->realTimeDecision = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\RealTimeDecision', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Retrieve a Real Time Payments Transfer
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RetrieveARealTimePaymentsTransferRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RetrieveARealTimePaymentsTransferResponse
     */
	public function retrieveARealTimePaymentsTransfer(
        \OpenAPI\OpenAPI\Models\Operations\RetrieveARealTimePaymentsTransferRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RetrieveARealTimePaymentsTransferResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/real_time_payments_transfers/{real_time_payments_transfer_id}', \OpenAPI\OpenAPI\Models\Operations\RetrieveARealTimePaymentsTransferRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RetrieveARealTimePaymentsTransferResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->realTimePaymentsTransfer = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\RealTimePaymentsTransfer', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Retrieve a Transaction
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RetrieveATransactionRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RetrieveATransactionResponse
     */
	public function retrieveATransaction(
        \OpenAPI\OpenAPI\Models\Operations\RetrieveATransactionRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RetrieveATransactionResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/transactions/{transaction_id}', \OpenAPI\OpenAPI\Models\Operations\RetrieveATransactionRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RetrieveATransactionResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->transaction = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Transaction', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Retrieve a Wire Drawdown Request
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RetrieveAWireDrawdownRequestRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RetrieveAWireDrawdownRequestResponse
     */
	public function retrieveAWireDrawdownRequest(
        \OpenAPI\OpenAPI\Models\Operations\RetrieveAWireDrawdownRequestRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RetrieveAWireDrawdownRequestResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/wire_drawdown_requests/{wire_drawdown_request_id}', \OpenAPI\OpenAPI\Models\Operations\RetrieveAWireDrawdownRequestRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RetrieveAWireDrawdownRequestResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->wireDrawdownRequest = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\WireDrawdownRequest', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Retrieve a Wire Transfer
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RetrieveAWireTransferRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RetrieveAWireTransferResponse
     */
	public function retrieveAWireTransfer(
        \OpenAPI\OpenAPI\Models\Operations\RetrieveAWireTransferRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RetrieveAWireTransferResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/wire_transfers/{wire_transfer_id}', \OpenAPI\OpenAPI\Models\Operations\RetrieveAWireTransferRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RetrieveAWireTransferResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->wireTransfer = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\WireTransfer', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Retrieve an Account
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RetrieveAnAccountRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RetrieveAnAccountResponse
     */
	public function retrieveAnAccount(
        \OpenAPI\OpenAPI\Models\Operations\RetrieveAnAccountRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RetrieveAnAccountResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/accounts/{account_id}', \OpenAPI\OpenAPI\Models\Operations\RetrieveAnAccountRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RetrieveAnAccountResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->account = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Account', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Retrieve an Account Number
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RetrieveAnAccountNumberRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RetrieveAnAccountNumberResponse
     */
	public function retrieveAnAccountNumber(
        \OpenAPI\OpenAPI\Models\Operations\RetrieveAnAccountNumberRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RetrieveAnAccountNumberResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/account_numbers/{account_number_id}', \OpenAPI\OpenAPI\Models\Operations\RetrieveAnAccountNumberRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RetrieveAnAccountNumberResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->accountNumber = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AccountNumber', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Retrieve an Account Statement
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RetrieveAnAccountStatementRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RetrieveAnAccountStatementResponse
     */
	public function retrieveAnAccountStatement(
        \OpenAPI\OpenAPI\Models\Operations\RetrieveAnAccountStatementRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RetrieveAnAccountStatementResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/account_statements/{account_statement_id}', \OpenAPI\OpenAPI\Models\Operations\RetrieveAnAccountStatementRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RetrieveAnAccountStatementResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->accountStatement = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AccountStatement', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Retrieve an Account Transfer
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RetrieveAnAccountTransferRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RetrieveAnAccountTransferResponse
     */
	public function retrieveAnAccountTransfer(
        \OpenAPI\OpenAPI\Models\Operations\RetrieveAnAccountTransferRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RetrieveAnAccountTransferResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/account_transfers/{account_transfer_id}', \OpenAPI\OpenAPI\Models\Operations\RetrieveAnAccountTransferRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RetrieveAnAccountTransferResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->accountTransfer = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AccountTransfer', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Retrieve an ACH Prenotification
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RetrieveAnAchPrenotificationRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RetrieveAnAchPrenotificationResponse
     */
	public function retrieveAnAchPrenotification(
        \OpenAPI\OpenAPI\Models\Operations\RetrieveAnAchPrenotificationRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RetrieveAnAchPrenotificationResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ach_prenotifications/{ach_prenotification_id}', \OpenAPI\OpenAPI\Models\Operations\RetrieveAnAchPrenotificationRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RetrieveAnAchPrenotificationResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->achPrenotification = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AchPrenotification', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Retrieve an ACH Transfer
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RetrieveAnAchTransferRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RetrieveAnAchTransferResponse
     */
	public function retrieveAnAchTransfer(
        \OpenAPI\OpenAPI\Models\Operations\RetrieveAnAchTransferRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RetrieveAnAchTransferResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/ach_transfers/{ach_transfer_id}', \OpenAPI\OpenAPI\Models\Operations\RetrieveAnAchTransferRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RetrieveAnAchTransferResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->achTransfer = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AchTransfer', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Retrieve an Entity
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RetrieveAnEntityRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RetrieveAnEntityResponse
     */
	public function retrieveAnEntity(
        \OpenAPI\OpenAPI\Models\Operations\RetrieveAnEntityRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RetrieveAnEntityResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/entities/{entity_id}', \OpenAPI\OpenAPI\Models\Operations\RetrieveAnEntityRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RetrieveAnEntityResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->entity = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Entity', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Retrieve an Event
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RetrieveAnEventRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RetrieveAnEventResponse
     */
	public function retrieveAnEvent(
        \OpenAPI\OpenAPI\Models\Operations\RetrieveAnEventRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RetrieveAnEventResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/events/{event_id}', \OpenAPI\OpenAPI\Models\Operations\RetrieveAnEventRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RetrieveAnEventResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->event = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Event', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Retrieve an Event Subscription
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RetrieveAnEventSubscriptionRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RetrieveAnEventSubscriptionResponse
     */
	public function retrieveAnEventSubscription(
        \OpenAPI\OpenAPI\Models\Operations\RetrieveAnEventSubscriptionRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RetrieveAnEventSubscriptionResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/event_subscriptions/{event_subscription_id}', \OpenAPI\OpenAPI\Models\Operations\RetrieveAnEventSubscriptionRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RetrieveAnEventSubscriptionResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->eventSubscription = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\EventSubscription', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Retrieve an Export
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RetrieveAnExportRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RetrieveAnExportResponse
     */
	public function retrieveAnExport(
        \OpenAPI\OpenAPI\Models\Operations\RetrieveAnExportRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RetrieveAnExportResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/exports/{export_id}', \OpenAPI\OpenAPI\Models\Operations\RetrieveAnExportRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RetrieveAnExportResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->export = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Export', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Retrieve an External Account
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RetrieveAnExternalAccountRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RetrieveAnExternalAccountResponse
     */
	public function retrieveAnExternalAccount(
        \OpenAPI\OpenAPI\Models\Operations\RetrieveAnExternalAccountRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RetrieveAnExternalAccountResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/external_accounts/{external_account_id}', \OpenAPI\OpenAPI\Models\Operations\RetrieveAnExternalAccountRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RetrieveAnExternalAccountResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->externalAccount = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ExternalAccount', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Retrieve an Inbound ACH Transfer Return
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RetrieveAnInboundAchTransferReturnRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RetrieveAnInboundAchTransferReturnResponse
     */
	public function retrieveAnInboundAchTransferReturn(
        \OpenAPI\OpenAPI\Models\Operations\RetrieveAnInboundAchTransferReturnRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RetrieveAnInboundAchTransferReturnResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/inbound_ach_transfer_returns/{inbound_ach_transfer_return_id}', \OpenAPI\OpenAPI\Models\Operations\RetrieveAnInboundAchTransferReturnRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RetrieveAnInboundAchTransferReturnResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->inboundAchTransferReturn = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\InboundAchTransferReturn', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Retrieve an Inbound Wire Drawdown Request
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RetrieveAnInboundWireDrawdownRequestRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RetrieveAnInboundWireDrawdownRequestResponse
     */
	public function retrieveAnInboundWireDrawdownRequest(
        \OpenAPI\OpenAPI\Models\Operations\RetrieveAnInboundWireDrawdownRequestRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RetrieveAnInboundWireDrawdownRequestResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/inbound_wire_drawdown_requests/{inbound_wire_drawdown_request_id}', \OpenAPI\OpenAPI\Models\Operations\RetrieveAnInboundWireDrawdownRequestRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RetrieveAnInboundWireDrawdownRequestResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->inboundWireDrawdownRequest = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\InboundWireDrawdownRequest', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Retrieve an OAuth Connection
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RetrieveAnOauthConnectionRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RetrieveAnOauthConnectionResponse
     */
	public function retrieveAnOauthConnection(
        \OpenAPI\OpenAPI\Models\Operations\RetrieveAnOauthConnectionRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RetrieveAnOauthConnectionResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/oauth_connections/{oauth_connection_id}', \OpenAPI\OpenAPI\Models\Operations\RetrieveAnOauthConnectionRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RetrieveAnOauthConnectionResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->oauthConnection = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\OauthConnection', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Retrieve Group details
     * 
     * Returns details for the currently authenticated Group.
     * 
     * @return \OpenAPI\OpenAPI\Models\Operations\RetrieveGroupDetailsResponse
     */
	public function retrieveGroupDetails(
    ): \OpenAPI\OpenAPI\Models\Operations\RetrieveGroupDetailsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/groups/current');
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RetrieveGroupDetailsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->group = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Group', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Retrieve sensitive details for a Card
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RetrieveSensitiveDetailsForACardRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RetrieveSensitiveDetailsForACardResponse
     */
	public function retrieveSensitiveDetailsForACard(
        \OpenAPI\OpenAPI\Models\Operations\RetrieveSensitiveDetailsForACardRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RetrieveSensitiveDetailsForACardResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/cards/{card_id}/details', \OpenAPI\OpenAPI\Models\Operations\RetrieveSensitiveDetailsForACardRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RetrieveSensitiveDetailsForACardResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->cardDetails = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CardDetails', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Return a Sandbox ACH Transfer
     * 
     * Simulates the return of an [ACH Transfer](#ach-transfers) by the Federal Reserve due to an error condition. This will also create a Transaction to account for the returned funds. This transfer must first have a `status` of `submitted`.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ReturnASandboxAchTransferRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ReturnASandboxAchTransferResponse
     */
	public function returnASandboxAchTransfer(
        \OpenAPI\OpenAPI\Models\Operations\ReturnASandboxAchTransferRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ReturnASandboxAchTransferResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/simulations/ach_transfers/{ach_transfer_id}/return', \OpenAPI\OpenAPI\Models\Operations\ReturnASandboxAchTransferRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "returnASandboxAchTransferParameters", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ReturnASandboxAchTransferResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->achTransfer = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AchTransfer', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Return a Sandbox Check Deposit
     * 
     * Simulates the return of a [Check Deposit](#check-deposits). This Check Deposit must first have a `status` of `submitted`.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ReturnASandboxCheckDepositRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ReturnASandboxCheckDepositResponse
     */
	public function returnASandboxCheckDeposit(
        \OpenAPI\OpenAPI\Models\Operations\ReturnASandboxCheckDepositRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ReturnASandboxCheckDepositResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/simulations/check_deposits/{check_deposit_id}/return', \OpenAPI\OpenAPI\Models\Operations\ReturnASandboxCheckDepositRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ReturnASandboxCheckDepositResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->checkDeposit = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CheckDeposit', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Return a Sandbox Check Transfer
     * 
     * Simulates a [Check Transfer](#check-transfers) being returned via USPS to Increase. This transfer must first have a `status` of `mailed`.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ReturnASandboxCheckTransferRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ReturnASandboxCheckTransferResponse
     */
	public function returnASandboxCheckTransfer(
        \OpenAPI\OpenAPI\Models\Operations\ReturnASandboxCheckTransferRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ReturnASandboxCheckTransferResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/simulations/check_transfers/{check_transfer_id}/return', \OpenAPI\OpenAPI\Models\Operations\ReturnASandboxCheckTransferRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "returnASandboxCheckTransferParameters", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ReturnASandboxCheckTransferResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->checkTransfer = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CheckTransfer', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Reverse a Sandbox Wire Transfer
     * 
     * Simulates the reversal of a [Wire Transfer](#wire-transfers) by the Federal Reserve due to error conditions. This will also create a [Transaction](#transaction) to account for the returned funds. This Wire Transfer must first have a `status` of `complete`.'
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ReverseASandboxWireTransferRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ReverseASandboxWireTransferResponse
     */
	public function reverseASandboxWireTransfer(
        \OpenAPI\OpenAPI\Models\Operations\ReverseASandboxWireTransferRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ReverseASandboxWireTransferResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/simulations/wire_transfers/{wire_transfer_id}/reverse', \OpenAPI\OpenAPI\Models\Operations\ReverseASandboxWireTransferRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ReverseASandboxWireTransferResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->wireTransfer = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\WireTransfer', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Simulate a Real Time Payments Transfer to your account
     * 
     * Simulates an inbound Real Time Payments transfer to your account. Real Time Payments are a beta feature.
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\SimulateARealTimePaymentsTransferToYourAccountParameters $request
     * @return \OpenAPI\OpenAPI\Models\Operations\SimulateARealTimePaymentsTransferToYourAccountResponse
     */
	public function simulateARealTimePaymentsTransferToYourAccount(
        \OpenAPI\OpenAPI\Models\Shared\SimulateARealTimePaymentsTransferToYourAccountParameters $request,
    ): \OpenAPI\OpenAPI\Models\Operations\SimulateARealTimePaymentsTransferToYourAccountResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/simulations/inbound_real_time_payments_transfers');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SimulateARealTimePaymentsTransferToYourAccountResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->inboundRealTimePaymentsTransferSimulationResult = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\InboundRealTimePaymentsTransferSimulationResult', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Simulate a refund on a card
     * 
     * Simulates refunding a card transaction. The full value of the original sandbox transaction is refunded.
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\SimulateARefundOnACardParameters $request
     * @return \OpenAPI\OpenAPI\Models\Operations\SimulateARefundOnACardResponse
     */
	public function simulateARefundOnACard(
        \OpenAPI\OpenAPI\Models\Shared\SimulateARefundOnACardParameters $request,
    ): \OpenAPI\OpenAPI\Models\Operations\SimulateARefundOnACardResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/simulations/card_refunds');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SimulateARefundOnACardResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->transaction = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Transaction', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Simulate a tax document being created
     * 
     * Simulates an tax document being created for an account.
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\SimulateATaxDocumentBeingCreatedParameters $request
     * @return \OpenAPI\OpenAPI\Models\Operations\SimulateATaxDocumentBeingCreatedResponse
     */
	public function simulateATaxDocumentBeingCreated(
        \OpenAPI\OpenAPI\Models\Shared\SimulateATaxDocumentBeingCreatedParameters $request,
    ): \OpenAPI\OpenAPI\Models\Operations\SimulateATaxDocumentBeingCreatedResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/simulations/documents');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SimulateATaxDocumentBeingCreatedResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->document = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Document', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Simulate a Wire Transfer to your account
     * 
     * Simulates an inbound Wire Transfer to your account.
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\SimulateAWireTransferToYourAccountParameters $request
     * @return \OpenAPI\OpenAPI\Models\Operations\SimulateAWireTransferToYourAccountResponse
     */
	public function simulateAWireTransferToYourAccount(
        \OpenAPI\OpenAPI\Models\Shared\SimulateAWireTransferToYourAccountParameters $request,
    ): \OpenAPI\OpenAPI\Models\Operations\SimulateAWireTransferToYourAccountResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/simulations/inbound_wire_transfers');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SimulateAWireTransferToYourAccountResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->inboundWireTransferSimulationResult = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\InboundWireTransferSimulationResult', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Simulate an Account Statement being created
     * 
     * Simulates an [Account Statement](#account-statements) being created for an account. In production, Account Statements are generated once per month.
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\SimulateAnAccountStatementBeingCreatedParameters $request
     * @return \OpenAPI\OpenAPI\Models\Operations\SimulateAnAccountStatementBeingCreatedResponse
     */
	public function simulateAnAccountStatementBeingCreated(
        \OpenAPI\OpenAPI\Models\Shared\SimulateAnAccountStatementBeingCreatedParameters $request,
    ): \OpenAPI\OpenAPI\Models\Operations\SimulateAnAccountStatementBeingCreatedResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/simulations/account_statements');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SimulateAnAccountStatementBeingCreatedResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->accountStatement = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AccountStatement', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Simulate an ACH Transfer to your account
     * 
     * Simulates an inbound ACH transfer to your account. This imitates initiating a transaction to an Increase account from a different financial institution. The transfer may be either a credit or a debit depending on if the `amount` is positive or negative. The result of calling this API will be either a [Transaction](#transactions) or a [Declined Transaction](#declined-transactions) depending on whether or not the transfer is allowed.
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\SimulateAnAchTransferToYourAccountParameters $request
     * @return \OpenAPI\OpenAPI\Models\Operations\SimulateAnAchTransferToYourAccountResponse
     */
	public function simulateAnAchTransferToYourAccount(
        \OpenAPI\OpenAPI\Models\Shared\SimulateAnAchTransferToYourAccountParameters $request,
    ): \OpenAPI\OpenAPI\Models\Operations\SimulateAnAchTransferToYourAccountResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/simulations/inbound_ach_transfers');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SimulateAnAchTransferToYourAccountResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->inboundAchTransferSimulationResult = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\InboundAchTransferSimulationResult', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Simulate an authorization on a Card
     * 
     * Simulates a purchase authorization on a [Card](#cards). Depending on the balance available to the card and the `amount` submitted, the authorization activity will result in a [Pending Transaction](#pending-transactions) of type `card_authorization` or a [Declined Transaction](#declined-transactions) of type `card_decline`. You can pass either a Card id or a [Digital Wallet Token](#digital-wallet-tokens) id to simulate the two different ways purchases can be made.
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\SimulateAnAuthorizationOnACardParameters $request
     * @return \OpenAPI\OpenAPI\Models\Operations\SimulateAnAuthorizationOnACardResponse
     */
	public function simulateAnAuthorizationOnACard(
        \OpenAPI\OpenAPI\Models\Shared\SimulateAnAuthorizationOnACardParameters $request,
    ): \OpenAPI\OpenAPI\Models\Operations\SimulateAnAuthorizationOnACardResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/simulations/card_authorizations');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SimulateAnAuthorizationOnACardResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->inboundCardAuthorizationSimulationResult = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\InboundCardAuthorizationSimulationResult', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Simulate an Inbound Wire Drawdown request being created
     * 
     * Simulates the receival of an [Inbound Wire Drawdown Request](#inbound-wire-drawdown-requests).
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\SimulateAnInboundWireDrawdownRequestBeingCreatedParameters $request
     * @return \OpenAPI\OpenAPI\Models\Operations\SimulateAnInboundWireDrawdownRequestBeingCreatedResponse
     */
	public function simulateAnInboundWireDrawdownRequestBeingCreated(
        \OpenAPI\OpenAPI\Models\Shared\SimulateAnInboundWireDrawdownRequestBeingCreatedParameters $request,
    ): \OpenAPI\OpenAPI\Models\Operations\SimulateAnInboundWireDrawdownRequestBeingCreatedResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/simulations/inbound_wire_drawdown_requests');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SimulateAnInboundWireDrawdownRequestBeingCreatedResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->inboundWireDrawdownRequest = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\InboundWireDrawdownRequest', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Simulate an Interest Payment to your account
     * 
     * Simulates an interest payment to your account. In production, this happens automatically on the first of each month.
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\SimulateAnInterestPaymentToYourAccountParameters $request
     * @return \OpenAPI\OpenAPI\Models\Operations\SimulateAnInterestPaymentToYourAccountResponse
     */
	public function simulateAnInterestPaymentToYourAccount(
        \OpenAPI\OpenAPI\Models\Shared\SimulateAnInterestPaymentToYourAccountParameters $request,
    ): \OpenAPI\OpenAPI\Models\Operations\SimulateAnInterestPaymentToYourAccountResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/simulations/interest_payment');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SimulateAnInterestPaymentToYourAccountResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->interestPaymentSimulationResult = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\InterestPaymentSimulationResult', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Simulate digital wallet provisioning for a card
     * 
     * Simulates a user attempting add a [Card](#cards) to a digital wallet such as Apple Pay.
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\SimulateDigitalWalletProvisioningForACardParameters $request
     * @return \OpenAPI\OpenAPI\Models\Operations\SimulateDigitalWalletProvisioningForACardResponse
     */
	public function simulateDigitalWalletProvisioningForACard(
        \OpenAPI\OpenAPI\Models\Shared\SimulateDigitalWalletProvisioningForACardParameters $request,
    ): \OpenAPI\OpenAPI\Models\Operations\SimulateDigitalWalletProvisioningForACardResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/simulations/digital_wallet_token_requests');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SimulateDigitalWalletProvisioningForACardResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->inboundDigitalWalletTokenRequestSimulationResult = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\InboundDigitalWalletTokenRequestSimulationResult', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Simulate settling a card authorization
     * 
     * Simulates the settlement of an authorization by a card acquirer. After a card authorization is created, the merchant will eventually send a settlement. This simulates that event, which may occur many days after the purchase in production. The amount settled can be different from the amount originally authorized, for example, when adding a tip to a restaurant bill.
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\SimulateSettlingACardAuthorizationParameters $request
     * @return \OpenAPI\OpenAPI\Models\Operations\SimulateSettlingACardAuthorizationResponse
     */
	public function simulateSettlingACardAuthorization(
        \OpenAPI\OpenAPI\Models\Shared\SimulateSettlingACardAuthorizationParameters $request,
    ): \OpenAPI\OpenAPI\Models\Operations\SimulateSettlingACardAuthorizationResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/simulations/card_settlements');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SimulateSettlingACardAuthorizationResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->transaction = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Transaction', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Simulates advancing the state of a card dispute
     * 
     * After a [Card Dispute](#card-disputes) is created in production, the dispute will be reviewed. Since no review happens in sandbox, this endpoint simulates moving a Card Dispute into a rejected or accepted state. A Card Dispute can only be actioned one time and must have a status of `pending_reviewing`.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\SimulatesAdvancingTheStateOfACardDisputeRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\SimulatesAdvancingTheStateOfACardDisputeResponse
     */
	public function simulatesAdvancingTheStateOfACardDispute(
        \OpenAPI\OpenAPI\Models\Operations\SimulatesAdvancingTheStateOfACardDisputeRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\SimulatesAdvancingTheStateOfACardDisputeResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/simulations/card_disputes/{card_dispute_id}/action', \OpenAPI\OpenAPI\Models\Operations\SimulatesAdvancingTheStateOfACardDisputeRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "simulatesAdvancingTheStateOfACardDisputeParameters", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SimulatesAdvancingTheStateOfACardDisputeResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->cardDispute = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CardDispute', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Submit a Sandbox ACH Transfer
     * 
     * Simulates the submission of an [ACH Transfer](#ach-transfers) to the Federal Reserve. This transfer must first have a `status` of `pending_approval` or `pending_submission`. In production, Increase submits ACH Transfers to the Federal Reserve three times per day on weekdays. Since sandbox ACH Transfers are not submitted to the Federal Reserve, this endpoint allows you to skip that delay and transition the ACH Transfer to a status of `submitted`.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\SubmitASandboxAchTransferRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\SubmitASandboxAchTransferResponse
     */
	public function submitASandboxAchTransfer(
        \OpenAPI\OpenAPI\Models\Operations\SubmitASandboxAchTransferRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\SubmitASandboxAchTransferResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/simulations/ach_transfers/{ach_transfer_id}/submit', \OpenAPI\OpenAPI\Models\Operations\SubmitASandboxAchTransferRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SubmitASandboxAchTransferResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->achTransfer = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AchTransfer', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Submit a Sandbox Check Deposit
     * 
     * Simulates the submission of a [Check Deposit](#check-deposits) to the Federal Reserve. This Check Deposit must first have a `status` of `pending`.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\SubmitASandboxCheckDepositRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\SubmitASandboxCheckDepositResponse
     */
	public function submitASandboxCheckDeposit(
        \OpenAPI\OpenAPI\Models\Operations\SubmitASandboxCheckDepositRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\SubmitASandboxCheckDepositResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/simulations/check_deposits/{check_deposit_id}/submit', \OpenAPI\OpenAPI\Models\Operations\SubmitASandboxCheckDepositRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SubmitASandboxCheckDepositResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->checkDeposit = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CheckDeposit', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Submit a Sandbox Wire Transfer
     * 
     * Simulates the submission of a [Wire Transfer](#wire-transfers) to the Federal Reserve. This transfer must first have a `status` of `pending_approval` or `pending_creating`.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\SubmitASandboxWireTransferRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\SubmitASandboxWireTransferResponse
     */
	public function submitASandboxWireTransfer(
        \OpenAPI\OpenAPI\Models\Operations\SubmitASandboxWireTransferRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\SubmitASandboxWireTransferResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/simulations/wire_transfers/{wire_transfer_id}/submit', \OpenAPI\OpenAPI\Models\Operations\SubmitASandboxWireTransferRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SubmitASandboxWireTransferResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->wireTransfer = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\WireTransfer', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update a Card
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateACardRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateACardResponse
     */
	public function updateACard(
        \OpenAPI\OpenAPI\Models\Operations\UpdateACardRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateACardResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/cards/{card_id}', \OpenAPI\OpenAPI\Models\Operations\UpdateACardRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "updateACardParameters", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateACardResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->card = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Card', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update a Limit
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateALimitRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateALimitResponse
     */
	public function updateALimit(
        \OpenAPI\OpenAPI\Models\Operations\UpdateALimitRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateALimitResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/limits/{limit_id}', \OpenAPI\OpenAPI\Models\Operations\UpdateALimitRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "updateALimitParameters", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateALimitResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->limit = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Limit', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update an Account
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateAnAccountRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateAnAccountResponse
     */
	public function updateAnAccount(
        \OpenAPI\OpenAPI\Models\Operations\UpdateAnAccountRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateAnAccountResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/accounts/{account_id}', \OpenAPI\OpenAPI\Models\Operations\UpdateAnAccountRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "updateAnAccountParameters", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateAnAccountResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->account = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Account', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update an Account Number
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateAnAccountNumberRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateAnAccountNumberResponse
     */
	public function updateAnAccountNumber(
        \OpenAPI\OpenAPI\Models\Operations\UpdateAnAccountNumberRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateAnAccountNumberResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/account_numbers/{account_number_id}', \OpenAPI\OpenAPI\Models\Operations\UpdateAnAccountNumberRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "updateAnAccountNumberParameters", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateAnAccountNumberResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->accountNumber = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AccountNumber', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update an Event Subscription
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateAnEventSubscriptionRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateAnEventSubscriptionResponse
     */
	public function updateAnEventSubscription(
        \OpenAPI\OpenAPI\Models\Operations\UpdateAnEventSubscriptionRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateAnEventSubscriptionResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/event_subscriptions/{event_subscription_id}', \OpenAPI\OpenAPI\Models\Operations\UpdateAnEventSubscriptionRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "updateAnEventSubscriptionParameters", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateAnEventSubscriptionResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->eventSubscription = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\EventSubscription', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update an External Account
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateAnExternalAccountRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateAnExternalAccountResponse
     */
	public function updateAnExternalAccount(
        \OpenAPI\OpenAPI\Models\Operations\UpdateAnExternalAccountRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateAnExternalAccountResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/external_accounts/{external_account_id}', \OpenAPI\OpenAPI\Models\Operations\UpdateAnExternalAccountRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "updateAnExternalAccountParameters", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateAnExternalAccountResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->externalAccount = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ExternalAccount', 'json');
            }
        }
        else {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'mixed', 'json');
            }
        }

        return $response;
    }
}