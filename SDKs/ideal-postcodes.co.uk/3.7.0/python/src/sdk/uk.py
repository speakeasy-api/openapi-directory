"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Optional

class Uk:
    r"""UK Address and Postcode Search"""
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def address_cleanse(self, request: operations.AddressCleanseRequest) -> operations.AddressCleanseResponse:
        r"""Cleanse
        The address cleanse API attempts to return the closest matching address for any given address inputs. We also return a number of Match Level indicators that describe the degree to which the suggested address matches the input address. The more impaired the input address, the harder it is to cleanse.
        
        ## Confidence Score
        
        The confidence score is a number ranging between 0 and 1. Where 1 implies a full match and 0 implies no major elements completely match. Each incorrect, missing or misspelled element will subtract from the overall confidence score.
        
        ### Deciding on an Acceptable Confidence Score Threshold
        
        Different address cleanse projects can have radically different inputs. However, within each project, the inputs tend to repeat the same errors. For instance, some input datasets may be exclusively inputted manually and be prone to typos. Others may have a persistently missing datapoint such as organistation name or postcode. For this reason, it is important to understand that there is no absolute Confidence Score threshold. Instead, the acceptable confidence score must be determined on a project by project basis based on systematic errors present in the data and business goals.
        
        When determining an acceptable Confidence Score threshold you should load a subset of the dataset into a spreadsheet application like Excel and sort on the score. Scrolling from top-to-bottom you will be able to observe matches from best to worst. As you start to hit the lower quality searches, you will be able to roughly determine:
        - Which confidence scores indicate ambigious matches (i.e. up to building level only)
        - Which confidence scores indicate a poor or no match (i.e. the nearest matching address is too far from the input address)
        
        Depending on your business goals, you can also use the Match Levels to determine an acceptable match. For instance, do you need to match up to the throroughfare or building name only? Are accurate organisation names an important feature?
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/cleanse/addresses'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        query_params = utils.get_query_params(operations.AddressCleanseRequest, request)
        
        client = self._client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AddressCleanseResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CleanseResponse])
                res.cleanse_response = out
        elif http_res.status_code == 400:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.BadRequestResponse])
                res.bad_request_response = out
        elif http_res.status_code == 401:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.UnauthorizedResponse])
                res.unauthorized_response = out
        elif http_res.status_code == 429:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.RateLimitedResponse])
                res.rate_limited_response = out

        return res

    def addresses(self, request: operations.AddressesRequest) -> operations.AddressesResponse:
        r"""Extract Addresses
        Extract a list of complete addresses that match the query ordered by relevance score. This query accepts an optional limit and page query (defaults to 10 and 0 respectively).
        
        If a valid postcode is passed as the query string, the entire address list for that postcode is passed as a result. Note, in these cases, limit and page parameters are ignored.
        
        This API is designed as a multi-purpose tool for generating address lists, cleansing and wholesale data extraction according to specific parameters.
        
        For address autocomplete, see our address finder API - which is designed for speed and address completion.
        
        ## Reverse Geocoding
        
        Return a list of addresses around a point using the lon= and lat= querystring arguments. Addresses will be sorted in order of distance to the point. The search radius is 100m.
        
        ## Filters
        
        You can strictly narrow your result by adding filters to your query string which correspond with an address attribute.
        
        For instance, you can restrict to postcode `SW1A 2AA` by appending `postcode=sw1a2aa`.
        
        If a filter term is invalid, e.g. `postcode=SW1A2AAA`, then an empty result set is returned and no lookup is incurred.
        
        You can also scope using multiple terms for the same filter with a comma separated list of terms. E.g. Restrict results to E1, E2 and E3 outward codes: `postcode_outward=e1,e2,e3`. Multiple terms are `OR`'ed, i.e. the matching result sets are combined.
        
        All filters can accept multiple terms unless stated otherwise below.
        
        Multiple filters can also be combined. E.g. Restrict results to small user organisations in the N postcode area: `su_organisation_indicator=Y&postcode_area=n`. Multiple filters are `AND`'ed, i.e. each additional filter narrows the result set.
        
        A combined maximum of 5 terms are allowed across all filters.
        
        ## Biases
        
        You can boost certain addresses results that correspond with a certain address attribute. All bias searches are prefixed with `bias_`.
        
        Biased searches, unlike filtered searches, also allow unmatched addresses to appear . These will rank lower.
        
        For instance, you can boost addresses with postcode areas `SW` and `SE` by appending `bias_postcode_area=SW,SE`.
        
        If a bias term is invalid, e.g. `bias_postcode=SW1A2AAA` no bias effect is applied.
        
        You may scope using multiple terms for the same bias with a comma separated list of terms. E.g. Restrict results to `E1`, `E2` and `E3` outward codes: `bias_postcode_outward=e1,e2,e3`.
        
        All biases can accept multiple terms unless stated otherwise below.
        
        A combined maximum of 5 terms are allowed across all biases.
        
        ## Search by Postcode and Building Name or Number
        
        Search by postcode and building attribute with the postcode filter and query argument. E.g. For \"SW1A 2AA Prime Minister\" `/v1/addresses?postcode=sw1a2aa&q=prime minister`.
        
        The advantage of using filters is a postcode mismatch does not result in a lookup as no results are returned.
        
        #### Search By UPRN
        
        Search by UPRN using the `uprn` filter and excluding the query argument. E.g. `/v1/addresses?uprn=100`.
        
        ## Testing
        
        - **ID1 1QD** Returns a successful query response `2000`
        - **ID1 KFA** Returns an empty query response `2000`
        - **ID1 CLIP** Returns \"no lookups remaining\" error `4020`
        - **ID1 CHOP** Returns \"daily (or individual) lookup limit breached\" error `4021`
        
        Test request undergo the usual authentication and restriction rules. This is to help surface any issues that occur during implementation and does not cost you a lookup.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/addresses'
        
        query_params = utils.get_query_params(operations.AddressesRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AddressesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.AddressResponse])
                res.address_response = out
        elif http_res.status_code == 400:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.BadRequestResponse])
                res.bad_request_response = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PostcodeNotFoundResponse])
                res.postcode_not_found_response = out

        return res

    def postcodes(self, request: operations.PostcodesRequest) -> operations.PostcodesResponse:
        r"""Lookup Postcode
        Returns the complete list of addresses for a postcode. Postcode searches are space and case insensitive.
        
        The Postcode Lookup API provides a JSON interface to search UK addresses from a postcode. It can be used to power Postcode Lookup driven address searches, like [Postcode Lookup](/postcode-lookup).
        
        ## Postcode Not Found
        
        Lookup balance is unaffected by invalid postcodes. The API returns a `404` response with response body:
        
        ```json
        {
          \"code\": 4040,
          \"message\": \"Postcode not found\",
          \"suggestions\": [\"SW1A 0AA\"]
        }
        ```
        
        ### Suggestions
        
        If a postcode cannot be found, the API will provide up to 5 closest matching postcodes. Common errors will be corrected first (e.g. mixing up `O` and `0` or `I` and `1`).
        
        If the suggestion list is small (fewer than 3), there is a high probability the correct postcode is there. You may notify the user or immediately trigger new searches.
        
        The suggestion list will be empty if the postcode has deviated too far from a valid postcode format.
        
        ## Multiple Residence
        
        A small number of postcodes will return more than 100 premises. These may require pagination. Use `page` to paginate the result set.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostcodesRequest, base_url, '/postcodes/{postcode}', request)
        
        query_params = utils.get_query_params(operations.PostcodesRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostcodesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PostcodeResponse])
                res.postcode_response = out
        elif http_res.status_code == 400:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.BadRequestResponse])
                res.bad_request_response = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PostcodeNotFoundResponse])
                res.postcode_not_found_response = out

        return res

    def udprn(self, request: operations.UDPRNRequest) -> operations.UDPRNResponse:
        r"""Retrieve by UDPRN
        Returns an address as identified by its Unique Delivery Point Reference Number (UDPRN).
        
        You may find it useful to store UDPRN information as it can be used to retrieve the most recent information for an address. It can also be used to test for a deleted address.
        
        UDPRNs are an eight digit unique numeric code (e.g. 25962203) for any premise on the Postcode Address File. It's essentially a unique identifier for every address in the UK that Royal Mail has in its database.
        
        ## Testing
        
        To test your implementation of our API we have a range of test UDPRNs that yield both successful and unsuccessful responses to your request.
        
        They are the following:
        
        - `0` Returns a successful UDPRN lookup response
          `2000`
        - `-1` Returns \"UDPRN not found\", error `4044`
        - `-2` Returns \"no lookups remaining\", error `4020`
        - `-3` Returns \"daily (or individual) lookup limit breached\",
          error `4021`
        
        Test request undergo the usual authentication and restriction rules. This is to help surface any issues that occur during implementation and does not cost you a lookup.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.UDPRNRequest, base_url, '/udprn/{udprn}', request)
        
        query_params = utils.get_query_params(operations.UDPRNRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UDPRNResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.UDPRNResponse])
                res.udprn_response = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    def umprn(self, request: operations.UMPRNRequest) -> operations.UMPRNResponse:
        r"""Retrieve by UMPRN
        Returns a multiple occupancy address identifited via its UMPRN (Multiple Residence Unique ID).
        
        UMPRNs are a unique numeric code for any Multiple Residence household on the optional Multiple Residence dataset.
        
        ## Testing
        
        To test your implementation of our API we have a range of test UMPRNs that yield both successful and unsuccessful responses to your request. They are the following
        
        - `0` Returns a successful UMPRN lookup response `2000`
        - `-1` Returns \"UMPRN not found\", error `4044`
        - `-2` Returns \"no lookups remaining\", error `4020`
        - `-3` Returns \"daily (or individual) lookup limit breached\", error `4021`
        
        Test request undergo the usual authentication and restriction rules. This is to help surface any issues that occur during implementation and does not cost you a lookup.
        
        ### Pricing
        
        Per lookup charges apply. Empty responses are not charged.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.UMPRNRequest, base_url, '/umprn/{umprn}', request)
        
        query_params = utils.get_query_params(operations.UMPRNRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UMPRNResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.UMPRNResponse])
                res.umprn_response = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    