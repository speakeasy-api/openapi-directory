"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Any, Optional

class Account:
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def add_payment_method(self, request: operations.AddPaymentMethodRequest, security: operations.AddPaymentMethodSecurity) -> operations.AddPaymentMethodResponse:
        r"""Add a new payment method to an account."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/account/billing/methods'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "add_payment_method_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        query_params = utils.get_query_params(operations.AddPaymentMethodRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AddPaymentMethodResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PaymentMethod])
                res.payment_method = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def authorize_device(self, request: operations.AuthorizeDeviceRequest, security: operations.AuthorizeDeviceSecurity) -> operations.AuthorizeDeviceResponse:
        r"""Authorize a device from a generated device authorization code.
        
        This is the second step in the process of authorizing a device by pin code.
        
        Firstly the device must request a generated authorization code via the
        `/authorization/device/code` endpoint.
        
        This endpoint then authorizes the device associated with the code to sign in
        to a user account. Typically this endpoint will be called from a page
        presented in the web app under the account section.
        
        Once authorized, the device will then be able to sign in to that account
        via the `/authorization/device` endpoint, without needing to provide the 
        credentials of the user.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/account/devices/authorization'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "device_authorization_code", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        query_params = utils.get_query_params(operations.AuthorizeDeviceRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AuthorizeDeviceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def cancel_subscription(self, request: operations.CancelSubscriptionRequest, security: operations.CancelSubscriptionSecurity) -> operations.CancelSubscriptionResponse:
        r"""Cancel a plan subscription.
        
        A cancelled subscription will continue to be valid until the subscription
        expiry date or next renewal date.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.CancelSubscriptionRequest, base_url, '/account/billing/subscriptions/{id}', request)
        
        query_params = utils.get_query_params(operations.CancelSubscriptionRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CancelSubscriptionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def change_password(self, request: operations.ChangePasswordRequest, security: operations.ChangePasswordSecurity) -> operations.ChangePasswordResponse:
        r"""Change the password of an account.
        
        The expected token scope is Settings.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/account/password'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "change_password_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        query_params = utils.get_query_params(operations.ChangePasswordRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PUT', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ChangePasswordResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def change_pin(self, request: operations.ChangePinRequest, security: operations.ChangePinSecurity) -> operations.ChangePinResponse:
        r"""Change the pin of an account."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/account/pin'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "change_pin_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        query_params = utils.get_query_params(operations.ChangePinRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PUT', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ChangePinResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def create_profile(self, request: operations.CreateProfileRequest, security: operations.CreateProfileSecurity) -> operations.CreateProfileResponse:
        r"""Create a new profile under the active account."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/account/profiles'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "profile_creation_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        query_params = utils.get_query_params(operations.CreateProfileRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateProfileResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ProfileDetail])
                res.profile_detail = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def delete_profile_with_id(self, request: operations.DeleteProfileWithIDRequest, security: operations.DeleteProfileWithIDSecurity) -> operations.DeleteProfileWithIDResponse:
        r"""Delete a profile with a specific id under the active account.
        
        Note that you cannot delete the primary profile.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteProfileWithIDRequest, base_url, '/account/profiles/{id}', request)
        
        query_params = utils.get_query_params(operations.DeleteProfileWithIDRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteProfileWithIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def deregister_device(self, request: operations.DeregisterDeviceRequest, security: operations.DeregisterDeviceSecurity) -> operations.DeregisterDeviceResponse:
        r"""Deregister a playback device from an account."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeregisterDeviceRequest, base_url, '/account/devices/{id}', request)
        
        query_params = utils.get_query_params(operations.DeregisterDeviceRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeregisterDeviceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def generate_nonce(self, request: operations.GenerateNonceRequest, security: operations.GenerateNonceSecurity) -> operations.GenerateNonceResponse:
        r"""Generate a new account nonce.
        
        A nonce may be required to help sign a response from a third party
        service which will be passed back to these services.
        
        For example a Facebook single-sign-on request initiated by a client
        application may first get a nonce from here to include in the request.
        Facebook will then include the nonce in the auth token it issues. This
        token can be passed back to our services and the nonce checked for validity.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/account/nonce'
        
        query_params = utils.get_query_params(operations.GenerateNonceRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GenerateNonceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.AccountNonce])
                res.account_nonce = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def get_account(self, request: operations.GetAccountRequest, security: operations.GetAccountSecurity) -> operations.GetAccountResponse:
        r"""Get the details of an account along with the profiles and entitlements under it."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/account'
        
        query_params = utils.get_query_params(operations.GetAccountRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAccountResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.account = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def get_device(self, request: operations.GetDeviceRequest, security: operations.GetDeviceSecurity) -> operations.GetDeviceResponse:
        r"""Get a registered device."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetDeviceRequest, base_url, '/account/devices/{id}', request)
        
        query_params = utils.get_query_params(operations.GetDeviceRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetDeviceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Device])
                res.device = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def get_devices(self, request: operations.GetDevicesRequest, security: operations.GetDevicesSecurity) -> operations.GetDevicesResponse:
        r"""Get all devices registered under this account.
        
        Also includes information around device registration and deregistration limits.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/account/devices'
        
        query_params = utils.get_query_params(operations.GetDevicesRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetDevicesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.AccountDevices])
                res.account_devices = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def get_entitlements(self, request: operations.GetEntitlementsRequest, security: operations.GetEntitlementsSecurity) -> operations.GetEntitlementsResponse:
        r"""Get all entitlements under the account.
        
        This list is returned under the call to get account information so a call here is
        only required when wishing to refresh a local copy of entitlements.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/account/entitlements'
        
        query_params = utils.get_query_params(operations.GetEntitlementsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetEntitlementsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.Entitlement]])
                res.entitlements = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def get_item_media_files(self, request: operations.GetItemMediaFilesRequest, security: operations.GetItemMediaFilesSecurity) -> operations.GetItemMediaFilesResponse:
        r"""Get the video files associated with an item given maximum resolution, device type
        and one or more delivery types.
        
        This endpoint accepts an Account Catalog token, however if when requesting
        playback files you receive an *403 status code with error code 1* then the file
        you're requesting is classification restricted. This means you should switch
        to target the `/account/items/{id}/videos-guarded` endpoint, passing it an Account
        Playback token. If not already obtained, this token can be requested via the
        `/itv/pinauthorization` endpoint with an account level pin.
        
        For convenience you may also access free / public files through this endpoint
        instead of the /items/{id}/videos endpoint, when authenticated.
        
        Returns an array of video file objects which each include a url to a video.
        
        The first entry in the array contains what is predicted to be the best match.
        The remainder of the entries, if any, may contain resolutions below what was
        requests. For example if you request HD-720 the response may also contain
        SD entries.
        
        If you specify multiple delivery types, then the response array will insert
        types in the order you specify them in the query. For example `stream,progressive`
        would return an array with 0 or more stream files followed by 0 or more progressive files.
        
        If no files are found a 404 is returned.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetItemMediaFilesRequest, base_url, '/account/items/{id}/videos', request)
        
        query_params = utils.get_query_params(operations.GetItemMediaFilesRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetItemMediaFilesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.MediaFile]])
                res.media_files = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def get_item_media_files_guarded(self, request: operations.GetItemMediaFilesGuardedRequest, security: operations.GetItemMediaFilesGuardedSecurity) -> operations.GetItemMediaFilesGuardedResponse:
        r"""Get the video files associated with an item given maximum resolution, device type
        and one or more delivery types.
        
        This endpoint is identical to the `/account/items/{id}/videos` however it expects
        an Account Playback token. This token, and in association this endpoint, is specifically
        for use when playback files are classification restricted and require an account
        level pin to access them.
        
        Returns an array of video file objects which each include a url to a video.
        
        The first entry in the array contains what is predicted to be the best match.
        The remainder of the entries, if any, may contain resolutions below what was
        requests. For example if you request HD-720 the response may also contain
        SD entries.
        
        If you specify multiple delivery types, then the response array will insert
        types in the order you specify them in the query. For example `stream,progressive`
        would return an array with 0 or more stream files followed by 0 or more progressive files.
        
        If no files are found a 404 is returned.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetItemMediaFilesGuardedRequest, base_url, '/account/items/{id}/videos-guarded', request)
        
        query_params = utils.get_query_params(operations.GetItemMediaFilesGuardedRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetItemMediaFilesGuardedResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.MediaFile]])
                res.media_files = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def get_payment_method(self, request: operations.GetPaymentMethodRequest, security: operations.GetPaymentMethodSecurity) -> operations.GetPaymentMethodResponse:
        r"""Get a payment method under an account."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetPaymentMethodRequest, base_url, '/account/billing/methods/{id}', request)
        
        query_params = utils.get_query_params(operations.GetPaymentMethodRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetPaymentMethodResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PaymentMethod])
                res.payment_method = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def get_payment_methods(self, request: operations.GetPaymentMethodsRequest, security: operations.GetPaymentMethodsSecurity) -> operations.GetPaymentMethodsResponse:
        r"""Get the available payment methods under an account."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/account/billing/methods'
        
        query_params = utils.get_query_params(operations.GetPaymentMethodsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetPaymentMethodsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.PaymentMethod]])
                res.payment_methods = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def get_profile_with_id(self, request: operations.GetProfileWithIDRequest, security: operations.GetProfileWithIDSecurity) -> operations.GetProfileWithIDResponse:
        r"""Get the summary of a profile with a specific id under the active account."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetProfileWithIDRequest, base_url, '/account/profiles/{id}', request)
        
        query_params = utils.get_query_params(operations.GetProfileWithIDRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetProfileWithIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ProfileSummary])
                res.profile_summary = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def get_purchases(self, request: operations.GetPurchasesRequest, security: operations.GetPurchasesSecurity) -> operations.GetPurchasesResponse:
        r"""Get a list of all purchases made under an account."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/account/billing/purchases'
        
        query_params = utils.get_query_params(operations.GetPurchasesRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetPurchasesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.Purchase]])
                res.purchases = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def make_purchase(self, request: operations.MakePurchaseRequest, security: operations.MakePurchaseSecurity) -> operations.MakePurchaseResponse:
        r"""Purchase a plan or item offer.
        The result of a successful transaction is a new entitlement.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/account/billing/purchases'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "purchase_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        query_params = utils.get_query_params(operations.MakePurchaseRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.MakePurchaseResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Entitlement])
                res.entitlement = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def register_device(self, request: operations.RegisterDeviceRequest, security: operations.RegisterDeviceSecurity) -> operations.RegisterDeviceResponse:
        r"""Register a playback device under an account.
        
        If a device with the same id already exists a `409` conflict will be returned.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/account/devices'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "device_registration_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        query_params = utils.get_query_params(operations.RegisterDeviceRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.RegisterDeviceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Device])
                res.device = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def remove_payment_method(self, request: operations.RemovePaymentMethodRequest, security: operations.RemovePaymentMethodSecurity) -> operations.RemovePaymentMethodResponse:
        r"""Remove a payment method from an account."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.RemovePaymentMethodRequest, base_url, '/account/billing/methods/{id}', request)
        
        query_params = utils.get_query_params(operations.RemovePaymentMethodRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.RemovePaymentMethodResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def rename_device(self, request: operations.RenameDeviceRequest, security: operations.RenameDeviceSecurity) -> operations.RenameDeviceResponse:
        r"""Rename a device"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.RenameDeviceRequest, base_url, '/account/devices/{id}/name', request)
        
        query_params = utils.get_query_params(operations.RenameDeviceRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PUT', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.RenameDeviceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def request_email_verification(self, request: operations.RequestEmailVerificationRequest, security: operations.RequestEmailVerificationSecurity) -> operations.RequestEmailVerificationResponse:
        r"""Request that the email address tied to an account be verified.
        
        This will send a verification email to the email address of the primary profile containing
        a link which, once clicked, completes the verification process via the /verify-email endpoint.
        
        Note that when an account is created this email is sent automatically so there's no need
        to call this directly.
        
        If the user doesn't click the link before it expires then this endpoint can be called
        to request a new verification email. In the future it may also be used if we add support
        for changing an account email address.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/account/request-email-verification'
        
        query_params = utils.get_query_params(operations.RequestEmailVerificationRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.RequestEmailVerificationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def update_account(self, request: operations.UpdateAccountRequest, security: operations.UpdateAccountSecurity) -> operations.UpdateAccountResponse:
        r"""Update the details of an account.
        
        With the exception of the address, this supports partial updates, so you can send just the
        properties you wish to update.
        
        When the address is provided any properties which are omitted from the address will be cleared.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/account'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "account_update_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        query_params = utils.get_query_params(operations.UpdateAccountRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PATCH', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateAccountResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def update_profile_with_id(self, request: operations.UpdateProfileWithIDRequest, security: operations.UpdateProfileWithIDSecurity) -> operations.UpdateProfileWithIDResponse:
        r"""Update the summary of a profile with a specific id under the active account.
        
        This supports partial updates so you can send just the properties you wish to update.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.UpdateProfileWithIDRequest, base_url, '/account/profiles/{id}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "profile_update_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        query_params = utils.get_query_params(operations.UpdateProfileWithIDRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PATCH', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateProfileWithIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def update_subscription(self, request: operations.UpdateSubscriptionRequest, security: operations.UpdateSubscriptionSecurity) -> operations.UpdateSubscriptionResponse:
        r"""Renew a cancelled subscription or switch subscription to a different plan.
        
        When renewing a cancelled subscription membership, hit this endpoint with
        the id of subscription to renew.
        
        To switch plans provide the id of the current active subscription membership
        of the account, and in the query specify the id of the plan to switch to.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.UpdateSubscriptionRequest, base_url, '/account/billing/subscriptions/{id}', request)
        
        query_params = utils.get_query_params(operations.UpdateSubscriptionRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PUT', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateSubscriptionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    