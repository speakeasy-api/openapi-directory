"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Optional

class ProjectAPI:
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def create_project(self, request: operations.CreateProjectRequest) -> operations.CreateProjectResponse:
        r"""Create a project."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/projects'
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.CreateProjectRequest, request)
        
        client = self._client
        
        http_res = client.request('POST', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateProjectResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Project])
                res.project = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content
        else:
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CustomVisionError])
                res.custom_vision_error = out

        return res

    def delete_iteration(self, request: operations.DeleteIterationRequest) -> operations.DeleteIterationResponse:
        r"""Delete a specific iteration of a project."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteIterationRequest, base_url, '/projects/{projectId}/iterations/{iterationId}', request)
        
        headers = utils.get_headers(request)
        
        client = self._client
        
        http_res = client.request('DELETE', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteIterationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        else:
            if utils.match_content_type(content_type, '*/*'):
                res.body = http_res.content

        return res

    def delete_project(self, request: operations.DeleteProjectRequest) -> operations.DeleteProjectResponse:
        r"""Delete a specific project."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteProjectRequest, base_url, '/projects/{projectId}', request)
        
        headers = utils.get_headers(request)
        
        client = self._client
        
        http_res = client.request('DELETE', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteProjectResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        else:
            if utils.match_content_type(content_type, '*/*'):
                res.body = http_res.content

        return res

    def export_iteration(self, request: operations.ExportIterationRequest) -> operations.ExportIterationResponse:
        r"""Export a trained iteration."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ExportIterationRequest, base_url, '/projects/{projectId}/iterations/{iterationId}/export', request)
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.ExportIterationRequest, request)
        
        client = self._client
        
        http_res = client.request('POST', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ExportIterationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Export])
                res.export = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content
        else:
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CustomVisionError])
                res.custom_vision_error = out

        return res

    def get_exports(self, request: operations.GetExportsRequest) -> operations.GetExportsResponse:
        r"""Get the list of exports for a specific iteration."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetExportsRequest, base_url, '/projects/{projectId}/iterations/{iterationId}/export', request)
        
        headers = utils.get_headers(request)
        
        client = self._client
        
        http_res = client.request('GET', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetExportsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.Export]])
                res.exports = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content
        else:
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CustomVisionError])
                res.custom_vision_error = out

        return res

    def get_image_performance_count(self, request: operations.GetImagePerformanceCountRequest) -> operations.GetImagePerformanceCountResponse:
        r"""Gets the number of images tagged with the provided {tagIds} that have prediction results from
        training for the provided iteration {iterationId}.
        The filtering is on an and/or relationship. For example, if the provided tag ids are for the \"Dog\" and
        \"Cat\" tags, then only images tagged with Dog and/or Cat will be returned
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetImagePerformanceCountRequest, base_url, '/projects/{projectId}/iterations/{iterationId}/performance/images/count', request)
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.GetImagePerformanceCountRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetImagePerformanceCountResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[int])
                res.get_image_performance_count_200_application_json_int32_integer = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content
        else:
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CustomVisionError])
                res.custom_vision_error = out

        return res

    def get_image_performances(self, request: operations.GetImagePerformancesRequest) -> operations.GetImagePerformancesResponse:
        r"""Get image with its prediction for a given project iteration.
        This API supports batching and range selection. By default it will only return first 50 images matching images.
        Use the {take} and {skip} parameters to control how many images to return in a given batch.
        The filtering is on an and/or relationship. For example, if the provided tag ids are for the \"Dog\" and
        \"Cat\" tags, then only images tagged with Dog and/or Cat will be returned
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetImagePerformancesRequest, base_url, '/projects/{projectId}/iterations/{iterationId}/performance/images', request)
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.GetImagePerformancesRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetImagePerformancesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.ImagePerformance]])
                res.image_performances = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content
        else:
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CustomVisionError])
                res.custom_vision_error = out

        return res

    def get_iteration(self, request: operations.GetIterationRequest) -> operations.GetIterationResponse:
        r"""Get a specific iteration."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetIterationRequest, base_url, '/projects/{projectId}/iterations/{iterationId}', request)
        
        headers = utils.get_headers(request)
        
        client = self._client
        
        http_res = client.request('GET', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetIterationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Iteration])
                res.iteration = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content
        else:
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CustomVisionError])
                res.custom_vision_error = out

        return res

    def get_iteration_performance(self, request: operations.GetIterationPerformanceRequest) -> operations.GetIterationPerformanceResponse:
        r"""Get detailed performance information about an iteration."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetIterationPerformanceRequest, base_url, '/projects/{projectId}/iterations/{iterationId}/performance', request)
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.GetIterationPerformanceRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetIterationPerformanceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.IterationPerformance])
                res.iteration_performance = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content
        else:
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CustomVisionError])
                res.custom_vision_error = out

        return res

    def get_iterations(self, request: operations.GetIterationsRequest) -> operations.GetIterationsResponse:
        r"""Get iterations for the project."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetIterationsRequest, base_url, '/projects/{projectId}/iterations', request)
        
        headers = utils.get_headers(request)
        
        client = self._client
        
        http_res = client.request('GET', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetIterationsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.Iteration]])
                res.iterations = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content
        else:
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CustomVisionError])
                res.custom_vision_error = out

        return res

    def get_project(self, request: operations.GetProjectRequest) -> operations.GetProjectResponse:
        r"""Get a specific project."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetProjectRequest, base_url, '/projects/{projectId}', request)
        
        headers = utils.get_headers(request)
        
        client = self._client
        
        http_res = client.request('GET', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetProjectResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Project])
                res.project = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content
        else:
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CustomVisionError])
                res.custom_vision_error = out

        return res

    def get_projects(self, request: operations.GetProjectsRequest) -> operations.GetProjectsResponse:
        r"""Get your projects."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/projects'
        
        headers = utils.get_headers(request)
        
        client = self._client
        
        http_res = client.request('GET', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetProjectsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.Project]])
                res.projects = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content
        else:
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CustomVisionError])
                res.custom_vision_error = out

        return res

    def publish_iteration(self, request: operations.PublishIterationRequest) -> operations.PublishIterationResponse:
        r"""Publish a specific iteration."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PublishIterationRequest, base_url, '/projects/{projectId}/iterations/{iterationId}/publish', request)
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.PublishIterationRequest, request)
        
        client = self._client
        
        http_res = client.request('POST', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PublishIterationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[bool])
                res.publish_iteration_200_application_json_boolean = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content
        else:
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CustomVisionError])
                res.custom_vision_error = out

        return res

    def train_project(self, request: operations.TrainProjectRequest) -> operations.TrainProjectResponse:
        r"""Queues project for training."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.TrainProjectRequest, base_url, '/projects/{projectId}/train', request)
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.TrainProjectRequest, request)
        
        client = self._client
        
        http_res = client.request('POST', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.TrainProjectResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Iteration])
                res.iteration = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content
        else:
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CustomVisionError])
                res.custom_vision_error = out

        return res

    def unpublish_iteration(self, request: operations.UnpublishIterationRequest) -> operations.UnpublishIterationResponse:
        r"""Unpublish a specific iteration."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.UnpublishIterationRequest, base_url, '/projects/{projectId}/iterations/{iterationId}/publish', request)
        
        headers = utils.get_headers(request)
        
        client = self._client
        
        http_res = client.request('DELETE', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UnpublishIterationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        else:
            if utils.match_content_type(content_type, '*/*'):
                res.body = http_res.content

        return res

    def update_iteration_form(self, request: operations.UpdateIterationFormRequest) -> operations.UpdateIterationFormResponse:
        r"""Update a specific iteration."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.UpdateIterationFormRequest, base_url, '/projects/{projectId}/iterations/{iterationId}', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "iteration_input", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateIterationFormResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Iteration])
                res.iteration = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content
        else:
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CustomVisionError])
                res.custom_vision_error = out

        return res

    def update_iteration_json(self, request: operations.UpdateIterationJSONRequest) -> operations.UpdateIterationJSONResponse:
        r"""Update a specific iteration."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.UpdateIterationJSONRequest, base_url, '/projects/{projectId}/iterations/{iterationId}', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "iteration_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateIterationJSONResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Iteration])
                res.iteration = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content
        else:
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CustomVisionError])
                res.custom_vision_error = out

        return res

    def update_iteration_raw(self, request: operations.UpdateIterationRawRequest) -> operations.UpdateIterationRawResponse:
        r"""Update a specific iteration."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.UpdateIterationRawRequest, base_url, '/projects/{projectId}/iterations/{iterationId}', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'raw')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateIterationRawResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Iteration])
                res.iteration = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content
        else:
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CustomVisionError])
                res.custom_vision_error = out

        return res

    def update_project_form(self, request: operations.UpdateProjectFormRequest) -> operations.UpdateProjectFormResponse:
        r"""Update a specific project."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.UpdateProjectFormRequest, base_url, '/projects/{projectId}', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "project_input", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateProjectFormResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Project])
                res.project = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content
        else:
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CustomVisionError])
                res.custom_vision_error = out

        return res

    def update_project_json(self, request: operations.UpdateProjectJSONRequest) -> operations.UpdateProjectJSONResponse:
        r"""Update a specific project."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.UpdateProjectJSONRequest, base_url, '/projects/{projectId}', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "project_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateProjectJSONResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Project])
                res.project = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content
        else:
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CustomVisionError])
                res.custom_vision_error = out

        return res

    def update_project_raw(self, request: operations.UpdateProjectRawRequest) -> operations.UpdateProjectRawResponse:
        r"""Update a specific project."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.UpdateProjectRawRequest, base_url, '/projects/{projectId}', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'raw')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateProjectRawResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Project])
                res.project = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content
        else:
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CustomVisionError])
                res.custom_vision_error = out

        return res

    