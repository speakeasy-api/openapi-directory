"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared

SERVERS = [
    "http://cloudsearch.{region}.amazonaws.com",
    r"""The Amazon CloudSearch multi-region endpoint"""
    "https://cloudsearch.{region}.amazonaws.com",
    r"""The Amazon CloudSearch multi-region endpoint"""
    "http://cloudsearch.{region}.amazonaws.com.cn",
    r"""The Amazon CloudSearch endpoint for China (Beijing) and China (Ningxia)"""
    "https://cloudsearch.{region}.amazonaws.com.cn",
    r"""The Amazon CloudSearch endpoint for China (Beijing) and China (Ningxia)"""
]
"""Contains the list of servers available to the SDK"""

class SDK:
    r"""<fullname>Amazon CloudSearch Configuration Service</fullname> <p>You use the configuration service to create, configure, and manage search domains. Configuration service requests are submitted using the AWS Query protocol. AWS Query requests are HTTP or HTTPS requests submitted via HTTP GET or POST with a query parameter named Action.</p> <p>The endpoint for configuration service requests is region-specific: cloudsearch.<i>region</i>.amazonaws.com. For example, cloudsearch.us-east-1.amazonaws.com. For a current list of supported regions and endpoints, see <a href=\\"http://docs.aws.amazon.com/general/latest/gr/rande.html#cloudsearch_region\\">Regions and Endpoints</a>.</p>
    https://docs.aws.amazon.com/cloudsearch/ - Amazon Web Services documentation
    """

    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str = SERVERS[0]
    _language: str = "python"
    _sdk_version: str = "0.0.1"
    _gen_version: str = "internal"

    def __init__(self,
                 security: shared.Security = None,
                 server_url: str = None,
                 url_params: dict[str, str] = None,
                 client: requests_http.Session = None
                 ) -> None:
        """Instantiates the SDK configuring it with the provided parameters.
        
        :param security: The security details required for authentication
        :type security: shared.Security
        :param server_url: The server URL to use for all operations
        :type server_url: str
        :param url_params: Parameters to optionally template the server URL with
        :type url_params: dict[str, str]
        :param client: The requests.Session HTTP client to use for all operations
        :type client: requests_http.Session        
        """
        self._client = requests_http.Session()
        
        
        if server_url is not None:
            if url_params is not None:
                self._server_url = utils.template_url(server_url, url_params)
            else:
                self._server_url = server_url

        if client is not None:
            self._client = client
        
        self._security_client = utils.configure_security_client(self._client, security)
        

        
    
    
    def get_create_domain(self, request: operations.GETCreateDomainRequest) -> operations.GETCreateDomainResponse:
        r"""Creates a new search domain."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/#Action=CreateDomain'
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.GETCreateDomainRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GETCreateDomainResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [200, 409, 480, 500]:
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def get_define_rank_expression(self, request: operations.GETDefineRankExpressionRequest) -> operations.GETDefineRankExpressionResponse:
        r"""Configures a <code>RankExpression</code> for the search domain. Used to create new rank expressions and modify existing ones. If the expression exists, the new configuration replaces the old one. You can configure a maximum of 50 rank expressions."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/#Action=DefineRankExpression'
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.GETDefineRankExpressionRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GETDefineRankExpressionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [200, 409, 480, 500]:
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def get_delete_domain(self, request: operations.GETDeleteDomainRequest) -> operations.GETDeleteDomainResponse:
        r"""Permanently deletes a search domain and all of its data."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/#Action=DeleteDomain'
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.GETDeleteDomainRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GETDeleteDomainResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [200, 480, 500]:
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def get_delete_index_field(self, request: operations.GETDeleteIndexFieldRequest) -> operations.GETDeleteIndexFieldResponse:
        r"""Removes an <code>IndexField</code> from the search domain."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/#Action=DeleteIndexField'
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.GETDeleteIndexFieldRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GETDeleteIndexFieldResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [200, 409, 480, 500]:
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def get_delete_rank_expression(self, request: operations.GETDeleteRankExpressionRequest) -> operations.GETDeleteRankExpressionResponse:
        r"""Removes a <code>RankExpression</code> from the search domain."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/#Action=DeleteRankExpression'
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.GETDeleteRankExpressionRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GETDeleteRankExpressionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [200, 409, 480, 500]:
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def get_describe_availability_options(self, request: operations.GETDescribeAvailabilityOptionsRequest) -> operations.GETDescribeAvailabilityOptionsResponse:
        r"""Gets the availability options configured for a domain. By default, shows the configuration with any pending changes. Set the <code>Deployed</code> option to <code>true</code> to show the active configuration and exclude pending changes. For more information, see <a href=\\"http://docs.aws.amazon.com/cloudsearch/latest/developerguide/configuring-availability-options.html\\" target=\\"_blank\\">Configuring Availability Options</a> in the <i>Amazon CloudSearch Developer Guide</i>."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/#Action=DescribeAvailabilityOptions'
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.GETDescribeAvailabilityOptionsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GETDescribeAvailabilityOptionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [200, 409, 480, 500]:
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def get_describe_default_search_field(self, request: operations.GETDescribeDefaultSearchFieldRequest) -> operations.GETDescribeDefaultSearchFieldResponse:
        r"""Gets the default search field configured for the search domain."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/#Action=DescribeDefaultSearchField'
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.GETDescribeDefaultSearchFieldRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GETDescribeDefaultSearchFieldResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [200, 409, 480, 500]:
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def get_describe_domains(self, request: operations.GETDescribeDomainsRequest) -> operations.GETDescribeDomainsResponse:
        r"""Gets information about the search domains owned by this account. Can be limited to specific domains. Shows all domains by default."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/#Action=DescribeDomains'
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.GETDescribeDomainsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GETDescribeDomainsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [200, 480, 500]:
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def get_describe_index_fields(self, request: operations.GETDescribeIndexFieldsRequest) -> operations.GETDescribeIndexFieldsResponse:
        r"""Gets information about the index fields configured for the search domain. Can be limited to specific fields by name. Shows all fields by default."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/#Action=DescribeIndexFields'
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.GETDescribeIndexFieldsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GETDescribeIndexFieldsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [200, 409, 480, 500]:
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def get_describe_rank_expressions(self, request: operations.GETDescribeRankExpressionsRequest) -> operations.GETDescribeRankExpressionsResponse:
        r"""Gets the rank expressions configured for the search domain. Can be limited to specific rank expressions by name. Shows all rank expressions by default."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/#Action=DescribeRankExpressions'
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.GETDescribeRankExpressionsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GETDescribeRankExpressionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [200, 409, 480, 500]:
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def get_describe_service_access_policies(self, request: operations.GETDescribeServiceAccessPoliciesRequest) -> operations.GETDescribeServiceAccessPoliciesResponse:
        r"""Gets information about the resource-based policies that control access to the domain's document and search services."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/#Action=DescribeServiceAccessPolicies'
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.GETDescribeServiceAccessPoliciesRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GETDescribeServiceAccessPoliciesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [200, 409, 480, 500]:
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def get_describe_stemming_options(self, request: operations.GETDescribeStemmingOptionsRequest) -> operations.GETDescribeStemmingOptionsResponse:
        r"""Gets the stemming dictionary configured for the search domain."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/#Action=DescribeStemmingOptions'
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.GETDescribeStemmingOptionsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GETDescribeStemmingOptionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [200, 409, 480, 500]:
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def get_describe_stopword_options(self, request: operations.GETDescribeStopwordOptionsRequest) -> operations.GETDescribeStopwordOptionsResponse:
        r"""Gets the stopwords configured for the search domain."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/#Action=DescribeStopwordOptions'
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.GETDescribeStopwordOptionsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GETDescribeStopwordOptionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [200, 409, 480, 500]:
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def get_describe_synonym_options(self, request: operations.GETDescribeSynonymOptionsRequest) -> operations.GETDescribeSynonymOptionsResponse:
        r"""Gets the synonym dictionary configured for the search domain."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/#Action=DescribeSynonymOptions'
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.GETDescribeSynonymOptionsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GETDescribeSynonymOptionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [200, 409, 480, 500]:
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def get_index_documents(self, request: operations.GETIndexDocumentsRequest) -> operations.GETIndexDocumentsResponse:
        r"""Tells the search domain to start indexing its documents using the latest text processing options and <code>IndexFields</code>. This operation must be invoked to make options whose <a>OptionStatus</a> has <code>OptionState</code> of <code>RequiresIndexDocuments</code> visible in search results."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/#Action=IndexDocuments'
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.GETIndexDocumentsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GETIndexDocumentsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [200, 409, 480, 500]:
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def get_update_availability_options(self, request: operations.GETUpdateAvailabilityOptionsRequest) -> operations.GETUpdateAvailabilityOptionsResponse:
        r"""Configures the availability options for a domain. Enabling the Multi-AZ option expands an Amazon CloudSearch domain to an additional Availability Zone in the same Region to increase fault tolerance in the event of a service disruption. Changes to the Multi-AZ option can take about half an hour to become active. For more information, see <a href=\\"http://docs.aws.amazon.com/cloudsearch/latest/developerguide/configuring-availability-options.html\\" target=\\"_blank\\">Configuring Availability Options</a> in the <i>Amazon CloudSearch Developer Guide</i>."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/#Action=UpdateAvailabilityOptions'
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.GETUpdateAvailabilityOptionsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GETUpdateAvailabilityOptionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [200, 409, 480, 500]:
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def get_update_default_search_field(self, request: operations.GETUpdateDefaultSearchFieldRequest) -> operations.GETUpdateDefaultSearchFieldResponse:
        r"""Configures the default search field for the search domain. The default search field is the text field that is searched when a search request does not specify which fields to search. By default, it is configured to include the contents of all of the domain's text fields."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/#Action=UpdateDefaultSearchField'
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.GETUpdateDefaultSearchFieldRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GETUpdateDefaultSearchFieldResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [200, 409, 480, 500]:
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def get_update_service_access_policies(self, request: operations.GETUpdateServiceAccessPoliciesRequest) -> operations.GETUpdateServiceAccessPoliciesResponse:
        r"""Configures the policies that control access to the domain's document and search services. The maximum size of an access policy document is 100 KB."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/#Action=UpdateServiceAccessPolicies'
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.GETUpdateServiceAccessPoliciesRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GETUpdateServiceAccessPoliciesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [200, 409, 480, 500]:
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def get_update_stemming_options(self, request: operations.GETUpdateStemmingOptionsRequest) -> operations.GETUpdateStemmingOptionsResponse:
        r"""Configures a stemming dictionary for the search domain. The stemming dictionary is used during indexing and when processing search requests. The maximum size of the stemming dictionary is 500 KB."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/#Action=UpdateStemmingOptions'
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.GETUpdateStemmingOptionsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GETUpdateStemmingOptionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [200, 409, 480, 500]:
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def get_update_stopword_options(self, request: operations.GETUpdateStopwordOptionsRequest) -> operations.GETUpdateStopwordOptionsResponse:
        r"""Configures stopwords for the search domain. Stopwords are used during indexing and when processing search requests. The maximum size of the stopwords dictionary is 10 KB."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/#Action=UpdateStopwordOptions'
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.GETUpdateStopwordOptionsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GETUpdateStopwordOptionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [200, 409, 480, 500]:
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def get_update_synonym_options(self, request: operations.GETUpdateSynonymOptionsRequest) -> operations.GETUpdateSynonymOptionsResponse:
        r"""Configures a synonym dictionary for the search domain. The synonym dictionary is used during indexing to configure mappings for terms that occur in text fields. The maximum size of the synonym dictionary is 100 KB."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/#Action=UpdateSynonymOptions'
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.GETUpdateSynonymOptionsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GETUpdateSynonymOptionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [200, 409, 480, 500]:
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def post_create_domain(self, request: operations.POSTCreateDomainRequest) -> operations.POSTCreateDomainResponse:
        r"""Creates a new search domain."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/#Action=CreateDomain'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'raw')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.POSTCreateDomainRequest, request)
        
        client = self._security_client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.POSTCreateDomainResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [200, 409, 480, 500]:
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def post_define_index_field(self, request: operations.POSTDefineIndexFieldRequest) -> operations.POSTDefineIndexFieldResponse:
        r"""Configures an <code>IndexField</code> for the search domain. Used to create new fields and modify existing ones. If the field exists, the new configuration replaces the old one. You can configure a maximum of 200 index fields."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/#Action=DefineIndexField'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'raw')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.POSTDefineIndexFieldRequest, request)
        
        client = self._security_client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.POSTDefineIndexFieldResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [200, 409, 480, 500]:
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def post_define_rank_expression(self, request: operations.POSTDefineRankExpressionRequest) -> operations.POSTDefineRankExpressionResponse:
        r"""Configures a <code>RankExpression</code> for the search domain. Used to create new rank expressions and modify existing ones. If the expression exists, the new configuration replaces the old one. You can configure a maximum of 50 rank expressions."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/#Action=DefineRankExpression'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'raw')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.POSTDefineRankExpressionRequest, request)
        
        client = self._security_client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.POSTDefineRankExpressionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [200, 409, 480, 500]:
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def post_delete_domain(self, request: operations.POSTDeleteDomainRequest) -> operations.POSTDeleteDomainResponse:
        r"""Permanently deletes a search domain and all of its data."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/#Action=DeleteDomain'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'raw')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.POSTDeleteDomainRequest, request)
        
        client = self._security_client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.POSTDeleteDomainResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [200, 480, 500]:
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def post_delete_index_field(self, request: operations.POSTDeleteIndexFieldRequest) -> operations.POSTDeleteIndexFieldResponse:
        r"""Removes an <code>IndexField</code> from the search domain."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/#Action=DeleteIndexField'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'raw')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.POSTDeleteIndexFieldRequest, request)
        
        client = self._security_client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.POSTDeleteIndexFieldResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [200, 409, 480, 500]:
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def post_delete_rank_expression(self, request: operations.POSTDeleteRankExpressionRequest) -> operations.POSTDeleteRankExpressionResponse:
        r"""Removes a <code>RankExpression</code> from the search domain."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/#Action=DeleteRankExpression'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'raw')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.POSTDeleteRankExpressionRequest, request)
        
        client = self._security_client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.POSTDeleteRankExpressionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [200, 409, 480, 500]:
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def post_describe_availability_options(self, request: operations.POSTDescribeAvailabilityOptionsRequest) -> operations.POSTDescribeAvailabilityOptionsResponse:
        r"""Gets the availability options configured for a domain. By default, shows the configuration with any pending changes. Set the <code>Deployed</code> option to <code>true</code> to show the active configuration and exclude pending changes. For more information, see <a href=\\"http://docs.aws.amazon.com/cloudsearch/latest/developerguide/configuring-availability-options.html\\" target=\\"_blank\\">Configuring Availability Options</a> in the <i>Amazon CloudSearch Developer Guide</i>."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/#Action=DescribeAvailabilityOptions'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'raw')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.POSTDescribeAvailabilityOptionsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.POSTDescribeAvailabilityOptionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [200, 409, 480, 500]:
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def post_describe_default_search_field(self, request: operations.POSTDescribeDefaultSearchFieldRequest) -> operations.POSTDescribeDefaultSearchFieldResponse:
        r"""Gets the default search field configured for the search domain."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/#Action=DescribeDefaultSearchField'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'raw')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.POSTDescribeDefaultSearchFieldRequest, request)
        
        client = self._security_client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.POSTDescribeDefaultSearchFieldResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [200, 409, 480, 500]:
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def post_describe_domains(self, request: operations.POSTDescribeDomainsRequest) -> operations.POSTDescribeDomainsResponse:
        r"""Gets information about the search domains owned by this account. Can be limited to specific domains. Shows all domains by default."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/#Action=DescribeDomains'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'raw')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.POSTDescribeDomainsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.POSTDescribeDomainsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [200, 480, 500]:
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def post_describe_index_fields(self, request: operations.POSTDescribeIndexFieldsRequest) -> operations.POSTDescribeIndexFieldsResponse:
        r"""Gets information about the index fields configured for the search domain. Can be limited to specific fields by name. Shows all fields by default."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/#Action=DescribeIndexFields'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'raw')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.POSTDescribeIndexFieldsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.POSTDescribeIndexFieldsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [200, 409, 480, 500]:
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def post_describe_rank_expressions(self, request: operations.POSTDescribeRankExpressionsRequest) -> operations.POSTDescribeRankExpressionsResponse:
        r"""Gets the rank expressions configured for the search domain. Can be limited to specific rank expressions by name. Shows all rank expressions by default."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/#Action=DescribeRankExpressions'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'raw')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.POSTDescribeRankExpressionsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.POSTDescribeRankExpressionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [200, 409, 480, 500]:
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def post_describe_service_access_policies(self, request: operations.POSTDescribeServiceAccessPoliciesRequest) -> operations.POSTDescribeServiceAccessPoliciesResponse:
        r"""Gets information about the resource-based policies that control access to the domain's document and search services."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/#Action=DescribeServiceAccessPolicies'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'raw')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.POSTDescribeServiceAccessPoliciesRequest, request)
        
        client = self._security_client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.POSTDescribeServiceAccessPoliciesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [200, 409, 480, 500]:
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def post_describe_stemming_options(self, request: operations.POSTDescribeStemmingOptionsRequest) -> operations.POSTDescribeStemmingOptionsResponse:
        r"""Gets the stemming dictionary configured for the search domain."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/#Action=DescribeStemmingOptions'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'raw')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.POSTDescribeStemmingOptionsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.POSTDescribeStemmingOptionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [200, 409, 480, 500]:
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def post_describe_stopword_options(self, request: operations.POSTDescribeStopwordOptionsRequest) -> operations.POSTDescribeStopwordOptionsResponse:
        r"""Gets the stopwords configured for the search domain."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/#Action=DescribeStopwordOptions'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'raw')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.POSTDescribeStopwordOptionsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.POSTDescribeStopwordOptionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [200, 409, 480, 500]:
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def post_describe_synonym_options(self, request: operations.POSTDescribeSynonymOptionsRequest) -> operations.POSTDescribeSynonymOptionsResponse:
        r"""Gets the synonym dictionary configured for the search domain."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/#Action=DescribeSynonymOptions'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'raw')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.POSTDescribeSynonymOptionsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.POSTDescribeSynonymOptionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [200, 409, 480, 500]:
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def post_index_documents(self, request: operations.POSTIndexDocumentsRequest) -> operations.POSTIndexDocumentsResponse:
        r"""Tells the search domain to start indexing its documents using the latest text processing options and <code>IndexFields</code>. This operation must be invoked to make options whose <a>OptionStatus</a> has <code>OptionState</code> of <code>RequiresIndexDocuments</code> visible in search results."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/#Action=IndexDocuments'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'raw')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.POSTIndexDocumentsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.POSTIndexDocumentsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [200, 409, 480, 500]:
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def post_update_availability_options(self, request: operations.POSTUpdateAvailabilityOptionsRequest) -> operations.POSTUpdateAvailabilityOptionsResponse:
        r"""Configures the availability options for a domain. Enabling the Multi-AZ option expands an Amazon CloudSearch domain to an additional Availability Zone in the same Region to increase fault tolerance in the event of a service disruption. Changes to the Multi-AZ option can take about half an hour to become active. For more information, see <a href=\\"http://docs.aws.amazon.com/cloudsearch/latest/developerguide/configuring-availability-options.html\\" target=\\"_blank\\">Configuring Availability Options</a> in the <i>Amazon CloudSearch Developer Guide</i>."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/#Action=UpdateAvailabilityOptions'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'raw')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.POSTUpdateAvailabilityOptionsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.POSTUpdateAvailabilityOptionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [200, 409, 480, 500]:
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def post_update_default_search_field(self, request: operations.POSTUpdateDefaultSearchFieldRequest) -> operations.POSTUpdateDefaultSearchFieldResponse:
        r"""Configures the default search field for the search domain. The default search field is the text field that is searched when a search request does not specify which fields to search. By default, it is configured to include the contents of all of the domain's text fields."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/#Action=UpdateDefaultSearchField'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'raw')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.POSTUpdateDefaultSearchFieldRequest, request)
        
        client = self._security_client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.POSTUpdateDefaultSearchFieldResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [200, 409, 480, 500]:
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def post_update_service_access_policies(self, request: operations.POSTUpdateServiceAccessPoliciesRequest) -> operations.POSTUpdateServiceAccessPoliciesResponse:
        r"""Configures the policies that control access to the domain's document and search services. The maximum size of an access policy document is 100 KB."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/#Action=UpdateServiceAccessPolicies'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'raw')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.POSTUpdateServiceAccessPoliciesRequest, request)
        
        client = self._security_client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.POSTUpdateServiceAccessPoliciesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [200, 409, 480, 500]:
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def post_update_stemming_options(self, request: operations.POSTUpdateStemmingOptionsRequest) -> operations.POSTUpdateStemmingOptionsResponse:
        r"""Configures a stemming dictionary for the search domain. The stemming dictionary is used during indexing and when processing search requests. The maximum size of the stemming dictionary is 500 KB."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/#Action=UpdateStemmingOptions'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'raw')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.POSTUpdateStemmingOptionsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.POSTUpdateStemmingOptionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [200, 409, 480, 500]:
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def post_update_stopword_options(self, request: operations.POSTUpdateStopwordOptionsRequest) -> operations.POSTUpdateStopwordOptionsResponse:
        r"""Configures stopwords for the search domain. Stopwords are used during indexing and when processing search requests. The maximum size of the stopwords dictionary is 10 KB."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/#Action=UpdateStopwordOptions'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'raw')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.POSTUpdateStopwordOptionsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.POSTUpdateStopwordOptionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [200, 409, 480, 500]:
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def post_update_synonym_options(self, request: operations.POSTUpdateSynonymOptionsRequest) -> operations.POSTUpdateSynonymOptionsResponse:
        r"""Configures a synonym dictionary for the search domain. The synonym dictionary is used during indexing to configure mappings for terms that occur in text fields. The maximum size of the synonym dictionary is 100 KB."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/#Action=UpdateSynonymOptions'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'raw')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.POSTUpdateSynonymOptionsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.POSTUpdateSynonymOptionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [200, 409, 480, 500]:
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    