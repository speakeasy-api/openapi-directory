<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class SslCerts 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * Generates a short-lived X509 certificate containing the provided public key and signed by a private key specific to the target instance. Users may use the certificate to authenticate as themselves when connecting to the database.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\SqlSslCertsCreateEphemeralRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\SqlSslCertsCreateEphemeralSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\SqlSslCertsCreateEphemeralResponse
     */
	public function sqlSslCertsCreateEphemeral(
        \OpenAPI\OpenAPI\Models\Operations\SqlSslCertsCreateEphemeralRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\SqlSslCertsCreateEphemeralSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\SqlSslCertsCreateEphemeralResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/projects/{project}/instances/{instance}/createEphemeral', \OpenAPI\OpenAPI\Models\Operations\SqlSslCertsCreateEphemeralRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "sslCertsCreateEphemeralRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\SqlSslCertsCreateEphemeralRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SqlSslCertsCreateEphemeralResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->sslCert = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\SslCert', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Deletes the SSL certificate. For First Generation instances, the certificate remains valid until the instance is restarted.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\SqlSslCertsDeleteRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\SqlSslCertsDeleteSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\SqlSslCertsDeleteResponse
     */
	public function sqlSslCertsDelete(
        \OpenAPI\OpenAPI\Models\Operations\SqlSslCertsDeleteRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\SqlSslCertsDeleteSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\SqlSslCertsDeleteResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/projects/{project}/instances/{instance}/sslCerts/{sha1Fingerprint}', \OpenAPI\OpenAPI\Models\Operations\SqlSslCertsDeleteRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\SqlSslCertsDeleteRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SqlSslCertsDeleteResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->operation = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Operation', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Retrieves a particular SSL certificate. Does not include the private key (required for usage). The private key must be saved from the response to initial creation.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\SqlSslCertsGetRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\SqlSslCertsGetSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\SqlSslCertsGetResponse
     */
	public function sqlSslCertsGet(
        \OpenAPI\OpenAPI\Models\Operations\SqlSslCertsGetRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\SqlSslCertsGetSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\SqlSslCertsGetResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/projects/{project}/instances/{instance}/sslCerts/{sha1Fingerprint}', \OpenAPI\OpenAPI\Models\Operations\SqlSslCertsGetRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\SqlSslCertsGetRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SqlSslCertsGetResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->sslCert = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\SslCert', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Creates an SSL certificate and returns it along with the private key and server certificate authority. The new certificate will not be usable until the instance is restarted.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\SqlSslCertsInsertRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\SqlSslCertsInsertSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\SqlSslCertsInsertResponse
     */
	public function sqlSslCertsInsert(
        \OpenAPI\OpenAPI\Models\Operations\SqlSslCertsInsertRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\SqlSslCertsInsertSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\SqlSslCertsInsertResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/projects/{project}/instances/{instance}/sslCerts', \OpenAPI\OpenAPI\Models\Operations\SqlSslCertsInsertRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "sslCertsInsertRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\SqlSslCertsInsertRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SqlSslCertsInsertResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->sslCertsInsertResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\SslCertsInsertResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Lists all of the current SSL certificates for the instance.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\SqlSslCertsListRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\SqlSslCertsListSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\SqlSslCertsListResponse
     */
	public function sqlSslCertsList(
        \OpenAPI\OpenAPI\Models\Operations\SqlSslCertsListRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\SqlSslCertsListSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\SqlSslCertsListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/projects/{project}/instances/{instance}/sslCerts', \OpenAPI\OpenAPI\Models\Operations\SqlSslCertsListRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\SqlSslCertsListRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SqlSslCertsListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->sslCertsListResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\SslCertsListResponse', 'json');
            }
        }

        return $response;
    }
}