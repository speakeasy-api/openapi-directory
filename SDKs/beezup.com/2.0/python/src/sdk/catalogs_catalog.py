"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Optional

class CatalogsCatalog:
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def catalog_store_index(self, request: operations.CatalogStoreIndexRequest) -> operations.CatalogStoreIndexResponse:
        r"""Get the index of the catalog API for this store
        The operation will give you all the operations you will be able to do on this store for this API.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.CatalogStoreIndexRequest, base_url, '/v2/user/catalogs/{storeId}', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CatalogStoreIndexResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CatalogStoreIndex])
                res.catalog_store_index = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.BeezUPCommonErrorResponseMessage])
                res.beez_up_common_error_response_message = out

        return res

    def catalog_change_catalog_column_user_name(self, request: operations.CatalogChangeCatalogColumnUserNameRequest) -> operations.CatalogChangeCatalogColumnUserNameResponse:
        r"""Change Catalog Column User Name"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.CatalogChangeCatalogColumnUserNameRequest, base_url, '/v2/user/catalogs/{storeId}/catalogColumns/{columnId}/rename', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "change_user_column_name_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CatalogChangeCatalogColumnUserNameResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        elif http_res.status_code == 409:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ImportAlreadyInProgressResponse])
                res.import_already_in_progress_response = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.BeezUPCommonErrorResponseMessage])
                res.beez_up_common_error_response_message = out

        return res

    def catalog_change_custom_column_expression(self, request: operations.CatalogChangeCustomColumnExpressionRequest) -> operations.CatalogChangeCustomColumnExpressionResponse:
        r"""Change custom column expression"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.CatalogChangeCustomColumnExpressionRequest, base_url, '/v2/user/catalogs/{storeId}/customColumns/{columnId}/expression', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "change_custom_column_expression_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CatalogChangeCustomColumnExpressionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        elif http_res.status_code == 409:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ImportAlreadyInProgressResponse])
                res.import_already_in_progress_response = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.BeezUPCommonErrorResponseMessage])
                res.beez_up_common_error_response_message = out

        return res

    def catalog_change_custom_column_user_name(self, request: operations.CatalogChangeCustomColumnUserNameRequest) -> operations.CatalogChangeCustomColumnUserNameResponse:
        r"""Change Custom Column User Name"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.CatalogChangeCustomColumnUserNameRequest, base_url, '/v2/user/catalogs/{storeId}/customColumns/{columnId}/rename', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "change_user_column_name_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CatalogChangeCustomColumnUserNameResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        elif http_res.status_code == 409:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ImportAlreadyInProgressResponse])
                res.import_already_in_progress_response = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.BeezUPCommonErrorResponseMessage])
                res.beez_up_common_error_response_message = out

        return res

    def catalog_compute_expression(self, request: operations.CatalogComputeExpressionRequest) -> operations.CatalogComputeExpressionResponse:
        r"""Compute the expression for this catalog."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.CatalogComputeExpressionRequest, base_url, '/v2/user/catalogs/{storeId}/customColumns/computeExpression', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "compute_expression_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CatalogComputeExpressionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                res.catalog_compute_expression_200_application_json_string = http_res.content
        elif http_res.status_code == 400:
            if utils.match_content_type(content_type, 'application/json'):
                res.catalog_compute_expression_400_application_json_string = http_res.content
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.BeezUPCommonErrorResponseMessage])
                res.beez_up_common_error_response_message = out

        return res

    def catalog_delete_custom_column(self, request: operations.CatalogDeleteCustomColumnRequest) -> operations.CatalogDeleteCustomColumnResponse:
        r"""Delete custom column"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.CatalogDeleteCustomColumnRequest, base_url, '/v2/user/catalogs/{storeId}/customColumns/{columnId}', request)
        
        
        client = self._client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CatalogDeleteCustomColumnResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.BeezUPCommonErrorResponseMessage])
                res.beez_up_common_error_response_message = out

        return res

    def catalog_get_catalog_columns(self, request: operations.CatalogGetCatalogColumnsRequest) -> operations.CatalogGetCatalogColumnsResponse:
        r"""Get catalog column list"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.CatalogGetCatalogColumnsRequest, base_url, '/v2/user/catalogs/{storeId}/catalogColumns', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CatalogGetCatalogColumnsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CatalogColumnList])
                res.catalog_column_list = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.BeezUPCommonErrorResponseMessage])
                res.beez_up_common_error_response_message = out

        return res

    def catalog_get_categories(self, request: operations.CatalogGetCategoriesRequest) -> operations.CatalogGetCategoriesResponse:
        r"""Get category list"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.CatalogGetCategoriesRequest, base_url, '/v2/user/catalogs/{storeId}/categories', request)
        
        headers = utils.get_headers(request)
        
        client = self._client
        
        http_res = client.request('GET', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CatalogGetCategoriesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CategoryList])
                res.category_list = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.BeezUPCommonErrorResponseMessage])
                res.beez_up_common_error_response_message = out

        return res

    def catalog_get_custom_column_expression(self, request: operations.CatalogGetCustomColumnExpressionRequest) -> operations.CatalogGetCustomColumnExpressionResponse:
        r"""Get the encrypted custom column expression"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.CatalogGetCustomColumnExpressionRequest, base_url, '/v2/user/catalogs/{storeId}/customColumns/{columnId}/expression', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CatalogGetCustomColumnExpressionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                res.catalog_get_custom_column_expression_200_application_json_string = http_res.content
        elif http_res.status_code == 404:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.BeezUPCommonErrorResponseMessage])
                res.beez_up_common_error_response_message = out

        return res

    def catalog_get_custom_columns(self, request: operations.CatalogGetCustomColumnsRequest) -> operations.CatalogGetCustomColumnsResponse:
        r"""Get custom column list"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.CatalogGetCustomColumnsRequest, base_url, '/v2/user/catalogs/{storeId}/customColumns', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CatalogGetCustomColumnsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CustomColumnList])
                res.custom_column_list = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.BeezUPCommonErrorResponseMessage])
                res.beez_up_common_error_response_message = out

        return res

    def catalog_get_product_by_product_id(self, request: operations.CatalogGetProductByProductIDRequest) -> operations.CatalogGetProductByProductIDResponse:
        r"""Get product by ProductId"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.CatalogGetProductByProductIDRequest, base_url, '/v2/user/catalogs/{storeId}/products/{productId}', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CatalogGetProductByProductIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Product])
                res.product = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.BeezUPCommonErrorResponseMessage])
                res.beez_up_common_error_response_message = out

        return res

    def catalog_get_product_by_sku(self, request: operations.CatalogGetProductBySkuRequest) -> operations.CatalogGetProductBySkuResponse:
        r"""Get product by Sku"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.CatalogGetProductBySkuRequest, base_url, '/v2/user/catalogs/{storeId}/products', request)
        
        query_params = utils.get_query_params(operations.CatalogGetProductBySkuRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CatalogGetProductBySkuResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Product])
                res.product = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.BeezUPCommonErrorResponseMessage])
                res.beez_up_common_error_response_message = out

        return res

    def catalog_get_products(self, request: operations.CatalogGetProductsRequest) -> operations.CatalogGetProductsResponse:
        r"""Get product list"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.CatalogGetProductsRequest, base_url, '/v2/user/catalogs/{storeId}/products/list', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "get_products_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CatalogGetProductsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ProductList])
                res.product_list = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.BeezUPCommonErrorResponseMessage])
                res.beez_up_common_error_response_message = out

        return res

    def catalog_get_random_products(self, request: operations.CatalogGetRandomProductsRequest) -> operations.CatalogGetRandomProductsResponse:
        r"""Get random product list
        We will return 10 products randomly selected with all product values
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.CatalogGetRandomProductsRequest, base_url, '/v2/user/catalogs/{storeId}/products/random', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CatalogGetRandomProductsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.RandomProductList])
                res.random_product_list = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.BeezUPCommonErrorResponseMessage])
                res.beez_up_common_error_response_message = out

        return res

    def catalog_save_custom_column(self, request: operations.CatalogSaveCustomColumnRequest) -> operations.CatalogSaveCustomColumnResponse:
        r"""Create or replace a custom column"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.CatalogSaveCustomColumnRequest, base_url, '/v2/user/catalogs/{storeId}/customColumns/{columnId}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "create_custom_column_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CatalogSaveCustomColumnResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [204, 404]:
            pass
        elif http_res.status_code == 409:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ImportAlreadyInProgressResponse])
                res.import_already_in_progress_response = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.BeezUPCommonErrorResponseMessage])
                res.beez_up_common_error_response_message = out

        return res

    def importation_get_manual_update_last_input_config(self, request: operations.ImportationGetManualUpdateLastInputConfigRequest) -> operations.ImportationGetManualUpdateLastInputConfigResponse:
        r"""Get the last input configuration"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ImportationGetManualUpdateLastInputConfigRequest, base_url, '/v2/user/catalogs/{storeId}/inputConfiguration', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ImportationGetManualUpdateLastInputConfigResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.LastManualImportInputConfiguration])
                res.last_manual_import_input_configuration = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.BeezUPCommonErrorResponseMessage])
                res.beez_up_common_error_response_message = out

        return res

    