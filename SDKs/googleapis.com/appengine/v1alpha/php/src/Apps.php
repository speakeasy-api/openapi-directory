<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class Apps 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * Uploads the specified SSL certificate.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\AppengineAppsAuthorizedCertificatesCreateRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\AppengineAppsAuthorizedCertificatesCreateSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\AppengineAppsAuthorizedCertificatesCreateResponse
     */
	public function appengineAppsAuthorizedCertificatesCreate(
        \OpenAPI\OpenAPI\Models\Operations\AppengineAppsAuthorizedCertificatesCreateRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\AppengineAppsAuthorizedCertificatesCreateSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\AppengineAppsAuthorizedCertificatesCreateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1alpha/apps/{appsId}/authorizedCertificates', \OpenAPI\OpenAPI\Models\Operations\AppengineAppsAuthorizedCertificatesCreateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "authorizedCertificate", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\AppengineAppsAuthorizedCertificatesCreateRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\AppengineAppsAuthorizedCertificatesCreateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->authorizedCertificate = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AuthorizedCertificate', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Deletes the specified SSL certificate.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\AppengineAppsAuthorizedCertificatesDeleteRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\AppengineAppsAuthorizedCertificatesDeleteSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\AppengineAppsAuthorizedCertificatesDeleteResponse
     */
	public function appengineAppsAuthorizedCertificatesDelete(
        \OpenAPI\OpenAPI\Models\Operations\AppengineAppsAuthorizedCertificatesDeleteRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\AppengineAppsAuthorizedCertificatesDeleteSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\AppengineAppsAuthorizedCertificatesDeleteResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1alpha/apps/{appsId}/authorizedCertificates/{authorizedCertificatesId}', \OpenAPI\OpenAPI\Models\Operations\AppengineAppsAuthorizedCertificatesDeleteRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\AppengineAppsAuthorizedCertificatesDeleteRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\AppengineAppsAuthorizedCertificatesDeleteResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->empty = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Gets the specified SSL certificate.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\AppengineAppsAuthorizedCertificatesGetRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\AppengineAppsAuthorizedCertificatesGetSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\AppengineAppsAuthorizedCertificatesGetResponse
     */
	public function appengineAppsAuthorizedCertificatesGet(
        \OpenAPI\OpenAPI\Models\Operations\AppengineAppsAuthorizedCertificatesGetRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\AppengineAppsAuthorizedCertificatesGetSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\AppengineAppsAuthorizedCertificatesGetResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1alpha/apps/{appsId}/authorizedCertificates/{authorizedCertificatesId}', \OpenAPI\OpenAPI\Models\Operations\AppengineAppsAuthorizedCertificatesGetRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\AppengineAppsAuthorizedCertificatesGetRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\AppengineAppsAuthorizedCertificatesGetResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->authorizedCertificate = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AuthorizedCertificate', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Lists all SSL certificates the user is authorized to administer.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\AppengineAppsAuthorizedCertificatesListRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\AppengineAppsAuthorizedCertificatesListSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\AppengineAppsAuthorizedCertificatesListResponse
     */
	public function appengineAppsAuthorizedCertificatesList(
        \OpenAPI\OpenAPI\Models\Operations\AppengineAppsAuthorizedCertificatesListRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\AppengineAppsAuthorizedCertificatesListSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\AppengineAppsAuthorizedCertificatesListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1alpha/apps/{appsId}/authorizedCertificates', \OpenAPI\OpenAPI\Models\Operations\AppengineAppsAuthorizedCertificatesListRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\AppengineAppsAuthorizedCertificatesListRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\AppengineAppsAuthorizedCertificatesListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->listAuthorizedCertificatesResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ListAuthorizedCertificatesResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Updates the specified SSL certificate. To renew a certificate and maintain its existing domain mappings, update certificate_data with a new certificate. The new certificate must be applicable to the same domains as the original certificate. The certificate display_name may also be updated.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\AppengineAppsAuthorizedCertificatesPatchRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\AppengineAppsAuthorizedCertificatesPatchSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\AppengineAppsAuthorizedCertificatesPatchResponse
     */
	public function appengineAppsAuthorizedCertificatesPatch(
        \OpenAPI\OpenAPI\Models\Operations\AppengineAppsAuthorizedCertificatesPatchRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\AppengineAppsAuthorizedCertificatesPatchSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\AppengineAppsAuthorizedCertificatesPatchResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1alpha/apps/{appsId}/authorizedCertificates/{authorizedCertificatesId}', \OpenAPI\OpenAPI\Models\Operations\AppengineAppsAuthorizedCertificatesPatchRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "authorizedCertificate", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\AppengineAppsAuthorizedCertificatesPatchRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\AppengineAppsAuthorizedCertificatesPatchResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->authorizedCertificate = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AuthorizedCertificate', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Lists all domains the user is authorized to administer.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\AppengineAppsAuthorizedDomainsListRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\AppengineAppsAuthorizedDomainsListSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\AppengineAppsAuthorizedDomainsListResponse
     */
	public function appengineAppsAuthorizedDomainsList(
        \OpenAPI\OpenAPI\Models\Operations\AppengineAppsAuthorizedDomainsListRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\AppengineAppsAuthorizedDomainsListSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\AppengineAppsAuthorizedDomainsListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1alpha/apps/{appsId}/authorizedDomains', \OpenAPI\OpenAPI\Models\Operations\AppengineAppsAuthorizedDomainsListRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\AppengineAppsAuthorizedDomainsListRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\AppengineAppsAuthorizedDomainsListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->listAuthorizedDomainsResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ListAuthorizedDomainsResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Maps a domain to an application. A user must be authorized to administer a domain in order to map it to an application. For a list of available authorized domains, see AuthorizedDomains.ListAuthorizedDomains.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\AppengineAppsDomainMappingsCreateRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\AppengineAppsDomainMappingsCreateSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\AppengineAppsDomainMappingsCreateResponse
     */
	public function appengineAppsDomainMappingsCreate(
        \OpenAPI\OpenAPI\Models\Operations\AppengineAppsDomainMappingsCreateRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\AppengineAppsDomainMappingsCreateSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\AppengineAppsDomainMappingsCreateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1alpha/apps/{appsId}/domainMappings', \OpenAPI\OpenAPI\Models\Operations\AppengineAppsDomainMappingsCreateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "domainMapping", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\AppengineAppsDomainMappingsCreateRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\AppengineAppsDomainMappingsCreateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->operation = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Operation', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Deletes the specified domain mapping. A user must be authorized to administer the associated domain in order to delete a DomainMapping resource.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\AppengineAppsDomainMappingsDeleteRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\AppengineAppsDomainMappingsDeleteSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\AppengineAppsDomainMappingsDeleteResponse
     */
	public function appengineAppsDomainMappingsDelete(
        \OpenAPI\OpenAPI\Models\Operations\AppengineAppsDomainMappingsDeleteRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\AppengineAppsDomainMappingsDeleteSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\AppengineAppsDomainMappingsDeleteResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1alpha/apps/{appsId}/domainMappings/{domainMappingsId}', \OpenAPI\OpenAPI\Models\Operations\AppengineAppsDomainMappingsDeleteRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\AppengineAppsDomainMappingsDeleteRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\AppengineAppsDomainMappingsDeleteResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->operation = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Operation', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Gets the specified domain mapping.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\AppengineAppsDomainMappingsGetRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\AppengineAppsDomainMappingsGetSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\AppengineAppsDomainMappingsGetResponse
     */
	public function appengineAppsDomainMappingsGet(
        \OpenAPI\OpenAPI\Models\Operations\AppengineAppsDomainMappingsGetRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\AppengineAppsDomainMappingsGetSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\AppengineAppsDomainMappingsGetResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1alpha/apps/{appsId}/domainMappings/{domainMappingsId}', \OpenAPI\OpenAPI\Models\Operations\AppengineAppsDomainMappingsGetRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\AppengineAppsDomainMappingsGetRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\AppengineAppsDomainMappingsGetResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->domainMapping = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\DomainMapping', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Lists the domain mappings on an application.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\AppengineAppsDomainMappingsListRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\AppengineAppsDomainMappingsListSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\AppengineAppsDomainMappingsListResponse
     */
	public function appengineAppsDomainMappingsList(
        \OpenAPI\OpenAPI\Models\Operations\AppengineAppsDomainMappingsListRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\AppengineAppsDomainMappingsListSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\AppengineAppsDomainMappingsListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1alpha/apps/{appsId}/domainMappings', \OpenAPI\OpenAPI\Models\Operations\AppengineAppsDomainMappingsListRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\AppengineAppsDomainMappingsListRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\AppengineAppsDomainMappingsListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->listDomainMappingsResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ListDomainMappingsResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Updates the specified domain mapping. To map an SSL certificate to a domain mapping, update certificate_id to point to an AuthorizedCertificate resource. A user must be authorized to administer the associated domain in order to update a DomainMapping resource.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\AppengineAppsDomainMappingsPatchRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\AppengineAppsDomainMappingsPatchSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\AppengineAppsDomainMappingsPatchResponse
     */
	public function appengineAppsDomainMappingsPatch(
        \OpenAPI\OpenAPI\Models\Operations\AppengineAppsDomainMappingsPatchRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\AppengineAppsDomainMappingsPatchSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\AppengineAppsDomainMappingsPatchResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1alpha/apps/{appsId}/domainMappings/{domainMappingsId}', \OpenAPI\OpenAPI\Models\Operations\AppengineAppsDomainMappingsPatchRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "domainMapping", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\AppengineAppsDomainMappingsPatchRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\AppengineAppsDomainMappingsPatchResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->operation = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Operation', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Gets information about a location.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\AppengineAppsLocationsGetRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\AppengineAppsLocationsGetSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\AppengineAppsLocationsGetResponse
     */
	public function appengineAppsLocationsGet(
        \OpenAPI\OpenAPI\Models\Operations\AppengineAppsLocationsGetRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\AppengineAppsLocationsGetSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\AppengineAppsLocationsGetResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1alpha/apps/{appsId}/locations/{locationsId}', \OpenAPI\OpenAPI\Models\Operations\AppengineAppsLocationsGetRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\AppengineAppsLocationsGetRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\AppengineAppsLocationsGetResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->location = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Location', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Lists information about the supported locations for this service.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\AppengineAppsLocationsListRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\AppengineAppsLocationsListSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\AppengineAppsLocationsListResponse
     */
	public function appengineAppsLocationsList(
        \OpenAPI\OpenAPI\Models\Operations\AppengineAppsLocationsListRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\AppengineAppsLocationsListSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\AppengineAppsLocationsListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1alpha/apps/{appsId}/locations', \OpenAPI\OpenAPI\Models\Operations\AppengineAppsLocationsListRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\AppengineAppsLocationsListRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\AppengineAppsLocationsListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->listLocationsResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ListLocationsResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Gets the latest state of a long-running operation. Clients can use this method to poll the operation result at intervals as recommended by the API service.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\AppengineAppsOperationsGetRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\AppengineAppsOperationsGetSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\AppengineAppsOperationsGetResponse
     */
	public function appengineAppsOperationsGet(
        \OpenAPI\OpenAPI\Models\Operations\AppengineAppsOperationsGetRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\AppengineAppsOperationsGetSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\AppengineAppsOperationsGetResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1alpha/apps/{appsId}/operations/{operationsId}', \OpenAPI\OpenAPI\Models\Operations\AppengineAppsOperationsGetRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\AppengineAppsOperationsGetRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\AppengineAppsOperationsGetResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->operation = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Operation', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Lists operations that match the specified filter in the request. If the server doesn't support this method, it returns UNIMPLEMENTED.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\AppengineAppsOperationsListRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\AppengineAppsOperationsListSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\AppengineAppsOperationsListResponse
     */
	public function appengineAppsOperationsList(
        \OpenAPI\OpenAPI\Models\Operations\AppengineAppsOperationsListRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\AppengineAppsOperationsListSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\AppengineAppsOperationsListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1alpha/apps/{appsId}/operations', \OpenAPI\OpenAPI\Models\Operations\AppengineAppsOperationsListRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\AppengineAppsOperationsListRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\AppengineAppsOperationsListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->listOperationsResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ListOperationsResponse', 'json');
            }
        }

        return $response;
    }
}