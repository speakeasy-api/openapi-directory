"use strict";
/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Users = void 0;
var utils = __importStar(require("../internal/utils"));
var operations = __importStar(require("./models/operations"));
var shared = __importStar(require("./models/shared"));
/**
 * Interact with and view information about users and also current user.
 */
var Users = /** @class */ (function () {
    function Users(defaultClient, securityClient, serverURL, language, sdkVersion, genVersion) {
        this._defaultClient = defaultClient;
        this._securityClient = securityClient;
        this._serverURL = serverURL;
        this._language = language;
        this._sdkVersion = sdkVersion;
        this._genVersion = genVersion;
    }
    /**
     * Add an email address for the authenticated user
     *
     * @remarks
     * This endpoint is accessible with the `user` scope.
     *
     * @see {@link https://docs.github.com/rest/reference/users#add-an-email-address-for-the-authenticated-user} - API method documentation
     */
    Users.prototype.usersAddEmailForAuthenticatedUser = function (req, config) {
        var _a;
        var baseURL = this._serverURL;
        var url = baseURL.replace(/\/$/, "") + "/user/emails";
        var _b = [{}, {}], reqBodyHeaders = _b[0], reqBody = _b[1];
        try {
            _a = utils.serializeRequestBody(req, "request", "json"), reqBodyHeaders = _a[0], reqBody = _a[1];
        }
        catch (e) {
            if (e instanceof Error) {
                throw new Error("Error serializing request body, cause: ".concat(e.message));
            }
        }
        var client = this._defaultClient;
        var headers = __assign(__assign({}, reqBodyHeaders), config === null || config === void 0 ? void 0 : config.headers);
        var r = client.request(__assign({ url: url, method: "post", headers: headers, data: reqBody }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.UsersAddEmailForAuthenticatedUserResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 201:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.emails = [];
                        var resFieldDepth = utils.getResFieldDepth(res);
                        res.emails = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.Email, resFieldDepth);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 304:
                    break;
                case [401, 403, 404].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.basicError = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.BasicError);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 422:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.validationError = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.ValidationError);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * Block a user
     *
     * @see {@link https://docs.github.com/rest/reference/users#block-a-user} - API method documentation
     */
    Users.prototype.usersBlock = function (req, config) {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.UsersBlockRequest(req);
        }
        var baseURL = this._serverURL;
        var url = utils.generateURL(baseURL, "/user/blocks/{username}", req);
        var client = this._defaultClient;
        var r = client.request(__assign({ url: url, method: "put" }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.UsersBlockResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case [204, 304].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    break;
                case [401, 403, 404].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.basicError = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.BasicError);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 422:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.validationError = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.ValidationError);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * Check if a user is blocked by the authenticated user
     *
     * @see {@link https://docs.github.com/rest/reference/users#check-if-a-user-is-blocked-by-the-authenticated-user} - API method documentation
     */
    Users.prototype.usersCheckBlocked = function (req, config) {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.UsersCheckBlockedRequest(req);
        }
        var baseURL = this._serverURL;
        var url = utils.generateURL(baseURL, "/user/blocks/{username}", req);
        var client = this._defaultClient;
        var r = client.request(__assign({ url: url, method: "get" }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.UsersCheckBlockedResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case [204, 304].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    break;
                case [401, 403, 404].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.basicError = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.BasicError);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * Check if a user follows another user
     *
     * @see {@link https://docs.github.com/rest/reference/users#check-if-a-user-follows-another-user} - API method documentation
     */
    Users.prototype.usersCheckFollowingForUser = function (req, config) {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.UsersCheckFollowingForUserRequest(req);
        }
        var baseURL = this._serverURL;
        var url = utils.generateURL(baseURL, "/users/{username}/following/{target_user}", req);
        var client = this._defaultClient;
        var r = client.request(__assign({ url: url, method: "get" }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.UsersCheckFollowingForUserResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case [204, 404].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    break;
            }
            return res;
        });
    };
    /**
     * Check if a person is followed by the authenticated user
     *
     * @see {@link https://docs.github.com/rest/reference/users#check-if-a-person-is-followed-by-the-authenticated-user} - API method documentation
     */
    Users.prototype.usersCheckPersonIsFollowedByAuthenticated = function (req, config) {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.UsersCheckPersonIsFollowedByAuthenticatedRequest(req);
        }
        var baseURL = this._serverURL;
        var url = utils.generateURL(baseURL, "/user/following/{username}", req);
        var client = this._defaultClient;
        var r = client.request(__assign({ url: url, method: "get" }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.UsersCheckPersonIsFollowedByAuthenticatedResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case [204, 304].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    break;
                case [401, 403, 404].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.basicError = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.BasicError);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * Create a GPG key for the authenticated user
     *
     * @remarks
     * Adds a GPG key to the authenticated user's GitHub account. Requires that you are authenticated via Basic Auth, or OAuth with at least `write:gpg_key` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     *
     * @see {@link https://docs.github.com/rest/reference/users#create-a-gpg-key-for-the-authenticated-user} - API method documentation
     */
    Users.prototype.usersCreateGpgKeyForAuthenticatedUser = function (req, config) {
        var _a;
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.UsersCreateGpgKeyForAuthenticatedUserRequestBody(req);
        }
        var baseURL = this._serverURL;
        var url = baseURL.replace(/\/$/, "") + "/user/gpg_keys";
        var _b = [{}, {}], reqBodyHeaders = _b[0], reqBody = _b[1];
        try {
            _a = utils.serializeRequestBody(req, "request", "json"), reqBodyHeaders = _a[0], reqBody = _a[1];
        }
        catch (e) {
            if (e instanceof Error) {
                throw new Error("Error serializing request body, cause: ".concat(e.message));
            }
        }
        var client = this._defaultClient;
        var headers = __assign(__assign({}, reqBodyHeaders), config === null || config === void 0 ? void 0 : config.headers);
        if (reqBody == null || Object.keys(reqBody).length === 0)
            throw new Error("request body is required");
        var r = client.request(__assign({ url: url, method: "post", headers: headers, data: reqBody }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.UsersCreateGpgKeyForAuthenticatedUserResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 201:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.gpgKey = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.GpgKey);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 304:
                    break;
                case [401, 403, 404].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.basicError = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.BasicError);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 422:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.validationError = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.ValidationError);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * Create a public SSH key for the authenticated user
     *
     * @remarks
     * Adds a public SSH key to the authenticated user's GitHub account. Requires that you are authenticated via Basic Auth, or OAuth with at least `write:public_key` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     *
     * @see {@link https://docs.github.com/rest/reference/users#create-a-public-ssh-key-for-the-authenticated-user} - API method documentation
     */
    Users.prototype.usersCreatePublicSshKeyForAuthenticatedUser = function (req, config) {
        var _a;
        if (!(req instanceof utils.SpeakeasyBase)) {
            req =
                new operations.UsersCreatePublicSshKeyForAuthenticatedUserRequestBody(req);
        }
        var baseURL = this._serverURL;
        var url = baseURL.replace(/\/$/, "") + "/user/keys";
        var _b = [{}, {}], reqBodyHeaders = _b[0], reqBody = _b[1];
        try {
            _a = utils.serializeRequestBody(req, "request", "json"), reqBodyHeaders = _a[0], reqBody = _a[1];
        }
        catch (e) {
            if (e instanceof Error) {
                throw new Error("Error serializing request body, cause: ".concat(e.message));
            }
        }
        var client = this._defaultClient;
        var headers = __assign(__assign({}, reqBodyHeaders), config === null || config === void 0 ? void 0 : config.headers);
        if (reqBody == null || Object.keys(reqBody).length === 0)
            throw new Error("request body is required");
        var r = client.request(__assign({ url: url, method: "post", headers: headers, data: reqBody }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.UsersCreatePublicSshKeyForAuthenticatedUserResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 201:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.key = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.Key);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 304:
                    break;
                case [401, 403, 404].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.basicError = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.BasicError);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 422:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.validationError = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.ValidationError);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * Create a SSH signing key for the authenticated user
     *
     * @remarks
     * Creates an SSH signing key for the authenticated user's GitHub account. You must authenticate with Basic Authentication, or you must authenticate with OAuth with at least `write:ssh_signing_key` scope. For more information, see "[Understanding scopes for OAuth apps](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/)."
     *
     * @see {@link https://docs.github.com/rest/reference/users#create-an-ssh-signing-key-for-the-authenticated-user} - API method documentation
     */
    Users.prototype.usersCreateSshSigningKeyForAuthenticatedUser = function (req, config) {
        var _a;
        if (!(req instanceof utils.SpeakeasyBase)) {
            req =
                new operations.UsersCreateSshSigningKeyForAuthenticatedUserRequestBody(req);
        }
        var baseURL = this._serverURL;
        var url = baseURL.replace(/\/$/, "") + "/user/ssh_signing_keys";
        var _b = [{}, {}], reqBodyHeaders = _b[0], reqBody = _b[1];
        try {
            _a = utils.serializeRequestBody(req, "request", "json"), reqBodyHeaders = _a[0], reqBody = _a[1];
        }
        catch (e) {
            if (e instanceof Error) {
                throw new Error("Error serializing request body, cause: ".concat(e.message));
            }
        }
        var client = this._defaultClient;
        var headers = __assign(__assign({}, reqBodyHeaders), config === null || config === void 0 ? void 0 : config.headers);
        if (reqBody == null || Object.keys(reqBody).length === 0)
            throw new Error("request body is required");
        var r = client.request(__assign({ url: url, method: "post", headers: headers, data: reqBody }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.UsersCreateSshSigningKeyForAuthenticatedUserResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 201:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.sshSigningKey = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.SshSigningKey);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 304:
                    break;
                case [401, 403, 404].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.basicError = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.BasicError);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 422:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.validationError = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.ValidationError);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * Delete an email address for the authenticated user
     *
     * @remarks
     * This endpoint is accessible with the `user` scope.
     *
     * @see {@link https://docs.github.com/rest/reference/users#delete-an-email-address-for-the-authenticated-user} - API method documentation
     */
    Users.prototype.usersDeleteEmailForAuthenticatedUser = function (req, config) {
        var _a;
        var baseURL = this._serverURL;
        var url = baseURL.replace(/\/$/, "") + "/user/emails";
        var _b = [{}, {}], reqBodyHeaders = _b[0], reqBody = _b[1];
        try {
            _a = utils.serializeRequestBody(req, "request", "json"), reqBodyHeaders = _a[0], reqBody = _a[1];
        }
        catch (e) {
            if (e instanceof Error) {
                throw new Error("Error serializing request body, cause: ".concat(e.message));
            }
        }
        var client = this._defaultClient;
        var headers = __assign(__assign({}, reqBodyHeaders), config === null || config === void 0 ? void 0 : config.headers);
        var r = client.request(__assign({ url: url, method: "delete", headers: headers, data: reqBody }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.UsersDeleteEmailForAuthenticatedUserResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case [204, 304].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    break;
                case [401, 403, 404].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.basicError = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.BasicError);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 422:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.validationError = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.ValidationError);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * Delete a GPG key for the authenticated user
     *
     * @remarks
     * Removes a GPG key from the authenticated user's GitHub account. Requires that you are authenticated via Basic Auth or via OAuth with at least `admin:gpg_key` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     *
     * @see {@link https://docs.github.com/rest/reference/users#delete-a-gpg-key-for-the-authenticated-user} - API method documentation
     */
    Users.prototype.usersDeleteGpgKeyForAuthenticatedUser = function (req, config) {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.UsersDeleteGpgKeyForAuthenticatedUserRequest(req);
        }
        var baseURL = this._serverURL;
        var url = utils.generateURL(baseURL, "/user/gpg_keys/{gpg_key_id}", req);
        var client = this._defaultClient;
        var r = client.request(__assign({ url: url, method: "delete" }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.UsersDeleteGpgKeyForAuthenticatedUserResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case [204, 304].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    break;
                case [401, 403, 404].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.basicError = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.BasicError);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 422:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.validationError = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.ValidationError);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * Delete a public SSH key for the authenticated user
     *
     * @remarks
     * Removes a public SSH key from the authenticated user's GitHub account. Requires that you are authenticated via Basic Auth or via OAuth with at least `admin:public_key` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     *
     * @see {@link https://docs.github.com/rest/reference/users#delete-a-public-ssh-key-for-the-authenticated-user} - API method documentation
     */
    Users.prototype.usersDeletePublicSshKeyForAuthenticatedUser = function (req, config) {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.UsersDeletePublicSshKeyForAuthenticatedUserRequest(req);
        }
        var baseURL = this._serverURL;
        var url = utils.generateURL(baseURL, "/user/keys/{key_id}", req);
        var client = this._defaultClient;
        var r = client.request(__assign({ url: url, method: "delete" }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.UsersDeletePublicSshKeyForAuthenticatedUserResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case [204, 304].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    break;
                case [401, 403, 404].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.basicError = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.BasicError);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * Delete an SSH signing key for the authenticated user
     *
     * @remarks
     * Deletes an SSH signing key from the authenticated user's GitHub account. You must authenticate with Basic Authentication, or you must authenticate with OAuth with at least `admin:ssh_signing_key` scope. For more information, see "[Understanding scopes for OAuth apps](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/)."
     *
     * @see {@link https://docs.github.com/rest/reference/users#delete-a-ssh-signing-key-for-the-authenticated-user} - API method documentation
     */
    Users.prototype.usersDeleteSshSigningKeyForAuthenticatedUser = function (req, config) {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.UsersDeleteSshSigningKeyForAuthenticatedUserRequest(req);
        }
        var baseURL = this._serverURL;
        var url = utils.generateURL(baseURL, "/user/ssh_signing_keys/{ssh_signing_key_id}", req);
        var client = this._defaultClient;
        var r = client.request(__assign({ url: url, method: "delete" }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.UsersDeleteSshSigningKeyForAuthenticatedUserResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case [204, 304].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    break;
                case [401, 403, 404].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.basicError = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.BasicError);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * Follow a user
     *
     * @remarks
     * Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs)."
     *
     * Following a user requires the user to be logged in and authenticated with basic auth or OAuth with the `user:follow` scope.
     *
     * @see {@link https://docs.github.com/rest/reference/users#follow-a-user} - API method documentation
     */
    Users.prototype.usersFollow = function (req, config) {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.UsersFollowRequest(req);
        }
        var baseURL = this._serverURL;
        var url = utils.generateURL(baseURL, "/user/following/{username}", req);
        var client = this._defaultClient;
        var r = client.request(__assign({ url: url, method: "put" }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.UsersFollowResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case [204, 304].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    break;
                case [401, 403, 404].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.basicError = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.BasicError);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * Get the authenticated user
     *
     * @remarks
     * If the authenticated user is authenticated through basic authentication or OAuth with the `user` scope, then the response lists public and private profile information.
     *
     * If the authenticated user is authenticated through OAuth without the `user` scope, then the response lists only public profile information.
     *
     * @see {@link https://docs.github.com/rest/reference/users#get-the-authenticated-user} - API method documentation
     */
    Users.prototype.usersGetAuthenticated = function (config) {
        var baseURL = this._serverURL;
        var url = baseURL.replace(/\/$/, "") + "/user";
        var client = this._defaultClient;
        var r = client.request(__assign({ url: url, method: "get" }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.UsersGetAuthenticatedResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 200:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.usersGetAuthenticated200ApplicationJSONOneOf = httpRes === null || httpRes === void 0 ? void 0 : httpRes.data;
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 304:
                    break;
                case [401, 403].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.basicError = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.BasicError);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * Get a user
     *
     * @remarks
     * Provides publicly available information about someone with a GitHub account.
     *
     * GitHub Apps with the `Plan` user permission can use this endpoint to retrieve information about a user's GitHub plan. The GitHub App must be authenticated as a user. See "[Identifying and authorizing users for GitHub Apps](https://docs.github.com/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/)" for details about authentication. For an example response, see 'Response with GitHub plan information' below"
     *
     * The `email` key in the following response is the publicly visible email address from your GitHub [profile page](https://github.com/settings/profile). When setting up your profile, you can select a primary email address to be “public” which provides an email entry for this endpoint. If you do not set a public email address for `email`, then it will have a value of `null`. You only see publicly visible email addresses when authenticated with GitHub. For more information, see [Authentication](https://docs.github.com/rest/overview/resources-in-the-rest-api#authentication).
     *
     * The Emails API enables you to list all of your email addresses, and toggle a primary email to be visible publicly. For more information, see "[Emails API](https://docs.github.com/rest/reference/users#emails)".
     *
     * @see {@link https://docs.github.com/rest/reference/users#get-a-user} - API method documentation
     */
    Users.prototype.usersGetByUsername = function (req, config) {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.UsersGetByUsernameRequest(req);
        }
        var baseURL = this._serverURL;
        var url = utils.generateURL(baseURL, "/users/{username}", req);
        var client = this._defaultClient;
        var r = client.request(__assign({ url: url, method: "get" }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.UsersGetByUsernameResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 200:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.usersGetByUsername200ApplicationJSONOneOf = httpRes === null || httpRes === void 0 ? void 0 : httpRes.data;
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 404:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.basicError = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.BasicError);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * Get contextual information for a user
     *
     * @remarks
     * Provides hovercard information when authenticated through basic auth or OAuth with the `repo` scope. You can find out more about someone in relation to their pull requests, issues, repositories, and organizations.
     *
     * The `subject_type` and `subject_id` parameters provide context for the person's hovercard, which returns more information than without the parameters. For example, if you wanted to find out more about `octocat` who owns the `Spoon-Knife` repository via cURL, it would look like this:
     *
     * ```shell
     *  curl -u username:token
     *   https://api.github.com/users/octocat/hovercard?subject_type=repository&subject_id=1300192
     * ```
     *
     * @see {@link https://docs.github.com/rest/reference/users#get-contextual-information-for-a-user} - API method documentation
     */
    Users.prototype.usersGetContextForUser = function (req, config) {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.UsersGetContextForUserRequest(req);
        }
        var baseURL = this._serverURL;
        var url = utils.generateURL(baseURL, "/users/{username}/hovercard", req);
        var client = this._defaultClient;
        var queryParams = utils.serializeQueryParams(req);
        var r = client.request(__assign({ url: url + queryParams, method: "get" }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.UsersGetContextForUserResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 200:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.hovercard = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.Hovercard);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 404:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.basicError = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.BasicError);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 422:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.validationError = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.ValidationError);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * Get a GPG key for the authenticated user
     *
     * @remarks
     * View extended details for a single GPG key. Requires that you are authenticated via Basic Auth or via OAuth with at least `read:gpg_key` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     *
     * @see {@link https://docs.github.com/rest/reference/users#get-a-gpg-key-for-the-authenticated-user} - API method documentation
     */
    Users.prototype.usersGetGpgKeyForAuthenticatedUser = function (req, config) {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.UsersGetGpgKeyForAuthenticatedUserRequest(req);
        }
        var baseURL = this._serverURL;
        var url = utils.generateURL(baseURL, "/user/gpg_keys/{gpg_key_id}", req);
        var client = this._defaultClient;
        var r = client.request(__assign({ url: url, method: "get" }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.UsersGetGpgKeyForAuthenticatedUserResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 200:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.gpgKey = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.GpgKey);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 304:
                    break;
                case [401, 403, 404].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.basicError = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.BasicError);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * Get a public SSH key for the authenticated user
     *
     * @remarks
     * View extended details for a single public SSH key. Requires that you are authenticated via Basic Auth or via OAuth with at least `read:public_key` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     *
     * @see {@link https://docs.github.com/rest/reference/users#get-a-public-ssh-key-for-the-authenticated-user} - API method documentation
     */
    Users.prototype.usersGetPublicSshKeyForAuthenticatedUser = function (req, config) {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.UsersGetPublicSshKeyForAuthenticatedUserRequest(req);
        }
        var baseURL = this._serverURL;
        var url = utils.generateURL(baseURL, "/user/keys/{key_id}", req);
        var client = this._defaultClient;
        var r = client.request(__assign({ url: url, method: "get" }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.UsersGetPublicSshKeyForAuthenticatedUserResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 200:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.key = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.Key);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 304:
                    break;
                case [401, 403, 404].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.basicError = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.BasicError);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * Get an SSH signing key for the authenticated user
     *
     * @remarks
     * Gets extended details for an SSH signing key. You must authenticate with Basic Authentication, or you must authenticate with OAuth with at least `read:ssh_signing_key` scope. For more information, see "[Understanding scopes for OAuth apps](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/)."
     *
     * @see {@link https://docs.github.com/rest/reference/users#get-a-ssh-signing-key-for-the-authenticated-user} - API method documentation
     */
    Users.prototype.usersGetSshSigningKeyForAuthenticatedUser = function (req, config) {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.UsersGetSshSigningKeyForAuthenticatedUserRequest(req);
        }
        var baseURL = this._serverURL;
        var url = utils.generateURL(baseURL, "/user/ssh_signing_keys/{ssh_signing_key_id}", req);
        var client = this._defaultClient;
        var r = client.request(__assign({ url: url, method: "get" }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.UsersGetSshSigningKeyForAuthenticatedUserResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 200:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.sshSigningKey = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.SshSigningKey);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 304:
                    break;
                case [401, 403, 404].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.basicError = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.BasicError);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * List users
     *
     * @remarks
     * Lists all users, in the order that they signed up on GitHub. This list includes personal user accounts and organization accounts.
     *
     * Note: Pagination is powered exclusively by the `since` parameter. Use the [Link header](https://docs.github.com/rest/overview/resources-in-the-rest-api#link-header) to get the URL for the next page of users.
     *
     * @see {@link https://docs.github.com/rest/reference/users#list-users} - API method documentation
     */
    Users.prototype.usersList = function (req, config) {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.UsersListRequest(req);
        }
        var baseURL = this._serverURL;
        var url = baseURL.replace(/\/$/, "") + "/users";
        var client = this._defaultClient;
        var queryParams = utils.serializeQueryParams(req);
        var r = client.request(__assign({ url: url + queryParams, method: "get" }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.UsersListResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
                headers: utils.getHeadersFromResponse(httpRes.headers),
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 200:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.simpleUsers = [];
                        var resFieldDepth = utils.getResFieldDepth(res);
                        res.simpleUsers = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.SimpleUser, resFieldDepth);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 304:
                    break;
            }
            return res;
        });
    };
    /**
     * List users blocked by the authenticated user
     *
     * @remarks
     * List the users you've blocked on your personal account.
     *
     * @see {@link https://docs.github.com/rest/reference/users#list-users-blocked-by-the-authenticated-user} - API method documentation
     */
    Users.prototype.usersListBlockedByAuthenticatedUser = function (req, config) {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.UsersListBlockedByAuthenticatedUserRequest(req);
        }
        var baseURL = this._serverURL;
        var url = baseURL.replace(/\/$/, "") + "/user/blocks";
        var client = this._defaultClient;
        var queryParams = utils.serializeQueryParams(req);
        var r = client.request(__assign({ url: url + queryParams, method: "get" }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.UsersListBlockedByAuthenticatedUserResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 200:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.simpleUsers = [];
                        var resFieldDepth = utils.getResFieldDepth(res);
                        res.simpleUsers = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.SimpleUser, resFieldDepth);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 304:
                    break;
                case [401, 403, 404].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.basicError = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.BasicError);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * List email addresses for the authenticated user
     *
     * @remarks
     * Lists all of your email addresses, and specifies which one is visible to the public. This endpoint is accessible with the `user:email` scope.
     *
     * @see {@link https://docs.github.com/rest/reference/users#list-email-addresses-for-the-authenticated-user} - API method documentation
     */
    Users.prototype.usersListEmailsForAuthenticatedUser = function (req, config) {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.UsersListEmailsForAuthenticatedUserRequest(req);
        }
        var baseURL = this._serverURL;
        var url = baseURL.replace(/\/$/, "") + "/user/emails";
        var client = this._defaultClient;
        var queryParams = utils.serializeQueryParams(req);
        var r = client.request(__assign({ url: url + queryParams, method: "get" }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.UsersListEmailsForAuthenticatedUserResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
                headers: utils.getHeadersFromResponse(httpRes.headers),
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 200:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.emails = [];
                        var resFieldDepth = utils.getResFieldDepth(res);
                        res.emails = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.Email, resFieldDepth);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 304:
                    break;
                case [401, 403, 404].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.basicError = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.BasicError);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * List the people the authenticated user follows
     *
     * @remarks
     * Lists the people who the authenticated user follows.
     *
     * @see {@link https://docs.github.com/rest/reference/users#list-the-people-the-authenticated-user-follows} - API method documentation
     */
    Users.prototype.usersListFollowedByAuthenticatedUser = function (req, config) {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.UsersListFollowedByAuthenticatedUserRequest(req);
        }
        var baseURL = this._serverURL;
        var url = baseURL.replace(/\/$/, "") + "/user/following";
        var client = this._defaultClient;
        var queryParams = utils.serializeQueryParams(req);
        var r = client.request(__assign({ url: url + queryParams, method: "get" }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.UsersListFollowedByAuthenticatedUserResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
                headers: utils.getHeadersFromResponse(httpRes.headers),
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 200:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.simpleUsers = [];
                        var resFieldDepth = utils.getResFieldDepth(res);
                        res.simpleUsers = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.SimpleUser, resFieldDepth);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 304:
                    break;
                case [401, 403].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.basicError = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.BasicError);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * List followers of the authenticated user
     *
     * @remarks
     * Lists the people following the authenticated user.
     *
     * @see {@link https://docs.github.com/rest/reference/users#list-followers-of-the-authenticated-user} - API method documentation
     */
    Users.prototype.usersListFollowersForAuthenticatedUser = function (req, config) {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.UsersListFollowersForAuthenticatedUserRequest(req);
        }
        var baseURL = this._serverURL;
        var url = baseURL.replace(/\/$/, "") + "/user/followers";
        var client = this._defaultClient;
        var queryParams = utils.serializeQueryParams(req);
        var r = client.request(__assign({ url: url + queryParams, method: "get" }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.UsersListFollowersForAuthenticatedUserResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
                headers: utils.getHeadersFromResponse(httpRes.headers),
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 200:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.simpleUsers = [];
                        var resFieldDepth = utils.getResFieldDepth(res);
                        res.simpleUsers = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.SimpleUser, resFieldDepth);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 304:
                    break;
                case [401, 403].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.basicError = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.BasicError);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * List followers of a user
     *
     * @remarks
     * Lists the people following the specified user.
     *
     * @see {@link https://docs.github.com/rest/reference/users#list-followers-of-a-user} - API method documentation
     */
    Users.prototype.usersListFollowersForUser = function (req, config) {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.UsersListFollowersForUserRequest(req);
        }
        var baseURL = this._serverURL;
        var url = utils.generateURL(baseURL, "/users/{username}/followers", req);
        var client = this._defaultClient;
        var queryParams = utils.serializeQueryParams(req);
        var r = client.request(__assign({ url: url + queryParams, method: "get" }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.UsersListFollowersForUserResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
                headers: utils.getHeadersFromResponse(httpRes.headers),
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 200:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.simpleUsers = [];
                        var resFieldDepth = utils.getResFieldDepth(res);
                        res.simpleUsers = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.SimpleUser, resFieldDepth);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * List the people a user follows
     *
     * @remarks
     * Lists the people who the specified user follows.
     *
     * @see {@link https://docs.github.com/rest/reference/users#list-the-people-a-user-follows} - API method documentation
     */
    Users.prototype.usersListFollowingForUser = function (req, config) {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.UsersListFollowingForUserRequest(req);
        }
        var baseURL = this._serverURL;
        var url = utils.generateURL(baseURL, "/users/{username}/following", req);
        var client = this._defaultClient;
        var queryParams = utils.serializeQueryParams(req);
        var r = client.request(__assign({ url: url + queryParams, method: "get" }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.UsersListFollowingForUserResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
                headers: utils.getHeadersFromResponse(httpRes.headers),
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 200:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.simpleUsers = [];
                        var resFieldDepth = utils.getResFieldDepth(res);
                        res.simpleUsers = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.SimpleUser, resFieldDepth);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * List GPG keys for the authenticated user
     *
     * @remarks
     * Lists the current user's GPG keys. Requires that you are authenticated via Basic Auth or via OAuth with at least `read:gpg_key` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     *
     * @see {@link https://docs.github.com/rest/reference/users#list-gpg-keys-for-the-authenticated-user} - API method documentation
     */
    Users.prototype.usersListGpgKeysForAuthenticatedUser = function (req, config) {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.UsersListGpgKeysForAuthenticatedUserRequest(req);
        }
        var baseURL = this._serverURL;
        var url = baseURL.replace(/\/$/, "") + "/user/gpg_keys";
        var client = this._defaultClient;
        var queryParams = utils.serializeQueryParams(req);
        var r = client.request(__assign({ url: url + queryParams, method: "get" }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.UsersListGpgKeysForAuthenticatedUserResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
                headers: utils.getHeadersFromResponse(httpRes.headers),
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 200:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.gpgKeys = [];
                        var resFieldDepth = utils.getResFieldDepth(res);
                        res.gpgKeys = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.GpgKey, resFieldDepth);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 304:
                    break;
                case [401, 403, 404].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.basicError = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.BasicError);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * List GPG keys for a user
     *
     * @remarks
     * Lists the GPG keys for a user. This information is accessible by anyone.
     *
     * @see {@link https://docs.github.com/rest/reference/users#list-gpg-keys-for-a-user} - API method documentation
     */
    Users.prototype.usersListGpgKeysForUser = function (req, config) {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.UsersListGpgKeysForUserRequest(req);
        }
        var baseURL = this._serverURL;
        var url = utils.generateURL(baseURL, "/users/{username}/gpg_keys", req);
        var client = this._defaultClient;
        var queryParams = utils.serializeQueryParams(req);
        var r = client.request(__assign({ url: url + queryParams, method: "get" }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.UsersListGpgKeysForUserResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
                headers: utils.getHeadersFromResponse(httpRes.headers),
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 200:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.gpgKeys = [];
                        var resFieldDepth = utils.getResFieldDepth(res);
                        res.gpgKeys = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.GpgKey, resFieldDepth);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * List public email addresses for the authenticated user
     *
     * @remarks
     * Lists your publicly visible email address, which you can set with the [Set primary email visibility for the authenticated user](https://docs.github.com/rest/reference/users#set-primary-email-visibility-for-the-authenticated-user) endpoint. This endpoint is accessible with the `user:email` scope.
     *
     * @see {@link https://docs.github.com/rest/reference/users#list-public-email-addresses-for-the-authenticated-user} - API method documentation
     */
    Users.prototype.usersListPublicEmailsForAuthenticatedUser = function (req, config) {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.UsersListPublicEmailsForAuthenticatedUserRequest(req);
        }
        var baseURL = this._serverURL;
        var url = baseURL.replace(/\/$/, "") + "/user/public_emails";
        var client = this._defaultClient;
        var queryParams = utils.serializeQueryParams(req);
        var r = client.request(__assign({ url: url + queryParams, method: "get" }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.UsersListPublicEmailsForAuthenticatedUserResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
                headers: utils.getHeadersFromResponse(httpRes.headers),
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 200:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.emails = [];
                        var resFieldDepth = utils.getResFieldDepth(res);
                        res.emails = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.Email, resFieldDepth);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 304:
                    break;
                case [401, 403, 404].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.basicError = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.BasicError);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * List public keys for a user
     *
     * @remarks
     * Lists the _verified_ public SSH keys for a user. This is accessible by anyone.
     *
     * @see {@link https://docs.github.com/rest/reference/users#list-public-keys-for-a-user} - API method documentation
     */
    Users.prototype.usersListPublicKeysForUser = function (req, config) {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.UsersListPublicKeysForUserRequest(req);
        }
        var baseURL = this._serverURL;
        var url = utils.generateURL(baseURL, "/users/{username}/keys", req);
        var client = this._defaultClient;
        var queryParams = utils.serializeQueryParams(req);
        var r = client.request(__assign({ url: url + queryParams, method: "get" }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.UsersListPublicKeysForUserResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
                headers: utils.getHeadersFromResponse(httpRes.headers),
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 200:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.keySimples = [];
                        var resFieldDepth = utils.getResFieldDepth(res);
                        res.keySimples = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.KeySimple, resFieldDepth);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * List public SSH keys for the authenticated user
     *
     * @remarks
     * Lists the public SSH keys for the authenticated user's GitHub account. Requires that you are authenticated via Basic Auth or via OAuth with at least `read:public_key` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     *
     * @see {@link https://docs.github.com/rest/reference/users#list-public-ssh-keys-for-the-authenticated-user} - API method documentation
     */
    Users.prototype.usersListPublicSshKeysForAuthenticatedUser = function (req, config) {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.UsersListPublicSshKeysForAuthenticatedUserRequest(req);
        }
        var baseURL = this._serverURL;
        var url = baseURL.replace(/\/$/, "") + "/user/keys";
        var client = this._defaultClient;
        var queryParams = utils.serializeQueryParams(req);
        var r = client.request(__assign({ url: url + queryParams, method: "get" }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.UsersListPublicSshKeysForAuthenticatedUserResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
                headers: utils.getHeadersFromResponse(httpRes.headers),
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 200:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.keys = [];
                        var resFieldDepth = utils.getResFieldDepth(res);
                        res.keys = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.Key, resFieldDepth);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 304:
                    break;
                case [401, 403, 404].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.basicError = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.BasicError);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * List SSH signing keys for the authenticated user
     *
     * @remarks
     * Lists the SSH signing keys for the authenticated user's GitHub account. You must authenticate with Basic Authentication, or you must authenticate with OAuth with at least `read:ssh_signing_key` scope. For more information, see "[Understanding scopes for OAuth apps](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/)."
     *
     * @see {@link https://docs.github.com/rest/reference/users#list-public-ssh-signing-keys-for-the-authenticated-user} - API method documentation
     */
    Users.prototype.usersListSshSigningKeysForAuthenticatedUser = function (req, config) {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.UsersListSshSigningKeysForAuthenticatedUserRequest(req);
        }
        var baseURL = this._serverURL;
        var url = baseURL.replace(/\/$/, "") + "/user/ssh_signing_keys";
        var client = this._defaultClient;
        var queryParams = utils.serializeQueryParams(req);
        var r = client.request(__assign({ url: url + queryParams, method: "get" }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.UsersListSshSigningKeysForAuthenticatedUserResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
                headers: utils.getHeadersFromResponse(httpRes.headers),
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 200:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.sshSigningKeys = [];
                        var resFieldDepth = utils.getResFieldDepth(res);
                        res.sshSigningKeys = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.SshSigningKey, resFieldDepth);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 304:
                    break;
                case [401, 403, 404].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.basicError = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.BasicError);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * List SSH signing keys for a user
     *
     * @remarks
     * Lists the SSH signing keys for a user. This operation is accessible by anyone.
     *
     * @see {@link https://docs.github.com/rest/reference/users#list-ssh-signing-keys-for-a-user} - API method documentation
     */
    Users.prototype.usersListSshSigningKeysForUser = function (req, config) {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.UsersListSshSigningKeysForUserRequest(req);
        }
        var baseURL = this._serverURL;
        var url = utils.generateURL(baseURL, "/users/{username}/ssh_signing_keys", req);
        var client = this._defaultClient;
        var queryParams = utils.serializeQueryParams(req);
        var r = client.request(__assign({ url: url + queryParams, method: "get" }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.UsersListSshSigningKeysForUserResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
                headers: utils.getHeadersFromResponse(httpRes.headers),
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 200:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.sshSigningKeys = [];
                        var resFieldDepth = utils.getResFieldDepth(res);
                        res.sshSigningKeys = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.SshSigningKey, resFieldDepth);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * Set primary email visibility for the authenticated user
     *
     * @remarks
     * Sets the visibility for your primary email addresses.
     *
     * @see {@link https://docs.github.com/rest/reference/users#set-primary-email-visibility-for-the-authenticated-user} - API method documentation
     */
    Users.prototype.usersSetPrimaryEmailVisibilityForAuthenticatedUser = function (req, config) {
        var _a;
        if (!(req instanceof utils.SpeakeasyBase)) {
            req =
                new operations.UsersSetPrimaryEmailVisibilityForAuthenticatedUserRequestBody(req);
        }
        var baseURL = this._serverURL;
        var url = baseURL.replace(/\/$/, "") + "/user/email/visibility";
        var _b = [{}, {}], reqBodyHeaders = _b[0], reqBody = _b[1];
        try {
            _a = utils.serializeRequestBody(req, "request", "json"), reqBodyHeaders = _a[0], reqBody = _a[1];
        }
        catch (e) {
            if (e instanceof Error) {
                throw new Error("Error serializing request body, cause: ".concat(e.message));
            }
        }
        var client = this._defaultClient;
        var headers = __assign(__assign({}, reqBodyHeaders), config === null || config === void 0 ? void 0 : config.headers);
        if (reqBody == null || Object.keys(reqBody).length === 0)
            throw new Error("request body is required");
        var r = client.request(__assign({ url: url, method: "patch", headers: headers, data: reqBody }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.UsersSetPrimaryEmailVisibilityForAuthenticatedUserResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 200:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.emails = [];
                        var resFieldDepth = utils.getResFieldDepth(res);
                        res.emails = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.Email, resFieldDepth);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 304:
                    break;
                case [401, 403, 404].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.basicError = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.BasicError);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 422:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.validationError = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.ValidationError);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * Unblock a user
     *
     * @see {@link https://docs.github.com/rest/reference/users#unblock-a-user} - API method documentation
     */
    Users.prototype.usersUnblock = function (req, config) {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.UsersUnblockRequest(req);
        }
        var baseURL = this._serverURL;
        var url = utils.generateURL(baseURL, "/user/blocks/{username}", req);
        var client = this._defaultClient;
        var r = client.request(__assign({ url: url, method: "delete" }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.UsersUnblockResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case [204, 304].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    break;
                case [401, 403, 404].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.basicError = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.BasicError);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * Unfollow a user
     *
     * @remarks
     * Unfollowing a user requires the user to be logged in and authenticated with basic auth or OAuth with the `user:follow` scope.
     *
     * @see {@link https://docs.github.com/rest/reference/users#unfollow-a-user} - API method documentation
     */
    Users.prototype.usersUnfollow = function (req, config) {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.UsersUnfollowRequest(req);
        }
        var baseURL = this._serverURL;
        var url = utils.generateURL(baseURL, "/user/following/{username}", req);
        var client = this._defaultClient;
        var r = client.request(__assign({ url: url, method: "delete" }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.UsersUnfollowResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case [204, 304].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    break;
                case [401, 403, 404].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.basicError = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.BasicError);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * Update the authenticated user
     *
     * @remarks
     * **Note:** If your email is set to private and you send an `email` parameter as part of this request to update your profile, your privacy settings are still enforced: the email address will not be displayed on your public profile or via the API.
     *
     * @see {@link https://docs.github.com/rest/reference/users/#update-the-authenticated-user} - API method documentation
     */
    Users.prototype.usersUpdateAuthenticated = function (req, config) {
        var _a;
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.UsersUpdateAuthenticatedRequestBody(req);
        }
        var baseURL = this._serverURL;
        var url = baseURL.replace(/\/$/, "") + "/user";
        var _b = [{}, {}], reqBodyHeaders = _b[0], reqBody = _b[1];
        try {
            _a = utils.serializeRequestBody(req, "request", "json"), reqBodyHeaders = _a[0], reqBody = _a[1];
        }
        catch (e) {
            if (e instanceof Error) {
                throw new Error("Error serializing request body, cause: ".concat(e.message));
            }
        }
        var client = this._defaultClient;
        var headers = __assign(__assign({}, reqBodyHeaders), config === null || config === void 0 ? void 0 : config.headers);
        var r = client.request(__assign({ url: url, method: "patch", headers: headers, data: reqBody }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.UsersUpdateAuthenticatedResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 200:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.privateUser = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.PrivateUser);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 304:
                    break;
                case [401, 403, 404].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.basicError = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.BasicError);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 422:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.validationError = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.ValidationError);
                    }
                    break;
            }
            return res;
        });
    };
    return Users;
}());
exports.Users = Users;
