/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class FirewallPolicies {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Inserts an association for the specified firewall policy.
   */
  computeFirewallPoliciesAddAssociation(
    req: operations.ComputeFirewallPoliciesAddAssociationRequest,
    security: operations.ComputeFirewallPoliciesAddAssociationSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ComputeFirewallPoliciesAddAssociationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ComputeFirewallPoliciesAddAssociationRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/locations/global/firewallPolicies/{firewallPolicy}/addAssociation",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "firewallPolicyAssociation",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ComputeFirewallPoliciesAddAssociationSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ComputeFirewallPoliciesAddAssociationResponse =
        new operations.ComputeFirewallPoliciesAddAssociationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Inserts a rule into a firewall policy.
   */
  computeFirewallPoliciesAddRule(
    req: operations.ComputeFirewallPoliciesAddRuleRequest,
    security: operations.ComputeFirewallPoliciesAddRuleSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ComputeFirewallPoliciesAddRuleResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ComputeFirewallPoliciesAddRuleRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/locations/global/firewallPolicies/{firewallPolicy}/addRule",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "firewallPolicyRule",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ComputeFirewallPoliciesAddRuleSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ComputeFirewallPoliciesAddRuleResponse =
        new operations.ComputeFirewallPoliciesAddRuleResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Copies rules to the specified firewall policy.
   */
  computeFirewallPoliciesCloneRules(
    req: operations.ComputeFirewallPoliciesCloneRulesRequest,
    security: operations.ComputeFirewallPoliciesCloneRulesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ComputeFirewallPoliciesCloneRulesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ComputeFirewallPoliciesCloneRulesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/locations/global/firewallPolicies/{firewallPolicy}/cloneRules",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ComputeFirewallPoliciesCloneRulesSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ComputeFirewallPoliciesCloneRulesResponse =
        new operations.ComputeFirewallPoliciesCloneRulesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes the specified policy.
   */
  computeFirewallPoliciesDelete(
    req: operations.ComputeFirewallPoliciesDeleteRequest,
    security: operations.ComputeFirewallPoliciesDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ComputeFirewallPoliciesDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ComputeFirewallPoliciesDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/locations/global/firewallPolicies/{firewallPolicy}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ComputeFirewallPoliciesDeleteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ComputeFirewallPoliciesDeleteResponse =
        new operations.ComputeFirewallPoliciesDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns the specified firewall policy.
   */
  computeFirewallPoliciesGet(
    req: operations.ComputeFirewallPoliciesGetRequest,
    security: operations.ComputeFirewallPoliciesGetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ComputeFirewallPoliciesGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ComputeFirewallPoliciesGetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/locations/global/firewallPolicies/{firewallPolicy}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ComputeFirewallPoliciesGetSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ComputeFirewallPoliciesGetResponse =
        new operations.ComputeFirewallPoliciesGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.firewallPolicy = utils.objectToClass(
              httpRes?.data,
              shared.FirewallPolicy
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets an association with the specified name.
   */
  computeFirewallPoliciesGetAssociation(
    req: operations.ComputeFirewallPoliciesGetAssociationRequest,
    security: operations.ComputeFirewallPoliciesGetAssociationSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ComputeFirewallPoliciesGetAssociationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ComputeFirewallPoliciesGetAssociationRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/locations/global/firewallPolicies/{firewallPolicy}/getAssociation",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ComputeFirewallPoliciesGetAssociationSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ComputeFirewallPoliciesGetAssociationResponse =
        new operations.ComputeFirewallPoliciesGetAssociationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.firewallPolicyAssociation = utils.objectToClass(
              httpRes?.data,
              shared.FirewallPolicyAssociation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets the access control policy for a resource. May be empty if no such policy or resource exists.
   */
  computeFirewallPoliciesGetIamPolicy(
    req: operations.ComputeFirewallPoliciesGetIamPolicyRequest,
    security: operations.ComputeFirewallPoliciesGetIamPolicySecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ComputeFirewallPoliciesGetIamPolicyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ComputeFirewallPoliciesGetIamPolicyRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/locations/global/firewallPolicies/{resource}/getIamPolicy",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ComputeFirewallPoliciesGetIamPolicySecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ComputeFirewallPoliciesGetIamPolicyResponse =
        new operations.ComputeFirewallPoliciesGetIamPolicyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.policy = utils.objectToClass(httpRes?.data, shared.Policy);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets a rule of the specified priority.
   */
  computeFirewallPoliciesGetRule(
    req: operations.ComputeFirewallPoliciesGetRuleRequest,
    security: operations.ComputeFirewallPoliciesGetRuleSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ComputeFirewallPoliciesGetRuleResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ComputeFirewallPoliciesGetRuleRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/locations/global/firewallPolicies/{firewallPolicy}/getRule",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ComputeFirewallPoliciesGetRuleSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ComputeFirewallPoliciesGetRuleResponse =
        new operations.ComputeFirewallPoliciesGetRuleResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.firewallPolicyRule = utils.objectToClass(
              httpRes?.data,
              shared.FirewallPolicyRule
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a new policy in the specified project using the data included in the request.
   */
  computeFirewallPoliciesInsert(
    req: operations.ComputeFirewallPoliciesInsertRequest,
    security: operations.ComputeFirewallPoliciesInsertSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ComputeFirewallPoliciesInsertResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ComputeFirewallPoliciesInsertRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/locations/global/firewallPolicies";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "firewallPolicy",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ComputeFirewallPoliciesInsertSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ComputeFirewallPoliciesInsertResponse =
        new operations.ComputeFirewallPoliciesInsertResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists all the policies that have been configured for the specified folder or organization.
   */
  computeFirewallPoliciesList(
    req: operations.ComputeFirewallPoliciesListRequest,
    security: operations.ComputeFirewallPoliciesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ComputeFirewallPoliciesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ComputeFirewallPoliciesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/locations/global/firewallPolicies";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ComputeFirewallPoliciesListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ComputeFirewallPoliciesListResponse =
        new operations.ComputeFirewallPoliciesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.firewallPolicyList = utils.objectToClass(
              httpRes?.data,
              shared.FirewallPolicyList
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists associations of a specified target, i.e., organization or folder.
   */
  computeFirewallPoliciesListAssociations(
    req: operations.ComputeFirewallPoliciesListAssociationsRequest,
    security: operations.ComputeFirewallPoliciesListAssociationsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ComputeFirewallPoliciesListAssociationsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ComputeFirewallPoliciesListAssociationsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/locations/global/firewallPolicies/listAssociations";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ComputeFirewallPoliciesListAssociationsSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ComputeFirewallPoliciesListAssociationsResponse =
        new operations.ComputeFirewallPoliciesListAssociationsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.firewallPoliciesListAssociationsResponse = utils.objectToClass(
              httpRes?.data,
              shared.FirewallPoliciesListAssociationsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Moves the specified firewall policy.
   */
  computeFirewallPoliciesMove(
    req: operations.ComputeFirewallPoliciesMoveRequest,
    security: operations.ComputeFirewallPoliciesMoveSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ComputeFirewallPoliciesMoveResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ComputeFirewallPoliciesMoveRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/locations/global/firewallPolicies/{firewallPolicy}/move",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ComputeFirewallPoliciesMoveSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ComputeFirewallPoliciesMoveResponse =
        new operations.ComputeFirewallPoliciesMoveResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Patches the specified policy with the data included in the request.
   */
  computeFirewallPoliciesPatch(
    req: operations.ComputeFirewallPoliciesPatchRequest,
    security: operations.ComputeFirewallPoliciesPatchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ComputeFirewallPoliciesPatchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ComputeFirewallPoliciesPatchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/locations/global/firewallPolicies/{firewallPolicy}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "firewallPolicy1",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ComputeFirewallPoliciesPatchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ComputeFirewallPoliciesPatchResponse =
        new operations.ComputeFirewallPoliciesPatchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Patches a rule of the specified priority.
   */
  computeFirewallPoliciesPatchRule(
    req: operations.ComputeFirewallPoliciesPatchRuleRequest,
    security: operations.ComputeFirewallPoliciesPatchRuleSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ComputeFirewallPoliciesPatchRuleResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ComputeFirewallPoliciesPatchRuleRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/locations/global/firewallPolicies/{firewallPolicy}/patchRule",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "firewallPolicyRule",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ComputeFirewallPoliciesPatchRuleSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ComputeFirewallPoliciesPatchRuleResponse =
        new operations.ComputeFirewallPoliciesPatchRuleResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Removes an association for the specified firewall policy.
   */
  computeFirewallPoliciesRemoveAssociation(
    req: operations.ComputeFirewallPoliciesRemoveAssociationRequest,
    security: operations.ComputeFirewallPoliciesRemoveAssociationSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ComputeFirewallPoliciesRemoveAssociationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ComputeFirewallPoliciesRemoveAssociationRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/locations/global/firewallPolicies/{firewallPolicy}/removeAssociation",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ComputeFirewallPoliciesRemoveAssociationSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ComputeFirewallPoliciesRemoveAssociationResponse =
        new operations.ComputeFirewallPoliciesRemoveAssociationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes a rule of the specified priority.
   */
  computeFirewallPoliciesRemoveRule(
    req: operations.ComputeFirewallPoliciesRemoveRuleRequest,
    security: operations.ComputeFirewallPoliciesRemoveRuleSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ComputeFirewallPoliciesRemoveRuleResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ComputeFirewallPoliciesRemoveRuleRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/locations/global/firewallPolicies/{firewallPolicy}/removeRule",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ComputeFirewallPoliciesRemoveRuleSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ComputeFirewallPoliciesRemoveRuleResponse =
        new operations.ComputeFirewallPoliciesRemoveRuleResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Sets the access control policy on the specified resource. Replaces any existing policy.
   */
  computeFirewallPoliciesSetIamPolicy(
    req: operations.ComputeFirewallPoliciesSetIamPolicyRequest,
    security: operations.ComputeFirewallPoliciesSetIamPolicySecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ComputeFirewallPoliciesSetIamPolicyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ComputeFirewallPoliciesSetIamPolicyRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/locations/global/firewallPolicies/{resource}/setIamPolicy",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "globalOrganizationSetPolicyRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ComputeFirewallPoliciesSetIamPolicySecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ComputeFirewallPoliciesSetIamPolicyResponse =
        new operations.ComputeFirewallPoliciesSetIamPolicyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.policy = utils.objectToClass(httpRes?.data, shared.Policy);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns permissions that a caller has on the specified resource.
   */
  computeFirewallPoliciesTestIamPermissions(
    req: operations.ComputeFirewallPoliciesTestIamPermissionsRequest,
    security: operations.ComputeFirewallPoliciesTestIamPermissionsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ComputeFirewallPoliciesTestIamPermissionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ComputeFirewallPoliciesTestIamPermissionsRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/locations/global/firewallPolicies/{resource}/testIamPermissions",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "testPermissionsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ComputeFirewallPoliciesTestIamPermissionsSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ComputeFirewallPoliciesTestIamPermissionsResponse =
        new operations.ComputeFirewallPoliciesTestIamPermissionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.testPermissionsResponse = utils.objectToClass(
              httpRes?.data,
              shared.TestPermissionsResponse
            );
          }
          break;
      }

      return res;
    });
  }
}
