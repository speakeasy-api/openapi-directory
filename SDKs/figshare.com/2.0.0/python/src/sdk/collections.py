"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Optional

class Collections:
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def collection_articles(self, request: operations.CollectionArticlesRequest) -> operations.CollectionArticlesResponse:
        r"""Public Collection Articles
        Returns a list of public collection articles
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.CollectionArticlesRequest, base_url, '/collections/{collection_id}/articles', request)
        
        query_params = utils.get_query_params(operations.CollectionArticlesRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CollectionArticlesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.Article]])
                res.articles = out
        elif http_res.status_code in [400, 404, 422, 500]:
            pass

        return res

    def collection_details(self, request: operations.CollectionDetailsRequest) -> operations.CollectionDetailsResponse:
        r"""Collection details
        View a collection
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.CollectionDetailsRequest, base_url, '/collections/{collection_id}', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CollectionDetailsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CollectionComplete])
                res.collection_complete = out
        elif http_res.status_code in [400, 404, 500]:
            pass

        return res

    def collection_version_details(self, request: operations.CollectionVersionDetailsRequest) -> operations.CollectionVersionDetailsResponse:
        r"""Collection Version details
        View details for a certain version of a collection
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.CollectionVersionDetailsRequest, base_url, '/collections/{collection_id}/versions/{version_id}', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CollectionVersionDetailsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CollectionComplete])
                res.collection_complete = out
        elif http_res.status_code in [400, 404, 500]:
            pass

        return res

    def collection_versions(self, request: operations.CollectionVersionsRequest) -> operations.CollectionVersionsResponse:
        r"""Collection Versions list
        Returns a list of public collection Versions
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.CollectionVersionsRequest, base_url, '/collections/{collection_id}/versions', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CollectionVersionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.CollectionVersions]])
                res.collection_versions = out
        elif http_res.status_code in [400, 404, 500]:
            pass

        return res

    def collections_list(self, request: operations.CollectionsListRequest) -> operations.CollectionsListResponse:
        r"""Public Collections
        Returns a list of public collections
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/collections'
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.CollectionsListRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CollectionsListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.Collection]])
                res.collections = out
        elif http_res.status_code in [400, 422, 500]:
            pass

        return res

    def collections_search(self, request: operations.CollectionsSearchRequest) -> operations.CollectionsSearchResponse:
        r"""Public Collections Search
        Returns a list of public collections
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/collections/search'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "collection_search", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = self._client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CollectionsSearchResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.Collection]])
                res.collections = out
        elif http_res.status_code in [400, 422, 500]:
            pass

        return res

    def private_collection_article_delete(self, request: operations.PrivateCollectionArticleDeleteRequest, security: operations.PrivateCollectionArticleDeleteSecurity) -> operations.PrivateCollectionArticleDeleteResponse:
        r"""Delete collection article
        De-associate article from collection
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PrivateCollectionArticleDeleteRequest, base_url, '/account/collections/{collection_id}/articles/{article_id}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PrivateCollectionArticleDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [204, 404, 500]:
            pass
        elif http_res.status_code == 403:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorMessage])
                res.error_message = out

        return res

    def private_collection_articles_add(self, request: operations.PrivateCollectionArticlesAddRequest, security: operations.PrivateCollectionArticlesAddSecurity) -> operations.PrivateCollectionArticlesAddResponse:
        r"""Add collection articles
        Associate new articles with the collection. This will add new articles to the list of already associated articles
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PrivateCollectionArticlesAddRequest, base_url, '/account/collections/{collection_id}/articles', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "articles_creator", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PrivateCollectionArticlesAddResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Location])
                res.location = out
        elif http_res.status_code in [400, 404, 500]:
            pass
        elif http_res.status_code == 403:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorMessage])
                res.error_message = out

        return res

    def private_collection_articles_list(self, request: operations.PrivateCollectionArticlesListRequest, security: operations.PrivateCollectionArticlesListSecurity) -> operations.PrivateCollectionArticlesListResponse:
        r"""List collection articles
        List collection articles
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PrivateCollectionArticlesListRequest, base_url, '/account/collections/{collection_id}/articles', request)
        
        query_params = utils.get_query_params(operations.PrivateCollectionArticlesListRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PrivateCollectionArticlesListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.Article]])
                res.articles = out
        elif http_res.status_code in [400, 404, 500]:
            pass
        elif http_res.status_code == 403:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorMessage])
                res.error_message = out

        return res

    def private_collection_articles_replace(self, request: operations.PrivateCollectionArticlesReplaceRequest, security: operations.PrivateCollectionArticlesReplaceSecurity) -> operations.PrivateCollectionArticlesReplaceResponse:
        r"""Replace collection articles
        Associate new articles with the collection. This will remove all already associated articles and add these new ones
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PrivateCollectionArticlesReplaceRequest, base_url, '/account/collections/{collection_id}/articles', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "articles_creator", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PrivateCollectionArticlesReplaceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 205:
            res.headers = http_res.headers
            
        elif http_res.status_code in [400, 404, 500]:
            pass
        elif http_res.status_code == 403:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorMessage])
                res.error_message = out

        return res

    def private_collection_author_delete(self, request: operations.PrivateCollectionAuthorDeleteRequest, security: operations.PrivateCollectionAuthorDeleteSecurity) -> operations.PrivateCollectionAuthorDeleteResponse:
        r"""Delete collection author
        Delete collection author
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PrivateCollectionAuthorDeleteRequest, base_url, '/account/collections/{collection_id}/authors/{author_id}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PrivateCollectionAuthorDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [204, 404, 500]:
            pass
        elif http_res.status_code == 403:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorMessage])
                res.error_message = out

        return res

    def private_collection_authors_add(self, request: operations.PrivateCollectionAuthorsAddRequest, security: operations.PrivateCollectionAuthorsAddSecurity) -> operations.PrivateCollectionAuthorsAddResponse:
        r"""Add collection authors
        Associate new authors with the collection. This will add new authors to the list of already associated authors
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PrivateCollectionAuthorsAddRequest, base_url, '/account/collections/{collection_id}/authors', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "authors_creator", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PrivateCollectionAuthorsAddResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Location])
                res.location = out
        elif http_res.status_code in [400, 404, 500]:
            pass
        elif http_res.status_code == 403:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorMessage])
                res.error_message = out

        return res

    def private_collection_authors_list(self, request: operations.PrivateCollectionAuthorsListRequest, security: operations.PrivateCollectionAuthorsListSecurity) -> operations.PrivateCollectionAuthorsListResponse:
        r"""List collection authors
        List collection authors
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PrivateCollectionAuthorsListRequest, base_url, '/account/collections/{collection_id}/authors', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PrivateCollectionAuthorsListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.Author]])
                res.authors = out
        elif http_res.status_code in [400, 404, 500]:
            pass
        elif http_res.status_code == 403:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorMessage])
                res.error_message = out

        return res

    def private_collection_authors_replace(self, request: operations.PrivateCollectionAuthorsReplaceRequest, security: operations.PrivateCollectionAuthorsReplaceSecurity) -> operations.PrivateCollectionAuthorsReplaceResponse:
        r"""Replace collection authors
        Associate new authors with the collection. This will remove all already associated authors and add these new ones
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PrivateCollectionAuthorsReplaceRequest, base_url, '/account/collections/{collection_id}/authors', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "authors_creator", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PrivateCollectionAuthorsReplaceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 205:
            res.headers = http_res.headers
            
        elif http_res.status_code in [400, 404, 500]:
            pass
        elif http_res.status_code == 403:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorMessage])
                res.error_message = out

        return res

    def private_collection_categories_add(self, request: operations.PrivateCollectionCategoriesAddRequest, security: operations.PrivateCollectionCategoriesAddSecurity) -> operations.PrivateCollectionCategoriesAddResponse:
        r"""Add collection categories
        Associate new categories with the collection. This will add new categories to the list of already associated categories
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PrivateCollectionCategoriesAddRequest, base_url, '/account/collections/{collection_id}/categories', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "categories_creator", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PrivateCollectionCategoriesAddResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Location])
                res.location = out
        elif http_res.status_code in [400, 404, 500]:
            pass
        elif http_res.status_code == 403:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorMessage])
                res.error_message = out

        return res

    def private_collection_categories_list(self, request: operations.PrivateCollectionCategoriesListRequest, security: operations.PrivateCollectionCategoriesListSecurity) -> operations.PrivateCollectionCategoriesListResponse:
        r"""List collection categories
        List collection categories
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PrivateCollectionCategoriesListRequest, base_url, '/account/collections/{collection_id}/categories', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PrivateCollectionCategoriesListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.Category]])
                res.categories = out
        elif http_res.status_code in [400, 404, 500]:
            pass
        elif http_res.status_code == 403:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorMessage])
                res.error_message = out

        return res

    def private_collection_categories_replace(self, request: operations.PrivateCollectionCategoriesReplaceRequest, security: operations.PrivateCollectionCategoriesReplaceSecurity) -> operations.PrivateCollectionCategoriesReplaceResponse:
        r"""Replace collection categories
        Associate new categories with the collection. This will remove all already associated categories and add these new ones
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PrivateCollectionCategoriesReplaceRequest, base_url, '/account/collections/{collection_id}/categories', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "categories_creator", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PrivateCollectionCategoriesReplaceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 205:
            res.headers = http_res.headers
            
        elif http_res.status_code in [400, 404, 500]:
            pass
        elif http_res.status_code == 403:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorMessage])
                res.error_message = out

        return res

    def private_collection_category_delete(self, request: operations.PrivateCollectionCategoryDeleteRequest, security: operations.PrivateCollectionCategoryDeleteSecurity) -> operations.PrivateCollectionCategoryDeleteResponse:
        r"""Delete collection category
        De-associate category from collection
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PrivateCollectionCategoryDeleteRequest, base_url, '/account/collections/{collection_id}/categories/{category_id}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PrivateCollectionCategoryDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [204, 404, 500]:
            pass
        elif http_res.status_code == 403:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorMessage])
                res.error_message = out

        return res

    def private_collection_create(self, request: shared.CollectionCreate, security: operations.PrivateCollectionCreateSecurity) -> operations.PrivateCollectionCreateResponse:
        r"""Create collection
        Create a new Collection by sending collection information
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/account/collections'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PrivateCollectionCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.LocationWarnings])
                res.location_warnings = out
        elif http_res.status_code in [400, 500]:
            pass
        elif http_res.status_code == 403:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorMessage])
                res.error_message = out

        return res

    def private_collection_delete(self, request: operations.PrivateCollectionDeleteRequest, security: operations.PrivateCollectionDeleteSecurity) -> operations.PrivateCollectionDeleteResponse:
        r"""Delete collection
        Delete n collection
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PrivateCollectionDeleteRequest, base_url, '/account/collections/{collection_id}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PrivateCollectionDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [204, 400, 404, 500]:
            pass
        elif http_res.status_code == 403:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorMessage])
                res.error_message = out

        return res

    def private_collection_details(self, request: operations.PrivateCollectionDetailsRequest, security: operations.PrivateCollectionDetailsSecurity) -> operations.PrivateCollectionDetailsResponse:
        r"""Collection details
        View a collection
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PrivateCollectionDetailsRequest, base_url, '/account/collections/{collection_id}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PrivateCollectionDetailsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CollectionCompletePrivate])
                res.collection_complete_private = out
        elif http_res.status_code in [400, 404, 500]:
            pass

        return res

    def private_collection_private_link_create(self, request: operations.PrivateCollectionPrivateLinkCreateRequest, security: operations.PrivateCollectionPrivateLinkCreateSecurity) -> operations.PrivateCollectionPrivateLinkCreateResponse:
        r"""Create collection private link
        Create new private link
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PrivateCollectionPrivateLinkCreateRequest, base_url, '/account/collections/{collection_id}/private_links', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "collection_private_link_creator", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PrivateCollectionPrivateLinkCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PrivateLinkResponse])
                res.private_link_response = out
        elif http_res.status_code in [400, 404, 500]:
            pass
        elif http_res.status_code == 403:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorMessage])
                res.error_message = out

        return res

    def private_collection_private_link_delete(self, request: operations.PrivateCollectionPrivateLinkDeleteRequest, security: operations.PrivateCollectionPrivateLinkDeleteSecurity) -> operations.PrivateCollectionPrivateLinkDeleteResponse:
        r"""Disable private link
        Disable/delete private link for this collection
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PrivateCollectionPrivateLinkDeleteRequest, base_url, '/account/collections/{collection_id}/private_links/{link_id}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PrivateCollectionPrivateLinkDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [204, 400, 404, 500]:
            pass
        elif http_res.status_code == 403:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorMessage])
                res.error_message = out

        return res

    def private_collection_private_link_update(self, request: operations.PrivateCollectionPrivateLinkUpdateRequest, security: operations.PrivateCollectionPrivateLinkUpdateSecurity) -> operations.PrivateCollectionPrivateLinkUpdateResponse:
        r"""Update collection private link
        Update existing private link for this collection
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PrivateCollectionPrivateLinkUpdateRequest, base_url, '/account/collections/{collection_id}/private_links/{link_id}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "collection_private_link_creator", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PrivateCollectionPrivateLinkUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 205:
            res.headers = http_res.headers
            
        elif http_res.status_code in [400, 404, 422, 500]:
            pass
        elif http_res.status_code == 403:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorMessage])
                res.error_message = out

        return res

    def private_collection_private_links_list(self, request: operations.PrivateCollectionPrivateLinksListRequest, security: operations.PrivateCollectionPrivateLinksListSecurity) -> operations.PrivateCollectionPrivateLinksListResponse:
        r"""List collection private links
        List article private links
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PrivateCollectionPrivateLinksListRequest, base_url, '/account/collections/{collection_id}/private_links', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PrivateCollectionPrivateLinksListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.PrivateLink]])
                res.private_links = out
        elif http_res.status_code in [400, 404, 500]:
            pass
        elif http_res.status_code == 403:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorMessage])
                res.error_message = out

        return res

    def private_collection_publish(self, request: operations.PrivateCollectionPublishRequest, security: operations.PrivateCollectionPublishSecurity) -> operations.PrivateCollectionPublishResponse:
        r"""Private Collection Publish
        When a collection is published, a new public version will be generated. Any further updates to the collection will affect the private collection data. In order to make these changes publicly visible, an explicit publish operation is needed.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PrivateCollectionPublishRequest, base_url, '/account/collections/{collection_id}/publish', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PrivateCollectionPublishResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Location])
                res.location = out
        elif http_res.status_code in [400, 500]:
            pass
        elif http_res.status_code == 403:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorMessage])
                res.error_message = out

        return res

    def private_collection_reserve_doi(self, request: operations.PrivateCollectionReserveDoiRequest, security: operations.PrivateCollectionReserveDoiSecurity) -> operations.PrivateCollectionReserveDoiResponse:
        r"""Private Collection Reserve DOI
        Reserve DOI for collection
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PrivateCollectionReserveDoiRequest, base_url, '/account/collections/{collection_id}/reserve_doi', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PrivateCollectionReserveDoiResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CollectionDOI])
                res.collection_doi = out
        elif http_res.status_code in [400, 500]:
            pass
        elif http_res.status_code == 403:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorMessage])
                res.error_message = out

        return res

    def private_collection_reserve_handle(self, request: operations.PrivateCollectionReserveHandleRequest, security: operations.PrivateCollectionReserveHandleSecurity) -> operations.PrivateCollectionReserveHandleResponse:
        r"""Private Collection Reserve Handle
        Reserve Handle for collection
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PrivateCollectionReserveHandleRequest, base_url, '/account/collections/{collection_id}/reserve_handle', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PrivateCollectionReserveHandleResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CollectionHandle])
                res.collection_handle = out
        elif http_res.status_code in [400, 500]:
            pass
        elif http_res.status_code == 403:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorMessage])
                res.error_message = out

        return res

    def private_collection_resource(self, request: operations.PrivateCollectionResourceRequest, security: operations.PrivateCollectionResourceSecurity) -> operations.PrivateCollectionResourceResponse:
        r"""Private Collection Resource
        Edit collection resource data.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PrivateCollectionResourceRequest, base_url, '/account/collections/{collection_id}/resource', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "resource", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PrivateCollectionResourceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 205:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Location])
                res.location = out
        elif http_res.status_code == 403:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorMessage])
                res.error_message = out
        elif http_res.status_code in [404, 422]:
            pass

        return res

    def private_collection_update(self, request: operations.PrivateCollectionUpdateRequest, security: operations.PrivateCollectionUpdateSecurity) -> operations.PrivateCollectionUpdateResponse:
        r"""Update collection
        Update collection details; request can also be made with the PATCH method.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PrivateCollectionUpdateRequest, base_url, '/account/collections/{collection_id}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "collection_update", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PrivateCollectionUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 205:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.LocationWarningsUpdate])
                res.location_warnings_update = out
        elif http_res.status_code in [400, 404, 500]:
            pass
        elif http_res.status_code == 403:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorMessage])
                res.error_message = out

        return res

    def private_collections_list(self, request: operations.PrivateCollectionsListRequest, security: operations.PrivateCollectionsListSecurity) -> operations.PrivateCollectionsListResponse:
        r"""Private Collections List
        List private collections
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/account/collections'
        
        query_params = utils.get_query_params(operations.PrivateCollectionsListRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PrivateCollectionsListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.Collection]])
                res.collections = out
        elif http_res.status_code in [400, 500]:
            pass
        elif http_res.status_code == 403:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorMessage])
                res.error_message = out

        return res

    def private_collections_search(self, request: shared.PrivateCollectionSearch, security: operations.PrivateCollectionsSearchSecurity) -> operations.PrivateCollectionsSearchResponse:
        r"""Private Collections Search
        Returns a list of private Collections
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/account/collections/search'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PrivateCollectionsSearchResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.Collection]])
                res.collections = out
        elif http_res.status_code in [400, 500]:
            pass
        elif http_res.status_code == 403:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorMessage])
                res.error_message = out

        return res

    