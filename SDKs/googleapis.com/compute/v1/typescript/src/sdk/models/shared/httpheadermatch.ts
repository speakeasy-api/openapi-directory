/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { SpeakeasyBase, SpeakeasyMetadata } from "../../../internal/utils";
import { Int64RangeMatch } from "./int64rangematch";
import { Expose, Type } from "class-transformer";

/**
 * matchRule criteria for request header matches.
 */
export class HttpHeaderMatch extends SpeakeasyBase {
  /**
   * The value should exactly match contents of exactMatch. Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch must be set.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "exactMatch" })
  exactMatch?: string;

  /**
   * The name of the HTTP header to match. For matching against the HTTP request's authority, use a headerMatch with the header name ":authority". For matching a request's method, use the headerName ":method". When the URL map is bound to a target gRPC proxy that has the validateForProxyless field set to true, only non-binary user-specified custom metadata and the `content-type` header are supported. The following transport-level headers cannot be used in header matching rules: `:authority`, `:method`, `:path`, `:scheme`, `user-agent`, `accept-encoding`, `content-encoding`, `grpc-accept-encoding`, `grpc-encoding`, `grpc-previous-rpc-attempts`, `grpc-tags-bin`, `grpc-timeout` and `grpc-trace-bin`.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "headerName" })
  headerName?: string;

  /**
   * If set to false, the headerMatch is considered a match if the preceding match criteria are met. If set to true, the headerMatch is considered a match if the preceding match criteria are NOT met. The default setting is false.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "invertMatch" })
  invertMatch?: boolean;

  /**
   * The value of the header must start with the contents of prefixMatch. Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch must be set.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "prefixMatch" })
  prefixMatch?: string;

  /**
   * A header with the contents of headerName must exist. The match takes place whether or not the request's header has a value. Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch must be set.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "presentMatch" })
  presentMatch?: boolean;

  /**
   * HttpRouteRuleMatch criteria for field values that must stay within the specified integer range.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "rangeMatch" })
  @Type(() => Int64RangeMatch)
  rangeMatch?: Int64RangeMatch;

  /**
   * The value of the header must match the regular expression specified in regexMatch. For more information about regular expression syntax, see Syntax. For matching against a port specified in the HTTP request, use a headerMatch with headerName set to PORT and a regular expression that satisfies the RFC2616 Host header's port specifier. Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch must be set. Regular expressions can only be used when the loadBalancingScheme is set to INTERNAL_SELF_MANAGED.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "regexMatch" })
  regexMatch?: string;

  /**
   * The value of the header must end with the contents of suffixMatch. Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch must be set.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "suffixMatch" })
  suffixMatch?: string;
}
