// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package sdk

import (
	"context"
	"fmt"
	"net/http"
	"openapi/pkg/models/operations"
	"openapi/pkg/models/shared"
	"openapi/pkg/utils"
)

type customers struct {
	defaultClient  HTTPClient
	securityClient HTTPClient
	serverURL      string
	language       string
	sdkVersion     string
	genVersion     string
}

func newCustomers(defaultClient, securityClient HTTPClient, serverURL, language, sdkVersion, genVersion string) *customers {
	return &customers{
		defaultClient:  defaultClient,
		securityClient: securityClient,
		serverURL:      serverURL,
		language:       language,
		sdkVersion:     sdkVersion,
		genVersion:     genVersion,
	}
}

// ChromepolicyCustomersPoliciesGroupsBatchDelete - Delete multiple policy values that are applied to a specific group. All targets must have the same target format. That is to say that they must point to the same target resource and must have the same keys specified in `additionalTargetKeyNames`, though the values for those keys may be different. On failure the request will return the error details as part of the google.rpc.Status.
func (s *customers) ChromepolicyCustomersPoliciesGroupsBatchDelete(ctx context.Context, request operations.ChromepolicyCustomersPoliciesGroupsBatchDeleteRequest, security operations.ChromepolicyCustomersPoliciesGroupsBatchDeleteSecurity) (*operations.ChromepolicyCustomersPoliciesGroupsBatchDeleteResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/v1/{customer}/policies/groups:batchDelete", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "GoogleChromePolicyVersionsV1BatchDeleteGroupPoliciesRequest", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ChromepolicyCustomersPoliciesGroupsBatchDeleteResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GoogleProtobufEmpty = out
		}
	}

	return res, nil
}

// ChromepolicyCustomersPoliciesGroupsBatchModify - Modify multiple policy values that are applied to a specific group. All targets must have the same target format. That is to say that they must point to the same target resource and must have the same keys specified in `additionalTargetKeyNames`, though the values for those keys may be different. On failure the request will return the error details as part of the google.rpc.Status.
func (s *customers) ChromepolicyCustomersPoliciesGroupsBatchModify(ctx context.Context, request operations.ChromepolicyCustomersPoliciesGroupsBatchModifyRequest, security operations.ChromepolicyCustomersPoliciesGroupsBatchModifySecurity) (*operations.ChromepolicyCustomersPoliciesGroupsBatchModifyResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/v1/{customer}/policies/groups:batchModify", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "GoogleChromePolicyVersionsV1BatchModifyGroupPoliciesRequest", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ChromepolicyCustomersPoliciesGroupsBatchModifyResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GoogleProtobufEmpty = out
		}
	}

	return res, nil
}

// ChromepolicyCustomersPoliciesGroupsListGroupPriorityOrdering - Retrieve a group priority ordering for an app. The target app must be supplied in `additionalTargetKeyNames` in the PolicyTargetKey. On failure the request will return the error details as part of the google.rpc.Status.
func (s *customers) ChromepolicyCustomersPoliciesGroupsListGroupPriorityOrdering(ctx context.Context, request operations.ChromepolicyCustomersPoliciesGroupsListGroupPriorityOrderingRequest, security operations.ChromepolicyCustomersPoliciesGroupsListGroupPriorityOrderingSecurity) (*operations.ChromepolicyCustomersPoliciesGroupsListGroupPriorityOrderingResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/v1/{customer}/policies/groups:listGroupPriorityOrdering", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "GoogleChromePolicyVersionsV1ListGroupPriorityOrderingRequest", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ChromepolicyCustomersPoliciesGroupsListGroupPriorityOrderingResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.GoogleChromePolicyVersionsV1ListGroupPriorityOrderingResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GoogleChromePolicyVersionsV1ListGroupPriorityOrderingResponse = out
		}
	}

	return res, nil
}

// ChromepolicyCustomersPoliciesGroupsUpdateGroupPriorityOrdering - Update a group priority ordering for an app. The target app must be supplied in `additionalTargetKeyNames` in the PolicyTargetKey. On failure the request will return the error details as part of the google.rpc.Status.
func (s *customers) ChromepolicyCustomersPoliciesGroupsUpdateGroupPriorityOrdering(ctx context.Context, request operations.ChromepolicyCustomersPoliciesGroupsUpdateGroupPriorityOrderingRequest, security operations.ChromepolicyCustomersPoliciesGroupsUpdateGroupPriorityOrderingSecurity) (*operations.ChromepolicyCustomersPoliciesGroupsUpdateGroupPriorityOrderingResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/v1/{customer}/policies/groups:updateGroupPriorityOrdering", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "GoogleChromePolicyVersionsV1UpdateGroupPriorityOrderingRequest", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ChromepolicyCustomersPoliciesGroupsUpdateGroupPriorityOrderingResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GoogleProtobufEmpty = out
		}
	}

	return res, nil
}

// ChromepolicyCustomersPoliciesNetworksDefineCertificate - Creates a certificate at a specified OU for a customer.
func (s *customers) ChromepolicyCustomersPoliciesNetworksDefineCertificate(ctx context.Context, request operations.ChromepolicyCustomersPoliciesNetworksDefineCertificateRequest, security operations.ChromepolicyCustomersPoliciesNetworksDefineCertificateSecurity) (*operations.ChromepolicyCustomersPoliciesNetworksDefineCertificateResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/v1/{customer}/policies/networks:defineCertificate", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "GoogleChromePolicyVersionsV1DefineCertificateRequest", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ChromepolicyCustomersPoliciesNetworksDefineCertificateResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.GoogleChromePolicyVersionsV1DefineCertificateResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GoogleChromePolicyVersionsV1DefineCertificateResponse = out
		}
	}

	return res, nil
}

// ChromepolicyCustomersPoliciesNetworksDefineNetwork - Define a new network.
func (s *customers) ChromepolicyCustomersPoliciesNetworksDefineNetwork(ctx context.Context, request operations.ChromepolicyCustomersPoliciesNetworksDefineNetworkRequest, security operations.ChromepolicyCustomersPoliciesNetworksDefineNetworkSecurity) (*operations.ChromepolicyCustomersPoliciesNetworksDefineNetworkResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/v1/{customer}/policies/networks:defineNetwork", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "GoogleChromePolicyVersionsV1DefineNetworkRequest", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ChromepolicyCustomersPoliciesNetworksDefineNetworkResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.GoogleChromePolicyVersionsV1DefineNetworkResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GoogleChromePolicyVersionsV1DefineNetworkResponse = out
		}
	}

	return res, nil
}

// ChromepolicyCustomersPoliciesNetworksRemoveCertificate - Remove an existing certificate by guid.
func (s *customers) ChromepolicyCustomersPoliciesNetworksRemoveCertificate(ctx context.Context, request operations.ChromepolicyCustomersPoliciesNetworksRemoveCertificateRequest, security operations.ChromepolicyCustomersPoliciesNetworksRemoveCertificateSecurity) (*operations.ChromepolicyCustomersPoliciesNetworksRemoveCertificateResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/v1/{customer}/policies/networks:removeCertificate", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "GoogleChromePolicyVersionsV1RemoveCertificateRequest", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ChromepolicyCustomersPoliciesNetworksRemoveCertificateResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GoogleChromePolicyVersionsV1RemoveCertificateResponse = out
		}
	}

	return res, nil
}

// ChromepolicyCustomersPoliciesNetworksRemoveNetwork - Remove an existing network by guid.
func (s *customers) ChromepolicyCustomersPoliciesNetworksRemoveNetwork(ctx context.Context, request operations.ChromepolicyCustomersPoliciesNetworksRemoveNetworkRequest, security operations.ChromepolicyCustomersPoliciesNetworksRemoveNetworkSecurity) (*operations.ChromepolicyCustomersPoliciesNetworksRemoveNetworkResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/v1/{customer}/policies/networks:removeNetwork", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "GoogleChromePolicyVersionsV1RemoveNetworkRequest", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ChromepolicyCustomersPoliciesNetworksRemoveNetworkResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GoogleChromePolicyVersionsV1RemoveNetworkResponse = out
		}
	}

	return res, nil
}

// ChromepolicyCustomersPoliciesOrgunitsBatchInherit - Modify multiple policy values that are applied to a specific org unit so that they now inherit the value from a parent (if applicable). All targets must have the same target format. That is to say that they must point to the same target resource and must have the same keys specified in `additionalTargetKeyNames`, though the values for those keys may be different. On failure the request will return the error details as part of the google.rpc.Status.
func (s *customers) ChromepolicyCustomersPoliciesOrgunitsBatchInherit(ctx context.Context, request operations.ChromepolicyCustomersPoliciesOrgunitsBatchInheritRequest, security operations.ChromepolicyCustomersPoliciesOrgunitsBatchInheritSecurity) (*operations.ChromepolicyCustomersPoliciesOrgunitsBatchInheritResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/v1/{customer}/policies/orgunits:batchInherit", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "GoogleChromePolicyVersionsV1BatchInheritOrgUnitPoliciesRequest", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ChromepolicyCustomersPoliciesOrgunitsBatchInheritResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GoogleProtobufEmpty = out
		}
	}

	return res, nil
}

// ChromepolicyCustomersPoliciesOrgunitsBatchModify - Modify multiple policy values that are applied to a specific org unit. All targets must have the same target format. That is to say that they must point to the same target resource and must have the same keys specified in `additionalTargetKeyNames`, though the values for those keys may be different. On failure the request will return the error details as part of the google.rpc.Status.
func (s *customers) ChromepolicyCustomersPoliciesOrgunitsBatchModify(ctx context.Context, request operations.ChromepolicyCustomersPoliciesOrgunitsBatchModifyRequest, security operations.ChromepolicyCustomersPoliciesOrgunitsBatchModifySecurity) (*operations.ChromepolicyCustomersPoliciesOrgunitsBatchModifyResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/v1/{customer}/policies/orgunits:batchModify", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "GoogleChromePolicyVersionsV1BatchModifyOrgUnitPoliciesRequest", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ChromepolicyCustomersPoliciesOrgunitsBatchModifyResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GoogleProtobufEmpty = out
		}
	}

	return res, nil
}

// ChromepolicyCustomersPoliciesResolve - Gets the resolved policy values for a list of policies that match a search query.
func (s *customers) ChromepolicyCustomersPoliciesResolve(ctx context.Context, request operations.ChromepolicyCustomersPoliciesResolveRequest, security operations.ChromepolicyCustomersPoliciesResolveSecurity) (*operations.ChromepolicyCustomersPoliciesResolveResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/v1/{customer}/policies:resolve", request, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "GoogleChromePolicyVersionsV1ResolveRequest", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ChromepolicyCustomersPoliciesResolveResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.GoogleChromePolicyVersionsV1ResolveResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GoogleChromePolicyVersionsV1ResolveResponse = out
		}
	}

	return res, nil
}

// ChromepolicyCustomersPolicySchemasGet - Get a specific policy schema for a customer by its resource name.
func (s *customers) ChromepolicyCustomersPolicySchemasGet(ctx context.Context, request operations.ChromepolicyCustomersPolicySchemasGetRequest, security operations.ChromepolicyCustomersPolicySchemasGetSecurity) (*operations.ChromepolicyCustomersPolicySchemasGetResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/v1/{name}", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ChromepolicyCustomersPolicySchemasGetResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.GoogleChromePolicyVersionsV1PolicySchema
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GoogleChromePolicyVersionsV1PolicySchema = out
		}
	}

	return res, nil
}

// ChromepolicyCustomersPolicySchemasList - Gets a list of policy schemas that match a specified filter value for a given customer.
func (s *customers) ChromepolicyCustomersPolicySchemasList(ctx context.Context, request operations.ChromepolicyCustomersPolicySchemasListRequest, security operations.ChromepolicyCustomersPolicySchemasListSecurity) (*operations.ChromepolicyCustomersPolicySchemasListResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/v1/{parent}/policySchemas", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ChromepolicyCustomersPolicySchemasListResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.GoogleChromePolicyVersionsV1ListPolicySchemasResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GoogleChromePolicyVersionsV1ListPolicySchemasResponse = out
		}
	}

	return res, nil
}
