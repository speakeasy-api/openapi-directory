/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package org.openapis.openapi;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import java.net.http.HttpResponse;
import java.nio.charset.StandardCharsets;
import org.apache.http.NameValuePair;
import org.openapis.openapi.utils.HTTPClient;
import org.openapis.openapi.utils.HTTPRequest;
import org.openapis.openapi.utils.JSON;
import org.openapis.openapi.utils.SerializedBody;

public class Clients {
	
	private HTTPClient _defaultClient;
	private HTTPClient _securityClient;
	private String _serverUrl;
	private String _language;
	private String _sdkVersion;
	private String _genVersion;

	public Clients(HTTPClient defaultClient, HTTPClient securityClient, String serverUrl, String language, String sdkVersion, String genVersion) {
		this._defaultClient = defaultClient;
		this._securityClient = securityClient;
		this._serverUrl = serverUrl;
		this._language = language;
		this._sdkVersion = sdkVersion;
		this._genVersion = genVersion;
	}

    /**
     * Delete the client
     * @param request the request object containing all of the parameters for the API call
     * @return the response from the API call
     * @throws Exception if the API call fails
     */
    public org.openapis.openapi.models.operations.DeleteRealmClientsIdResponse deleteRealmClientsId(org.openapis.openapi.models.operations.DeleteRealmClientsIdRequest request) throws Exception {
        String baseUrl = this._serverUrl;
        String url = org.openapis.openapi.utils.Utils.generateURL(org.openapis.openapi.models.operations.DeleteRealmClientsIdRequest.class, baseUrl, "/{realm}/clients/{id}", request, null);
        
        HTTPRequest req = new HTTPRequest();
        req.setMethod("DELETE");
        req.setURL(url);
        
        
        HTTPClient client = this._securityClient;
        
        HttpResponse<byte[]> httpRes = client.send(req);

        String contentType = httpRes.headers().firstValue("Content-Type").orElse("application/octet-stream");

        org.openapis.openapi.models.operations.DeleteRealmClientsIdResponse res = new org.openapis.openapi.models.operations.DeleteRealmClientsIdResponse() {{
        }};
        res.statusCode = httpRes.statusCode();
        res.contentType = contentType;
        res.rawResponse = httpRes;
        
        if ((httpRes.statusCode() >= 200 && httpRes.statusCode() < 300)) {
        }

        return res;
    }

    public org.openapis.openapi.models.operations.DeleteRealmClientsIdDefaultClientScopesClientScopeIdResponse deleteRealmClientsIdDefaultClientScopesClientScopeId(org.openapis.openapi.models.operations.DeleteRealmClientsIdDefaultClientScopesClientScopeIdRequest request) throws Exception {
        String baseUrl = this._serverUrl;
        String url = org.openapis.openapi.utils.Utils.generateURL(org.openapis.openapi.models.operations.DeleteRealmClientsIdDefaultClientScopesClientScopeIdRequest.class, baseUrl, "/{realm}/clients/{id}/default-client-scopes/{clientScopeId}", request, null);
        
        HTTPRequest req = new HTTPRequest();
        req.setMethod("DELETE");
        req.setURL(url);
        
        
        HTTPClient client = this._securityClient;
        
        HttpResponse<byte[]> httpRes = client.send(req);

        String contentType = httpRes.headers().firstValue("Content-Type").orElse("application/octet-stream");

        org.openapis.openapi.models.operations.DeleteRealmClientsIdDefaultClientScopesClientScopeIdResponse res = new org.openapis.openapi.models.operations.DeleteRealmClientsIdDefaultClientScopesClientScopeIdResponse() {{
        }};
        res.statusCode = httpRes.statusCode();
        res.contentType = contentType;
        res.rawResponse = httpRes;
        
        if ((httpRes.statusCode() >= 200 && httpRes.statusCode() < 300)) {
        }

        return res;
    }

    /**
     * Unregister a cluster node from the client
     * @param request the request object containing all of the parameters for the API call
     * @return the response from the API call
     * @throws Exception if the API call fails
     */
    public org.openapis.openapi.models.operations.DeleteRealmClientsIdNodesNodeResponse deleteRealmClientsIdNodesNode(org.openapis.openapi.models.operations.DeleteRealmClientsIdNodesNodeRequest request) throws Exception {
        String baseUrl = this._serverUrl;
        String url = org.openapis.openapi.utils.Utils.generateURL(org.openapis.openapi.models.operations.DeleteRealmClientsIdNodesNodeRequest.class, baseUrl, "/{realm}/clients/{id}/nodes/{node}", request, null);
        
        HTTPRequest req = new HTTPRequest();
        req.setMethod("DELETE");
        req.setURL(url);
        
        
        HTTPClient client = this._securityClient;
        
        HttpResponse<byte[]> httpRes = client.send(req);

        String contentType = httpRes.headers().firstValue("Content-Type").orElse("application/octet-stream");

        org.openapis.openapi.models.operations.DeleteRealmClientsIdNodesNodeResponse res = new org.openapis.openapi.models.operations.DeleteRealmClientsIdNodesNodeResponse() {{
        }};
        res.statusCode = httpRes.statusCode();
        res.contentType = contentType;
        res.rawResponse = httpRes;
        
        if ((httpRes.statusCode() >= 200 && httpRes.statusCode() < 300)) {
        }

        return res;
    }

    public org.openapis.openapi.models.operations.DeleteRealmClientsIdOptionalClientScopesClientScopeIdResponse deleteRealmClientsIdOptionalClientScopesClientScopeId(org.openapis.openapi.models.operations.DeleteRealmClientsIdOptionalClientScopesClientScopeIdRequest request) throws Exception {
        String baseUrl = this._serverUrl;
        String url = org.openapis.openapi.utils.Utils.generateURL(org.openapis.openapi.models.operations.DeleteRealmClientsIdOptionalClientScopesClientScopeIdRequest.class, baseUrl, "/{realm}/clients/{id}/optional-client-scopes/{clientScopeId}", request, null);
        
        HTTPRequest req = new HTTPRequest();
        req.setMethod("DELETE");
        req.setURL(url);
        
        
        HTTPClient client = this._securityClient;
        
        HttpResponse<byte[]> httpRes = client.send(req);

        String contentType = httpRes.headers().firstValue("Content-Type").orElse("application/octet-stream");

        org.openapis.openapi.models.operations.DeleteRealmClientsIdOptionalClientScopesClientScopeIdResponse res = new org.openapis.openapi.models.operations.DeleteRealmClientsIdOptionalClientScopesClientScopeIdResponse() {{
        }};
        res.statusCode = httpRes.statusCode();
        res.contentType = contentType;
        res.rawResponse = httpRes;
        
        if ((httpRes.statusCode() >= 200 && httpRes.statusCode() < 300)) {
        }

        return res;
    }

    /**
     * Get clients belonging to the realm   Returns a list of clients belonging to the realm
     * @param request the request object containing all of the parameters for the API call
     * @return the response from the API call
     * @throws Exception if the API call fails
     */
    public org.openapis.openapi.models.operations.GetRealmClientsResponse getRealmClients(org.openapis.openapi.models.operations.GetRealmClientsRequest request) throws Exception {
        String baseUrl = this._serverUrl;
        String url = org.openapis.openapi.utils.Utils.generateURL(org.openapis.openapi.models.operations.GetRealmClientsRequest.class, baseUrl, "/{realm}/clients", request, null);
        
        HTTPRequest req = new HTTPRequest();
        req.setMethod("GET");
        req.setURL(url);
        
        java.util.List<NameValuePair> queryParams = org.openapis.openapi.utils.Utils.getQueryParams(org.openapis.openapi.models.operations.GetRealmClientsRequest.class, request, null);
        if (queryParams != null) {
            for (NameValuePair queryParam : queryParams) {
                req.addQueryParam(queryParam);
            }
        }
        
        HTTPClient client = this._securityClient;
        
        HttpResponse<byte[]> httpRes = client.send(req);

        String contentType = httpRes.headers().firstValue("Content-Type").orElse("application/octet-stream");

        org.openapis.openapi.models.operations.GetRealmClientsResponse res = new org.openapis.openapi.models.operations.GetRealmClientsResponse() {{
            clientRepresentations = null;
        }};
        res.statusCode = httpRes.statusCode();
        res.contentType = contentType;
        res.rawResponse = httpRes;
        
        if ((httpRes.statusCode() >= 200 && httpRes.statusCode() < 300)) {
            if (org.openapis.openapi.utils.Utils.matchContentType(contentType, "application/json")) {
                ObjectMapper mapper = JSON.getMapper();
                org.openapis.openapi.models.shared.ClientRepresentation[] out = mapper.readValue(new String(httpRes.body(), StandardCharsets.UTF_8), org.openapis.openapi.models.shared.ClientRepresentation[].class);
                res.clientRepresentations = out;
            }
        }

        return res;
    }

    /**
     * Get representation of the client
     * @param request the request object containing all of the parameters for the API call
     * @return the response from the API call
     * @throws Exception if the API call fails
     */
    public org.openapis.openapi.models.operations.GetRealmClientsIdResponse getRealmClientsId(org.openapis.openapi.models.operations.GetRealmClientsIdRequest request) throws Exception {
        String baseUrl = this._serverUrl;
        String url = org.openapis.openapi.utils.Utils.generateURL(org.openapis.openapi.models.operations.GetRealmClientsIdRequest.class, baseUrl, "/{realm}/clients/{id}", request, null);
        
        HTTPRequest req = new HTTPRequest();
        req.setMethod("GET");
        req.setURL(url);
        
        
        HTTPClient client = this._securityClient;
        
        HttpResponse<byte[]> httpRes = client.send(req);

        String contentType = httpRes.headers().firstValue("Content-Type").orElse("application/octet-stream");

        org.openapis.openapi.models.operations.GetRealmClientsIdResponse res = new org.openapis.openapi.models.operations.GetRealmClientsIdResponse() {{
            clientRepresentation = null;
        }};
        res.statusCode = httpRes.statusCode();
        res.contentType = contentType;
        res.rawResponse = httpRes;
        
        if ((httpRes.statusCode() >= 200 && httpRes.statusCode() < 300)) {
            if (org.openapis.openapi.utils.Utils.matchContentType(contentType, "application/json")) {
                ObjectMapper mapper = JSON.getMapper();
                org.openapis.openapi.models.shared.ClientRepresentation out = mapper.readValue(new String(httpRes.body(), StandardCharsets.UTF_8), org.openapis.openapi.models.shared.ClientRepresentation.class);
                res.clientRepresentation = out;
            }
        }

        return res;
    }

    /**
     * Get the client secret
     * @param request the request object containing all of the parameters for the API call
     * @return the response from the API call
     * @throws Exception if the API call fails
     */
    public org.openapis.openapi.models.operations.GetRealmClientsIdClientSecretResponse getRealmClientsIdClientSecret(org.openapis.openapi.models.operations.GetRealmClientsIdClientSecretRequest request) throws Exception {
        String baseUrl = this._serverUrl;
        String url = org.openapis.openapi.utils.Utils.generateURL(org.openapis.openapi.models.operations.GetRealmClientsIdClientSecretRequest.class, baseUrl, "/{realm}/clients/{id}/client-secret", request, null);
        
        HTTPRequest req = new HTTPRequest();
        req.setMethod("GET");
        req.setURL(url);
        
        
        HTTPClient client = this._securityClient;
        
        HttpResponse<byte[]> httpRes = client.send(req);

        String contentType = httpRes.headers().firstValue("Content-Type").orElse("application/octet-stream");

        org.openapis.openapi.models.operations.GetRealmClientsIdClientSecretResponse res = new org.openapis.openapi.models.operations.GetRealmClientsIdClientSecretResponse() {{
            credentialRepresentation = null;
        }};
        res.statusCode = httpRes.statusCode();
        res.contentType = contentType;
        res.rawResponse = httpRes;
        
        if ((httpRes.statusCode() >= 200 && httpRes.statusCode() < 300)) {
            if (org.openapis.openapi.utils.Utils.matchContentType(contentType, "application/json")) {
                ObjectMapper mapper = JSON.getMapper();
                org.openapis.openapi.models.shared.CredentialRepresentation out = mapper.readValue(new String(httpRes.body(), StandardCharsets.UTF_8), org.openapis.openapi.models.shared.CredentialRepresentation.class);
                res.credentialRepresentation = out;
            }
        }

        return res;
    }

    /**
     * Get default client scopes.
     * @param request the request object containing all of the parameters for the API call
     * @return the response from the API call
     * @throws Exception if the API call fails
     */
    public org.openapis.openapi.models.operations.GetRealmClientsIdDefaultClientScopesResponse getRealmClientsIdDefaultClientScopes(org.openapis.openapi.models.operations.GetRealmClientsIdDefaultClientScopesRequest request) throws Exception {
        String baseUrl = this._serverUrl;
        String url = org.openapis.openapi.utils.Utils.generateURL(org.openapis.openapi.models.operations.GetRealmClientsIdDefaultClientScopesRequest.class, baseUrl, "/{realm}/clients/{id}/default-client-scopes", request, null);
        
        HTTPRequest req = new HTTPRequest();
        req.setMethod("GET");
        req.setURL(url);
        
        
        HTTPClient client = this._securityClient;
        
        HttpResponse<byte[]> httpRes = client.send(req);

        String contentType = httpRes.headers().firstValue("Content-Type").orElse("application/octet-stream");

        org.openapis.openapi.models.operations.GetRealmClientsIdDefaultClientScopesResponse res = new org.openapis.openapi.models.operations.GetRealmClientsIdDefaultClientScopesResponse() {{
            clientScopeRepresentations = null;
        }};
        res.statusCode = httpRes.statusCode();
        res.contentType = contentType;
        res.rawResponse = httpRes;
        
        if ((httpRes.statusCode() >= 200 && httpRes.statusCode() < 300)) {
            if (org.openapis.openapi.utils.Utils.matchContentType(contentType, "application/json")) {
                ObjectMapper mapper = JSON.getMapper();
                org.openapis.openapi.models.shared.ClientScopeRepresentation[] out = mapper.readValue(new String(httpRes.body(), StandardCharsets.UTF_8), org.openapis.openapi.models.shared.ClientScopeRepresentation[].class);
                res.clientScopeRepresentations = out;
            }
        }

        return res;
    }

    /**
     * Create JSON with payload of example access token
     * @param request the request object containing all of the parameters for the API call
     * @return the response from the API call
     * @throws Exception if the API call fails
     */
    public org.openapis.openapi.models.operations.GetRealmClientsIdEvaluateScopesGenerateExampleAccessTokenResponse getRealmClientsIdEvaluateScopesGenerateExampleAccessToken(org.openapis.openapi.models.operations.GetRealmClientsIdEvaluateScopesGenerateExampleAccessTokenRequest request) throws Exception {
        String baseUrl = this._serverUrl;
        String url = org.openapis.openapi.utils.Utils.generateURL(org.openapis.openapi.models.operations.GetRealmClientsIdEvaluateScopesGenerateExampleAccessTokenRequest.class, baseUrl, "/{realm}/clients/{id}/evaluate-scopes/generate-example-access-token", request, null);
        
        HTTPRequest req = new HTTPRequest();
        req.setMethod("GET");
        req.setURL(url);
        
        java.util.List<NameValuePair> queryParams = org.openapis.openapi.utils.Utils.getQueryParams(org.openapis.openapi.models.operations.GetRealmClientsIdEvaluateScopesGenerateExampleAccessTokenRequest.class, request, null);
        if (queryParams != null) {
            for (NameValuePair queryParam : queryParams) {
                req.addQueryParam(queryParam);
            }
        }
        
        HTTPClient client = this._securityClient;
        
        HttpResponse<byte[]> httpRes = client.send(req);

        String contentType = httpRes.headers().firstValue("Content-Type").orElse("application/octet-stream");

        org.openapis.openapi.models.operations.GetRealmClientsIdEvaluateScopesGenerateExampleAccessTokenResponse res = new org.openapis.openapi.models.operations.GetRealmClientsIdEvaluateScopesGenerateExampleAccessTokenResponse() {{
            accessToken = null;
        }};
        res.statusCode = httpRes.statusCode();
        res.contentType = contentType;
        res.rawResponse = httpRes;
        
        if ((httpRes.statusCode() >= 200 && httpRes.statusCode() < 300)) {
            if (org.openapis.openapi.utils.Utils.matchContentType(contentType, "application/json")) {
                ObjectMapper mapper = JSON.getMapper();
                org.openapis.openapi.models.shared.AccessToken out = mapper.readValue(new String(httpRes.body(), StandardCharsets.UTF_8), org.openapis.openapi.models.shared.AccessToken.class);
                res.accessToken = out;
            }
        }

        return res;
    }

    /**
     * Return list of all protocol mappers, which will be used when generating tokens issued for particular client.
     * @param request the request object containing all of the parameters for the API call
     * @return the response from the API call
     * @throws Exception if the API call fails
     */
    public org.openapis.openapi.models.operations.GetRealmClientsIdEvaluateScopesProtocolMappersResponse getRealmClientsIdEvaluateScopesProtocolMappers(org.openapis.openapi.models.operations.GetRealmClientsIdEvaluateScopesProtocolMappersRequest request) throws Exception {
        String baseUrl = this._serverUrl;
        String url = org.openapis.openapi.utils.Utils.generateURL(org.openapis.openapi.models.operations.GetRealmClientsIdEvaluateScopesProtocolMappersRequest.class, baseUrl, "/{realm}/clients/{id}/evaluate-scopes/protocol-mappers", request, null);
        
        HTTPRequest req = new HTTPRequest();
        req.setMethod("GET");
        req.setURL(url);
        
        java.util.List<NameValuePair> queryParams = org.openapis.openapi.utils.Utils.getQueryParams(org.openapis.openapi.models.operations.GetRealmClientsIdEvaluateScopesProtocolMappersRequest.class, request, null);
        if (queryParams != null) {
            for (NameValuePair queryParam : queryParams) {
                req.addQueryParam(queryParam);
            }
        }
        
        HTTPClient client = this._securityClient;
        
        HttpResponse<byte[]> httpRes = client.send(req);

        String contentType = httpRes.headers().firstValue("Content-Type").orElse("application/octet-stream");

        org.openapis.openapi.models.operations.GetRealmClientsIdEvaluateScopesProtocolMappersResponse res = new org.openapis.openapi.models.operations.GetRealmClientsIdEvaluateScopesProtocolMappersResponse() {{
            clientScopeEvaluateResourceProtocolMapperEvaluationRepresentations = null;
        }};
        res.statusCode = httpRes.statusCode();
        res.contentType = contentType;
        res.rawResponse = httpRes;
        
        if ((httpRes.statusCode() >= 200 && httpRes.statusCode() < 300)) {
            if (org.openapis.openapi.utils.Utils.matchContentType(contentType, "application/json")) {
                ObjectMapper mapper = JSON.getMapper();
                org.openapis.openapi.models.shared.ClientScopeEvaluateResourceProtocolMapperEvaluationRepresentation[] out = mapper.readValue(new String(httpRes.body(), StandardCharsets.UTF_8), org.openapis.openapi.models.shared.ClientScopeEvaluateResourceProtocolMapperEvaluationRepresentation[].class);
                res.clientScopeEvaluateResourceProtocolMapperEvaluationRepresentations = out;
            }
        }

        return res;
    }

    /**
     * Get effective scope mapping of all roles of particular role container, which this client is defacto allowed to have in the accessToken issued for him.
     * @param request the request object containing all of the parameters for the API call
     * @return the response from the API call
     * @throws Exception if the API call fails
     */
    public org.openapis.openapi.models.operations.GetRealmClientsIdEvaluateScopesScopeMappingsRoleContainerIdGrantedResponse getRealmClientsIdEvaluateScopesScopeMappingsRoleContainerIdGranted(org.openapis.openapi.models.operations.GetRealmClientsIdEvaluateScopesScopeMappingsRoleContainerIdGrantedRequest request) throws Exception {
        String baseUrl = this._serverUrl;
        String url = org.openapis.openapi.utils.Utils.generateURL(org.openapis.openapi.models.operations.GetRealmClientsIdEvaluateScopesScopeMappingsRoleContainerIdGrantedRequest.class, baseUrl, "/{realm}/clients/{id}/evaluate-scopes/scope-mappings/{roleContainerId}/granted", request, null);
        
        HTTPRequest req = new HTTPRequest();
        req.setMethod("GET");
        req.setURL(url);
        
        java.util.List<NameValuePair> queryParams = org.openapis.openapi.utils.Utils.getQueryParams(org.openapis.openapi.models.operations.GetRealmClientsIdEvaluateScopesScopeMappingsRoleContainerIdGrantedRequest.class, request, null);
        if (queryParams != null) {
            for (NameValuePair queryParam : queryParams) {
                req.addQueryParam(queryParam);
            }
        }
        
        HTTPClient client = this._securityClient;
        
        HttpResponse<byte[]> httpRes = client.send(req);

        String contentType = httpRes.headers().firstValue("Content-Type").orElse("application/octet-stream");

        org.openapis.openapi.models.operations.GetRealmClientsIdEvaluateScopesScopeMappingsRoleContainerIdGrantedResponse res = new org.openapis.openapi.models.operations.GetRealmClientsIdEvaluateScopesScopeMappingsRoleContainerIdGrantedResponse() {{
            roleRepresentations = null;
        }};
        res.statusCode = httpRes.statusCode();
        res.contentType = contentType;
        res.rawResponse = httpRes;
        
        if ((httpRes.statusCode() >= 200 && httpRes.statusCode() < 300)) {
            if (org.openapis.openapi.utils.Utils.matchContentType(contentType, "application/json")) {
                ObjectMapper mapper = JSON.getMapper();
                org.openapis.openapi.models.shared.RoleRepresentation[] out = mapper.readValue(new String(httpRes.body(), StandardCharsets.UTF_8), org.openapis.openapi.models.shared.RoleRepresentation[].class);
                res.roleRepresentations = out;
            }
        }

        return res;
    }

    /**
     * Get roles, which this client doesn\u2019t have scope for and can\u2019t have them in the accessToken issued for him.
     * @param request the request object containing all of the parameters for the API call
     * @return the response from the API call
     * @throws Exception if the API call fails
     */
    public org.openapis.openapi.models.operations.GetRealmClientsIdEvaluateScopesScopeMappingsRoleContainerIdNotGrantedResponse getRealmClientsIdEvaluateScopesScopeMappingsRoleContainerIdNotGranted(org.openapis.openapi.models.operations.GetRealmClientsIdEvaluateScopesScopeMappingsRoleContainerIdNotGrantedRequest request) throws Exception {
        String baseUrl = this._serverUrl;
        String url = org.openapis.openapi.utils.Utils.generateURL(org.openapis.openapi.models.operations.GetRealmClientsIdEvaluateScopesScopeMappingsRoleContainerIdNotGrantedRequest.class, baseUrl, "/{realm}/clients/{id}/evaluate-scopes/scope-mappings/{roleContainerId}/not-granted", request, null);
        
        HTTPRequest req = new HTTPRequest();
        req.setMethod("GET");
        req.setURL(url);
        
        java.util.List<NameValuePair> queryParams = org.openapis.openapi.utils.Utils.getQueryParams(org.openapis.openapi.models.operations.GetRealmClientsIdEvaluateScopesScopeMappingsRoleContainerIdNotGrantedRequest.class, request, null);
        if (queryParams != null) {
            for (NameValuePair queryParam : queryParams) {
                req.addQueryParam(queryParam);
            }
        }
        
        HTTPClient client = this._securityClient;
        
        HttpResponse<byte[]> httpRes = client.send(req);

        String contentType = httpRes.headers().firstValue("Content-Type").orElse("application/octet-stream");

        org.openapis.openapi.models.operations.GetRealmClientsIdEvaluateScopesScopeMappingsRoleContainerIdNotGrantedResponse res = new org.openapis.openapi.models.operations.GetRealmClientsIdEvaluateScopesScopeMappingsRoleContainerIdNotGrantedResponse() {{
            roleRepresentations = null;
        }};
        res.statusCode = httpRes.statusCode();
        res.contentType = contentType;
        res.rawResponse = httpRes;
        
        if ((httpRes.statusCode() >= 200 && httpRes.statusCode() < 300)) {
            if (org.openapis.openapi.utils.Utils.matchContentType(contentType, "application/json")) {
                ObjectMapper mapper = JSON.getMapper();
                org.openapis.openapi.models.shared.RoleRepresentation[] out = mapper.readValue(new String(httpRes.body(), StandardCharsets.UTF_8), org.openapis.openapi.models.shared.RoleRepresentation[].class);
                res.roleRepresentations = out;
            }
        }

        return res;
    }

    public org.openapis.openapi.models.operations.GetRealmClientsIdInstallationProvidersProviderIdResponse getRealmClientsIdInstallationProvidersProviderId(org.openapis.openapi.models.operations.GetRealmClientsIdInstallationProvidersProviderIdRequest request) throws Exception {
        String baseUrl = this._serverUrl;
        String url = org.openapis.openapi.utils.Utils.generateURL(org.openapis.openapi.models.operations.GetRealmClientsIdInstallationProvidersProviderIdRequest.class, baseUrl, "/{realm}/clients/{id}/installation/providers/{providerId}", request, null);
        
        HTTPRequest req = new HTTPRequest();
        req.setMethod("GET");
        req.setURL(url);
        
        
        HTTPClient client = this._securityClient;
        
        HttpResponse<byte[]> httpRes = client.send(req);

        String contentType = httpRes.headers().firstValue("Content-Type").orElse("application/octet-stream");

        org.openapis.openapi.models.operations.GetRealmClientsIdInstallationProvidersProviderIdResponse res = new org.openapis.openapi.models.operations.GetRealmClientsIdInstallationProvidersProviderIdResponse() {{
        }};
        res.statusCode = httpRes.statusCode();
        res.contentType = contentType;
        res.rawResponse = httpRes;
        
        if ((httpRes.statusCode() >= 200 && httpRes.statusCode() < 300)) {
        }

        return res;
    }

    /**
     * Return object stating whether client Authorization permissions have been initialized or not and a reference
     * @param request the request object containing all of the parameters for the API call
     * @return the response from the API call
     * @throws Exception if the API call fails
     */
    public org.openapis.openapi.models.operations.GetRealmClientsIdManagementPermissionsResponse getRealmClientsIdManagementPermissions(org.openapis.openapi.models.operations.GetRealmClientsIdManagementPermissionsRequest request) throws Exception {
        String baseUrl = this._serverUrl;
        String url = org.openapis.openapi.utils.Utils.generateURL(org.openapis.openapi.models.operations.GetRealmClientsIdManagementPermissionsRequest.class, baseUrl, "/{realm}/clients/{id}/management/permissions", request, null);
        
        HTTPRequest req = new HTTPRequest();
        req.setMethod("GET");
        req.setURL(url);
        
        
        HTTPClient client = this._securityClient;
        
        HttpResponse<byte[]> httpRes = client.send(req);

        String contentType = httpRes.headers().firstValue("Content-Type").orElse("application/octet-stream");

        org.openapis.openapi.models.operations.GetRealmClientsIdManagementPermissionsResponse res = new org.openapis.openapi.models.operations.GetRealmClientsIdManagementPermissionsResponse() {{
            managementPermissionReference = null;
        }};
        res.statusCode = httpRes.statusCode();
        res.contentType = contentType;
        res.rawResponse = httpRes;
        
        if ((httpRes.statusCode() >= 200 && httpRes.statusCode() < 300)) {
            if (org.openapis.openapi.utils.Utils.matchContentType(contentType, "application/json")) {
                ObjectMapper mapper = JSON.getMapper();
                org.openapis.openapi.models.shared.ManagementPermissionReference out = mapper.readValue(new String(httpRes.body(), StandardCharsets.UTF_8), org.openapis.openapi.models.shared.ManagementPermissionReference.class);
                res.managementPermissionReference = out;
            }
        }

        return res;
    }

    /**
     * Get application offline session count   Returns a number of offline user sessions associated with this client   {      "count": number  }
     * @param request the request object containing all of the parameters for the API call
     * @return the response from the API call
     * @throws Exception if the API call fails
     */
    public org.openapis.openapi.models.operations.GetRealmClientsIdOfflineSessionCountResponse getRealmClientsIdOfflineSessionCount(org.openapis.openapi.models.operations.GetRealmClientsIdOfflineSessionCountRequest request) throws Exception {
        String baseUrl = this._serverUrl;
        String url = org.openapis.openapi.utils.Utils.generateURL(org.openapis.openapi.models.operations.GetRealmClientsIdOfflineSessionCountRequest.class, baseUrl, "/{realm}/clients/{id}/offline-session-count", request, null);
        
        HTTPRequest req = new HTTPRequest();
        req.setMethod("GET");
        req.setURL(url);
        
        
        HTTPClient client = this._securityClient;
        
        HttpResponse<byte[]> httpRes = client.send(req);

        String contentType = httpRes.headers().firstValue("Content-Type").orElse("application/octet-stream");

        org.openapis.openapi.models.operations.GetRealmClientsIdOfflineSessionCountResponse res = new org.openapis.openapi.models.operations.GetRealmClientsIdOfflineSessionCountResponse() {{
            getRealmClientsIdOfflineSessionCount2XXApplicationJSONObject = null;
        }};
        res.statusCode = httpRes.statusCode();
        res.contentType = contentType;
        res.rawResponse = httpRes;
        
        if ((httpRes.statusCode() >= 200 && httpRes.statusCode() < 300)) {
            if (org.openapis.openapi.utils.Utils.matchContentType(contentType, "application/json")) {
                ObjectMapper mapper = JSON.getMapper();
                java.util.Map<String, Object> out = mapper.readValue(new String(httpRes.body(), StandardCharsets.UTF_8), new TypeReference<java.util.Map<String, Object>>() {});
                res.getRealmClientsIdOfflineSessionCount2XXApplicationJSONObject = out;
            }
        }

        return res;
    }

    /**
     * Get offline sessions for client   Returns a list of offline user sessions associated with this client
     * @param request the request object containing all of the parameters for the API call
     * @return the response from the API call
     * @throws Exception if the API call fails
     */
    public org.openapis.openapi.models.operations.GetRealmClientsIdOfflineSessionsResponse getRealmClientsIdOfflineSessions(org.openapis.openapi.models.operations.GetRealmClientsIdOfflineSessionsRequest request) throws Exception {
        String baseUrl = this._serverUrl;
        String url = org.openapis.openapi.utils.Utils.generateURL(org.openapis.openapi.models.operations.GetRealmClientsIdOfflineSessionsRequest.class, baseUrl, "/{realm}/clients/{id}/offline-sessions", request, null);
        
        HTTPRequest req = new HTTPRequest();
        req.setMethod("GET");
        req.setURL(url);
        
        java.util.List<NameValuePair> queryParams = org.openapis.openapi.utils.Utils.getQueryParams(org.openapis.openapi.models.operations.GetRealmClientsIdOfflineSessionsRequest.class, request, null);
        if (queryParams != null) {
            for (NameValuePair queryParam : queryParams) {
                req.addQueryParam(queryParam);
            }
        }
        
        HTTPClient client = this._securityClient;
        
        HttpResponse<byte[]> httpRes = client.send(req);

        String contentType = httpRes.headers().firstValue("Content-Type").orElse("application/octet-stream");

        org.openapis.openapi.models.operations.GetRealmClientsIdOfflineSessionsResponse res = new org.openapis.openapi.models.operations.GetRealmClientsIdOfflineSessionsResponse() {{
            userSessionRepresentations = null;
        }};
        res.statusCode = httpRes.statusCode();
        res.contentType = contentType;
        res.rawResponse = httpRes;
        
        if ((httpRes.statusCode() >= 200 && httpRes.statusCode() < 300)) {
            if (org.openapis.openapi.utils.Utils.matchContentType(contentType, "application/json")) {
                ObjectMapper mapper = JSON.getMapper();
                org.openapis.openapi.models.shared.UserSessionRepresentation[] out = mapper.readValue(new String(httpRes.body(), StandardCharsets.UTF_8), org.openapis.openapi.models.shared.UserSessionRepresentation[].class);
                res.userSessionRepresentations = out;
            }
        }

        return res;
    }

    /**
     * Get optional client scopes.
     * @param request the request object containing all of the parameters for the API call
     * @return the response from the API call
     * @throws Exception if the API call fails
     */
    public org.openapis.openapi.models.operations.GetRealmClientsIdOptionalClientScopesResponse getRealmClientsIdOptionalClientScopes(org.openapis.openapi.models.operations.GetRealmClientsIdOptionalClientScopesRequest request) throws Exception {
        String baseUrl = this._serverUrl;
        String url = org.openapis.openapi.utils.Utils.generateURL(org.openapis.openapi.models.operations.GetRealmClientsIdOptionalClientScopesRequest.class, baseUrl, "/{realm}/clients/{id}/optional-client-scopes", request, null);
        
        HTTPRequest req = new HTTPRequest();
        req.setMethod("GET");
        req.setURL(url);
        
        
        HTTPClient client = this._securityClient;
        
        HttpResponse<byte[]> httpRes = client.send(req);

        String contentType = httpRes.headers().firstValue("Content-Type").orElse("application/octet-stream");

        org.openapis.openapi.models.operations.GetRealmClientsIdOptionalClientScopesResponse res = new org.openapis.openapi.models.operations.GetRealmClientsIdOptionalClientScopesResponse() {{
            clientScopeRepresentations = null;
        }};
        res.statusCode = httpRes.statusCode();
        res.contentType = contentType;
        res.rawResponse = httpRes;
        
        if ((httpRes.statusCode() >= 200 && httpRes.statusCode() < 300)) {
            if (org.openapis.openapi.utils.Utils.matchContentType(contentType, "application/json")) {
                ObjectMapper mapper = JSON.getMapper();
                org.openapis.openapi.models.shared.ClientScopeRepresentation[] out = mapper.readValue(new String(httpRes.body(), StandardCharsets.UTF_8), org.openapis.openapi.models.shared.ClientScopeRepresentation[].class);
                res.clientScopeRepresentations = out;
            }
        }

        return res;
    }

    /**
     * Get a user dedicated to the service account
     * @param request the request object containing all of the parameters for the API call
     * @return the response from the API call
     * @throws Exception if the API call fails
     */
    public org.openapis.openapi.models.operations.GetRealmClientsIdServiceAccountUserResponse getRealmClientsIdServiceAccountUser(org.openapis.openapi.models.operations.GetRealmClientsIdServiceAccountUserRequest request) throws Exception {
        String baseUrl = this._serverUrl;
        String url = org.openapis.openapi.utils.Utils.generateURL(org.openapis.openapi.models.operations.GetRealmClientsIdServiceAccountUserRequest.class, baseUrl, "/{realm}/clients/{id}/service-account-user", request, null);
        
        HTTPRequest req = new HTTPRequest();
        req.setMethod("GET");
        req.setURL(url);
        
        
        HTTPClient client = this._securityClient;
        
        HttpResponse<byte[]> httpRes = client.send(req);

        String contentType = httpRes.headers().firstValue("Content-Type").orElse("application/octet-stream");

        org.openapis.openapi.models.operations.GetRealmClientsIdServiceAccountUserResponse res = new org.openapis.openapi.models.operations.GetRealmClientsIdServiceAccountUserResponse() {{
            userRepresentation = null;
        }};
        res.statusCode = httpRes.statusCode();
        res.contentType = contentType;
        res.rawResponse = httpRes;
        
        if ((httpRes.statusCode() >= 200 && httpRes.statusCode() < 300)) {
            if (org.openapis.openapi.utils.Utils.matchContentType(contentType, "application/json")) {
                ObjectMapper mapper = JSON.getMapper();
                org.openapis.openapi.models.shared.UserRepresentation out = mapper.readValue(new String(httpRes.body(), StandardCharsets.UTF_8), org.openapis.openapi.models.shared.UserRepresentation.class);
                res.userRepresentation = out;
            }
        }

        return res;
    }

    /**
     * Get application session count   Returns a number of user sessions associated with this client   {      "count": number  }
     * @param request the request object containing all of the parameters for the API call
     * @return the response from the API call
     * @throws Exception if the API call fails
     */
    public org.openapis.openapi.models.operations.GetRealmClientsIdSessionCountResponse getRealmClientsIdSessionCount(org.openapis.openapi.models.operations.GetRealmClientsIdSessionCountRequest request) throws Exception {
        String baseUrl = this._serverUrl;
        String url = org.openapis.openapi.utils.Utils.generateURL(org.openapis.openapi.models.operations.GetRealmClientsIdSessionCountRequest.class, baseUrl, "/{realm}/clients/{id}/session-count", request, null);
        
        HTTPRequest req = new HTTPRequest();
        req.setMethod("GET");
        req.setURL(url);
        
        
        HTTPClient client = this._securityClient;
        
        HttpResponse<byte[]> httpRes = client.send(req);

        String contentType = httpRes.headers().firstValue("Content-Type").orElse("application/octet-stream");

        org.openapis.openapi.models.operations.GetRealmClientsIdSessionCountResponse res = new org.openapis.openapi.models.operations.GetRealmClientsIdSessionCountResponse() {{
            getRealmClientsIdSessionCount2XXApplicationJSONObject = null;
        }};
        res.statusCode = httpRes.statusCode();
        res.contentType = contentType;
        res.rawResponse = httpRes;
        
        if ((httpRes.statusCode() >= 200 && httpRes.statusCode() < 300)) {
            if (org.openapis.openapi.utils.Utils.matchContentType(contentType, "application/json")) {
                ObjectMapper mapper = JSON.getMapper();
                java.util.Map<String, Object> out = mapper.readValue(new String(httpRes.body(), StandardCharsets.UTF_8), new TypeReference<java.util.Map<String, Object>>() {});
                res.getRealmClientsIdSessionCount2XXApplicationJSONObject = out;
            }
        }

        return res;
    }

    /**
     * Test if registered cluster nodes are available   Tests availability by sending 'ping' request to all cluster nodes.
     * @param request the request object containing all of the parameters for the API call
     * @return the response from the API call
     * @throws Exception if the API call fails
     */
    public org.openapis.openapi.models.operations.GetRealmClientsIdTestNodesAvailableResponse getRealmClientsIdTestNodesAvailable(org.openapis.openapi.models.operations.GetRealmClientsIdTestNodesAvailableRequest request) throws Exception {
        String baseUrl = this._serverUrl;
        String url = org.openapis.openapi.utils.Utils.generateURL(org.openapis.openapi.models.operations.GetRealmClientsIdTestNodesAvailableRequest.class, baseUrl, "/{realm}/clients/{id}/test-nodes-available", request, null);
        
        HTTPRequest req = new HTTPRequest();
        req.setMethod("GET");
        req.setURL(url);
        
        
        HTTPClient client = this._securityClient;
        
        HttpResponse<byte[]> httpRes = client.send(req);

        String contentType = httpRes.headers().firstValue("Content-Type").orElse("application/octet-stream");

        org.openapis.openapi.models.operations.GetRealmClientsIdTestNodesAvailableResponse res = new org.openapis.openapi.models.operations.GetRealmClientsIdTestNodesAvailableResponse() {{
            globalRequestResult = null;
        }};
        res.statusCode = httpRes.statusCode();
        res.contentType = contentType;
        res.rawResponse = httpRes;
        
        if ((httpRes.statusCode() >= 200 && httpRes.statusCode() < 300)) {
            if (org.openapis.openapi.utils.Utils.matchContentType(contentType, "application/json")) {
                ObjectMapper mapper = JSON.getMapper();
                org.openapis.openapi.models.shared.GlobalRequestResult out = mapper.readValue(new String(httpRes.body(), StandardCharsets.UTF_8), org.openapis.openapi.models.shared.GlobalRequestResult.class);
                res.globalRequestResult = out;
            }
        }

        return res;
    }

    /**
     * Get user sessions for client   Returns a list of user sessions associated with this client
     * @param request the request object containing all of the parameters for the API call
     * @return the response from the API call
     * @throws Exception if the API call fails
     */
    public org.openapis.openapi.models.operations.GetRealmClientsIdUserSessionsResponse getRealmClientsIdUserSessions(org.openapis.openapi.models.operations.GetRealmClientsIdUserSessionsRequest request) throws Exception {
        String baseUrl = this._serverUrl;
        String url = org.openapis.openapi.utils.Utils.generateURL(org.openapis.openapi.models.operations.GetRealmClientsIdUserSessionsRequest.class, baseUrl, "/{realm}/clients/{id}/user-sessions", request, null);
        
        HTTPRequest req = new HTTPRequest();
        req.setMethod("GET");
        req.setURL(url);
        
        java.util.List<NameValuePair> queryParams = org.openapis.openapi.utils.Utils.getQueryParams(org.openapis.openapi.models.operations.GetRealmClientsIdUserSessionsRequest.class, request, null);
        if (queryParams != null) {
            for (NameValuePair queryParam : queryParams) {
                req.addQueryParam(queryParam);
            }
        }
        
        HTTPClient client = this._securityClient;
        
        HttpResponse<byte[]> httpRes = client.send(req);

        String contentType = httpRes.headers().firstValue("Content-Type").orElse("application/octet-stream");

        org.openapis.openapi.models.operations.GetRealmClientsIdUserSessionsResponse res = new org.openapis.openapi.models.operations.GetRealmClientsIdUserSessionsResponse() {{
            userSessionRepresentations = null;
        }};
        res.statusCode = httpRes.statusCode();
        res.contentType = contentType;
        res.rawResponse = httpRes;
        
        if ((httpRes.statusCode() >= 200 && httpRes.statusCode() < 300)) {
            if (org.openapis.openapi.utils.Utils.matchContentType(contentType, "application/json")) {
                ObjectMapper mapper = JSON.getMapper();
                org.openapis.openapi.models.shared.UserSessionRepresentation[] out = mapper.readValue(new String(httpRes.body(), StandardCharsets.UTF_8), org.openapis.openapi.models.shared.UserSessionRepresentation[].class);
                res.userSessionRepresentations = out;
            }
        }

        return res;
    }

    /**
     * Create a new client   Client\u2019s client_id must be unique!
     * @param request the request object containing all of the parameters for the API call
     * @return the response from the API call
     * @throws Exception if the API call fails
     */
    public org.openapis.openapi.models.operations.PostRealmClientsResponse postRealmClients(org.openapis.openapi.models.operations.PostRealmClientsRequest request) throws Exception {
        String baseUrl = this._serverUrl;
        String url = org.openapis.openapi.utils.Utils.generateURL(org.openapis.openapi.models.operations.PostRealmClientsRequest.class, baseUrl, "/{realm}/clients", request, null);
        
        HTTPRequest req = new HTTPRequest();
        req.setMethod("POST");
        req.setURL(url);
        SerializedBody serializedRequestBody = org.openapis.openapi.utils.Utils.serializeRequestBody(request, "clientRepresentation", "json");
        if (serializedRequestBody == null) {
            throw new Exception("Request body is required");
        }
        req.setBody(serializedRequestBody);
        
        
        HTTPClient client = this._securityClient;
        
        HttpResponse<byte[]> httpRes = client.send(req);

        String contentType = httpRes.headers().firstValue("Content-Type").orElse("application/octet-stream");

        org.openapis.openapi.models.operations.PostRealmClientsResponse res = new org.openapis.openapi.models.operations.PostRealmClientsResponse() {{
        }};
        res.statusCode = httpRes.statusCode();
        res.contentType = contentType;
        res.rawResponse = httpRes;
        
        if ((httpRes.statusCode() >= 200 && httpRes.statusCode() < 300)) {
        }

        return res;
    }

    /**
     * Generate a new secret for the client
     * @param request the request object containing all of the parameters for the API call
     * @return the response from the API call
     * @throws Exception if the API call fails
     */
    public org.openapis.openapi.models.operations.PostRealmClientsIdClientSecretResponse postRealmClientsIdClientSecret(org.openapis.openapi.models.operations.PostRealmClientsIdClientSecretRequest request) throws Exception {
        String baseUrl = this._serverUrl;
        String url = org.openapis.openapi.utils.Utils.generateURL(org.openapis.openapi.models.operations.PostRealmClientsIdClientSecretRequest.class, baseUrl, "/{realm}/clients/{id}/client-secret", request, null);
        
        HTTPRequest req = new HTTPRequest();
        req.setMethod("POST");
        req.setURL(url);
        
        
        HTTPClient client = this._securityClient;
        
        HttpResponse<byte[]> httpRes = client.send(req);

        String contentType = httpRes.headers().firstValue("Content-Type").orElse("application/octet-stream");

        org.openapis.openapi.models.operations.PostRealmClientsIdClientSecretResponse res = new org.openapis.openapi.models.operations.PostRealmClientsIdClientSecretResponse() {{
            credentialRepresentation = null;
        }};
        res.statusCode = httpRes.statusCode();
        res.contentType = contentType;
        res.rawResponse = httpRes;
        
        if ((httpRes.statusCode() >= 200 && httpRes.statusCode() < 300)) {
            if (org.openapis.openapi.utils.Utils.matchContentType(contentType, "application/json")) {
                ObjectMapper mapper = JSON.getMapper();
                org.openapis.openapi.models.shared.CredentialRepresentation out = mapper.readValue(new String(httpRes.body(), StandardCharsets.UTF_8), org.openapis.openapi.models.shared.CredentialRepresentation.class);
                res.credentialRepresentation = out;
            }
        }

        return res;
    }

    /**
     * Register a cluster node with the client   Manually register cluster node to this client - usually it\u2019s not needed to call this directly as adapter should handle  by sending registration request to Keycloak
     * @param request the request object containing all of the parameters for the API call
     * @return the response from the API call
     * @throws Exception if the API call fails
     */
    public org.openapis.openapi.models.operations.PostRealmClientsIdNodesResponse postRealmClientsIdNodes(org.openapis.openapi.models.operations.PostRealmClientsIdNodesRequest request) throws Exception {
        String baseUrl = this._serverUrl;
        String url = org.openapis.openapi.utils.Utils.generateURL(org.openapis.openapi.models.operations.PostRealmClientsIdNodesRequest.class, baseUrl, "/{realm}/clients/{id}/nodes", request, null);
        
        HTTPRequest req = new HTTPRequest();
        req.setMethod("POST");
        req.setURL(url);
        SerializedBody serializedRequestBody = org.openapis.openapi.utils.Utils.serializeRequestBody(request, "requestBody", "json");
        if (serializedRequestBody == null) {
            throw new Exception("Request body is required");
        }
        req.setBody(serializedRequestBody);
        
        
        HTTPClient client = this._securityClient;
        
        HttpResponse<byte[]> httpRes = client.send(req);

        String contentType = httpRes.headers().firstValue("Content-Type").orElse("application/octet-stream");

        org.openapis.openapi.models.operations.PostRealmClientsIdNodesResponse res = new org.openapis.openapi.models.operations.PostRealmClientsIdNodesResponse() {{
        }};
        res.statusCode = httpRes.statusCode();
        res.contentType = contentType;
        res.rawResponse = httpRes;
        
        if ((httpRes.statusCode() >= 200 && httpRes.statusCode() < 300)) {
        }

        return res;
    }

    /**
     * Push the client\u2019s revocation policy to its admin URL   If the client has an admin URL, push revocation policy to it.
     * @param request the request object containing all of the parameters for the API call
     * @return the response from the API call
     * @throws Exception if the API call fails
     */
    public org.openapis.openapi.models.operations.PostRealmClientsIdPushRevocationResponse postRealmClientsIdPushRevocation(org.openapis.openapi.models.operations.PostRealmClientsIdPushRevocationRequest request) throws Exception {
        String baseUrl = this._serverUrl;
        String url = org.openapis.openapi.utils.Utils.generateURL(org.openapis.openapi.models.operations.PostRealmClientsIdPushRevocationRequest.class, baseUrl, "/{realm}/clients/{id}/push-revocation", request, null);
        
        HTTPRequest req = new HTTPRequest();
        req.setMethod("POST");
        req.setURL(url);
        
        
        HTTPClient client = this._securityClient;
        
        HttpResponse<byte[]> httpRes = client.send(req);

        String contentType = httpRes.headers().firstValue("Content-Type").orElse("application/octet-stream");

        org.openapis.openapi.models.operations.PostRealmClientsIdPushRevocationResponse res = new org.openapis.openapi.models.operations.PostRealmClientsIdPushRevocationResponse() {{
            globalRequestResult = null;
        }};
        res.statusCode = httpRes.statusCode();
        res.contentType = contentType;
        res.rawResponse = httpRes;
        
        if ((httpRes.statusCode() >= 200 && httpRes.statusCode() < 300)) {
            if (org.openapis.openapi.utils.Utils.matchContentType(contentType, "application/json")) {
                ObjectMapper mapper = JSON.getMapper();
                org.openapis.openapi.models.shared.GlobalRequestResult out = mapper.readValue(new String(httpRes.body(), StandardCharsets.UTF_8), org.openapis.openapi.models.shared.GlobalRequestResult.class);
                res.globalRequestResult = out;
            }
        }

        return res;
    }

    /**
     * Generate a new registration access token for the client
     * @param request the request object containing all of the parameters for the API call
     * @return the response from the API call
     * @throws Exception if the API call fails
     */
    public org.openapis.openapi.models.operations.PostRealmClientsIdRegistrationAccessTokenResponse postRealmClientsIdRegistrationAccessToken(org.openapis.openapi.models.operations.PostRealmClientsIdRegistrationAccessTokenRequest request) throws Exception {
        String baseUrl = this._serverUrl;
        String url = org.openapis.openapi.utils.Utils.generateURL(org.openapis.openapi.models.operations.PostRealmClientsIdRegistrationAccessTokenRequest.class, baseUrl, "/{realm}/clients/{id}/registration-access-token", request, null);
        
        HTTPRequest req = new HTTPRequest();
        req.setMethod("POST");
        req.setURL(url);
        
        
        HTTPClient client = this._securityClient;
        
        HttpResponse<byte[]> httpRes = client.send(req);

        String contentType = httpRes.headers().firstValue("Content-Type").orElse("application/octet-stream");

        org.openapis.openapi.models.operations.PostRealmClientsIdRegistrationAccessTokenResponse res = new org.openapis.openapi.models.operations.PostRealmClientsIdRegistrationAccessTokenResponse() {{
            clientRepresentation = null;
        }};
        res.statusCode = httpRes.statusCode();
        res.contentType = contentType;
        res.rawResponse = httpRes;
        
        if ((httpRes.statusCode() >= 200 && httpRes.statusCode() < 300)) {
            if (org.openapis.openapi.utils.Utils.matchContentType(contentType, "application/json")) {
                ObjectMapper mapper = JSON.getMapper();
                org.openapis.openapi.models.shared.ClientRepresentation out = mapper.readValue(new String(httpRes.body(), StandardCharsets.UTF_8), org.openapis.openapi.models.shared.ClientRepresentation.class);
                res.clientRepresentation = out;
            }
        }

        return res;
    }

    /**
     * Update the client
     * @param request the request object containing all of the parameters for the API call
     * @return the response from the API call
     * @throws Exception if the API call fails
     */
    public org.openapis.openapi.models.operations.PutRealmClientsIdResponse putRealmClientsId(org.openapis.openapi.models.operations.PutRealmClientsIdRequest request) throws Exception {
        String baseUrl = this._serverUrl;
        String url = org.openapis.openapi.utils.Utils.generateURL(org.openapis.openapi.models.operations.PutRealmClientsIdRequest.class, baseUrl, "/{realm}/clients/{id}", request, null);
        
        HTTPRequest req = new HTTPRequest();
        req.setMethod("PUT");
        req.setURL(url);
        SerializedBody serializedRequestBody = org.openapis.openapi.utils.Utils.serializeRequestBody(request, "clientRepresentation", "json");
        if (serializedRequestBody == null) {
            throw new Exception("Request body is required");
        }
        req.setBody(serializedRequestBody);
        
        
        HTTPClient client = this._securityClient;
        
        HttpResponse<byte[]> httpRes = client.send(req);

        String contentType = httpRes.headers().firstValue("Content-Type").orElse("application/octet-stream");

        org.openapis.openapi.models.operations.PutRealmClientsIdResponse res = new org.openapis.openapi.models.operations.PutRealmClientsIdResponse() {{
        }};
        res.statusCode = httpRes.statusCode();
        res.contentType = contentType;
        res.rawResponse = httpRes;
        
        if ((httpRes.statusCode() >= 200 && httpRes.statusCode() < 300)) {
        }

        return res;
    }

    public org.openapis.openapi.models.operations.PutRealmClientsIdDefaultClientScopesClientScopeIdResponse putRealmClientsIdDefaultClientScopesClientScopeId(org.openapis.openapi.models.operations.PutRealmClientsIdDefaultClientScopesClientScopeIdRequest request) throws Exception {
        String baseUrl = this._serverUrl;
        String url = org.openapis.openapi.utils.Utils.generateURL(org.openapis.openapi.models.operations.PutRealmClientsIdDefaultClientScopesClientScopeIdRequest.class, baseUrl, "/{realm}/clients/{id}/default-client-scopes/{clientScopeId}", request, null);
        
        HTTPRequest req = new HTTPRequest();
        req.setMethod("PUT");
        req.setURL(url);
        
        
        HTTPClient client = this._securityClient;
        
        HttpResponse<byte[]> httpRes = client.send(req);

        String contentType = httpRes.headers().firstValue("Content-Type").orElse("application/octet-stream");

        org.openapis.openapi.models.operations.PutRealmClientsIdDefaultClientScopesClientScopeIdResponse res = new org.openapis.openapi.models.operations.PutRealmClientsIdDefaultClientScopesClientScopeIdResponse() {{
        }};
        res.statusCode = httpRes.statusCode();
        res.contentType = contentType;
        res.rawResponse = httpRes;
        
        if ((httpRes.statusCode() >= 200 && httpRes.statusCode() < 300)) {
        }

        return res;
    }

    /**
     * Return object stating whether client Authorization permissions have been initialized or not and a reference
     * @param request the request object containing all of the parameters for the API call
     * @return the response from the API call
     * @throws Exception if the API call fails
     */
    public org.openapis.openapi.models.operations.PutRealmClientsIdManagementPermissionsResponse putRealmClientsIdManagementPermissions(org.openapis.openapi.models.operations.PutRealmClientsIdManagementPermissionsRequest request) throws Exception {
        String baseUrl = this._serverUrl;
        String url = org.openapis.openapi.utils.Utils.generateURL(org.openapis.openapi.models.operations.PutRealmClientsIdManagementPermissionsRequest.class, baseUrl, "/{realm}/clients/{id}/management/permissions", request, null);
        
        HTTPRequest req = new HTTPRequest();
        req.setMethod("PUT");
        req.setURL(url);
        SerializedBody serializedRequestBody = org.openapis.openapi.utils.Utils.serializeRequestBody(request, "managementPermissionReference", "json");
        if (serializedRequestBody == null) {
            throw new Exception("Request body is required");
        }
        req.setBody(serializedRequestBody);
        
        
        HTTPClient client = this._securityClient;
        
        HttpResponse<byte[]> httpRes = client.send(req);

        String contentType = httpRes.headers().firstValue("Content-Type").orElse("application/octet-stream");

        org.openapis.openapi.models.operations.PutRealmClientsIdManagementPermissionsResponse res = new org.openapis.openapi.models.operations.PutRealmClientsIdManagementPermissionsResponse() {{
            managementPermissionReference = null;
        }};
        res.statusCode = httpRes.statusCode();
        res.contentType = contentType;
        res.rawResponse = httpRes;
        
        if ((httpRes.statusCode() >= 200 && httpRes.statusCode() < 300)) {
            if (org.openapis.openapi.utils.Utils.matchContentType(contentType, "application/json")) {
                ObjectMapper mapper = JSON.getMapper();
                org.openapis.openapi.models.shared.ManagementPermissionReference out = mapper.readValue(new String(httpRes.body(), StandardCharsets.UTF_8), org.openapis.openapi.models.shared.ManagementPermissionReference.class);
                res.managementPermissionReference = out;
            }
        }

        return res;
    }

    public org.openapis.openapi.models.operations.PutRealmClientsIdOptionalClientScopesClientScopeIdResponse putRealmClientsIdOptionalClientScopesClientScopeId(org.openapis.openapi.models.operations.PutRealmClientsIdOptionalClientScopesClientScopeIdRequest request) throws Exception {
        String baseUrl = this._serverUrl;
        String url = org.openapis.openapi.utils.Utils.generateURL(org.openapis.openapi.models.operations.PutRealmClientsIdOptionalClientScopesClientScopeIdRequest.class, baseUrl, "/{realm}/clients/{id}/optional-client-scopes/{clientScopeId}", request, null);
        
        HTTPRequest req = new HTTPRequest();
        req.setMethod("PUT");
        req.setURL(url);
        
        
        HTTPClient client = this._securityClient;
        
        HttpResponse<byte[]> httpRes = client.send(req);

        String contentType = httpRes.headers().firstValue("Content-Type").orElse("application/octet-stream");

        org.openapis.openapi.models.operations.PutRealmClientsIdOptionalClientScopesClientScopeIdResponse res = new org.openapis.openapi.models.operations.PutRealmClientsIdOptionalClientScopesClientScopeIdResponse() {{
        }};
        res.statusCode = httpRes.statusCode();
        res.contentType = contentType;
        res.rawResponse = httpRes;
        
        if ((httpRes.statusCode() >= 200 && httpRes.statusCode() < 300)) {
        }

        return res;
    }
}