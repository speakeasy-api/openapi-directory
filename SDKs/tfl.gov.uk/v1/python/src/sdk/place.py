"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Any, Optional

class Place:
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def place_get(self, request: operations.PlaceGetRequest) -> operations.PlaceGetResponse:
        r"""Gets the place with the given id."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PlaceGetRequest, base_url, '/Place/{id}', request)
        
        query_params = utils.get_query_params(operations.PlaceGetRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PlaceGetResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesPlace]])
                res.tfl_api_presentation_entities_places = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesPlace]])
                res.tfl_api_presentation_entities_places = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def place_get_at(self, request: operations.PlaceGetAtRequest) -> operations.PlaceGetAtResponse:
        r"""Gets any places of the given type whose geography intersects the given latitude and longitude. In practice this means the Place
                    must be polygonal e.g. a BoroughBoundary.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PlaceGetAtRequest, base_url, '/Place/{type}/At/{Lat}/{Lon}', request)
        
        query_params = utils.get_query_params(operations.PlaceGetAtRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PlaceGetAtResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.system_object = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.system_object = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def place_get_by_geo(self, request: operations.PlaceGetByGeoRequest) -> operations.PlaceGetByGeoResponse:
        r"""Gets the places that lie within a geographic region. The geographic region of interest can either be specified
                    by using a lat/lon geo-point and a radius in metres to return places within the locus defined by the lat/lon of
                    its centre or alternatively, by the use of a bounding box defined by the lat/lon of its north-west and south-east corners.
                    Optionally filters on type and can strip properties for a smaller payload.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/Place'
        
        query_params = utils.get_query_params(operations.PlaceGetByGeoRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PlaceGetByGeoResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesStopPoint]])
                res.tfl_api_presentation_entities_stop_points = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesStopPoint]])
                res.tfl_api_presentation_entities_stop_points = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def place_get_by_type(self, request: operations.PlaceGetByTypeRequest) -> operations.PlaceGetByTypeResponse:
        r"""Gets all places of a given type"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PlaceGetByTypeRequest, base_url, '/Place/Type/{types}', request)
        
        query_params = utils.get_query_params(operations.PlaceGetByTypeRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PlaceGetByTypeResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesPlace]])
                res.tfl_api_presentation_entities_places = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesPlace]])
                res.tfl_api_presentation_entities_places = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def place_get_overlay(self, request: operations.PlaceGetOverlayRequest) -> operations.PlaceGetOverlayResponse:
        r"""Gets the place overlay for a given set of co-ordinates and a given width/height."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PlaceGetOverlayRequest, base_url, '/Place/{type}/overlay/{z}/{Lat}/{Lon}/{width}/{height}', request)
        
        query_params = utils.get_query_params(operations.PlaceGetOverlayRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PlaceGetOverlayResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.system_object = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.system_object = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def place_get_streets_by_post_code(self, request: operations.PlaceGetStreetsByPostCodeRequest) -> operations.PlaceGetStreetsByPostCodeResponse:
        r"""Gets the set of streets associated with a post code."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PlaceGetStreetsByPostCodeRequest, base_url, '/Place/Address/Streets/{Postcode}', request)
        
        query_params = utils.get_query_params(operations.PlaceGetStreetsByPostCodeRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PlaceGetStreetsByPostCodeResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.system_object = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.system_object = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def place_meta_categories(self) -> operations.PlaceMetaCategoriesResponse:
        r"""Gets a list of all of the available place property categories and keys."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/Place/Meta/Categories'
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PlaceMetaCategoriesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesPlaceCategory]])
                res.tfl_api_presentation_entities_place_categories = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesPlaceCategory]])
                res.tfl_api_presentation_entities_place_categories = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def place_meta_place_types(self) -> operations.PlaceMetaPlaceTypesResponse:
        r"""Gets a list of the available types of Place."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/Place/Meta/PlaceTypes'
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PlaceMetaPlaceTypesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesPlaceCategory]])
                res.tfl_api_presentation_entities_place_categories = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesPlaceCategory]])
                res.tfl_api_presentation_entities_place_categories = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def place_search(self, request: operations.PlaceSearchRequest) -> operations.PlaceSearchResponse:
        r"""Gets all places that matches the given query"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/Place/Search'
        
        query_params = utils.get_query_params(operations.PlaceSearchRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PlaceSearchResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesPlace]])
                res.tfl_api_presentation_entities_places = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesPlace]])
                res.tfl_api_presentation_entities_places = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    