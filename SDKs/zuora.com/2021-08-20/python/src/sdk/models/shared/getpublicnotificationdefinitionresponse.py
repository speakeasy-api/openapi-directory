"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
import dateutil.parser
from ..shared import calloutauth as shared_calloutauth
from ..shared import filterruleparameterdefinition as shared_filterruleparameterdefinition
from dataclasses_json import Undefined, dataclass_json
from datetime import datetime
from enum import Enum
from marshmallow import fields
from sdk import utils
from typing import Optional

class GETPublicNotificationDefinitionResponseCalloutHTTPMethodEnum(str, Enum):
    r"""The HTTP method of the callout."""
    GET = 'GET'
    PUT = 'PUT'
    POST = 'POST'
    DELETE = 'DELETE'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GETPublicNotificationDefinitionResponseCallout:
    
    active: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('active'), 'exclude': lambda f: f is None }})
    r"""The status of the callout. The default is true."""  
    callout_auth: Optional[shared_calloutauth.CalloutAuth] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('calloutAuth'), 'exclude': lambda f: f is None }})
    r"""If requiredAuth is true, this object is required."""  
    callout_baseurl: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('calloutBaseurl'), 'exclude': lambda f: f is None }})
    r"""The callout URL. It must start with 'https://'"""  
    callout_params: Optional[dict[str, str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('calloutParams'), 'exclude': lambda f: f is None }})
    r"""A key-value map of merge fields of this callout."""  
    callout_retry: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('calloutRetry'), 'exclude': lambda f: f is None }})
    r"""Specified whether to retry the callout when the callout fails. The default is true."""  
    description: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('description'), 'exclude': lambda f: f is None }})
    r"""Description for the callout."""  
    event_type_name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('eventTypeName'), 'exclude': lambda f: f is None }})
    r"""The name of the event type."""  
    http_method: Optional[GETPublicNotificationDefinitionResponseCalloutHTTPMethodEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('httpMethod'), 'exclude': lambda f: f is None }})
    r"""The HTTP method of the callout."""  
    id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id'), 'exclude': lambda f: f is None }})
    r"""The ID of the callout. If `calloutActive` is true, a callout is required. The eventTypeName of the callout MUST be the same as the eventTypeName."""  
    name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name'), 'exclude': lambda f: f is None }})
    r"""The name of the created callout."""  
    required_auth: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('requiredAuth'), 'exclude': lambda f: f is None }})
    r"""Specifies whether the callout requires auth."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GETPublicNotificationDefinitionResponseFilterRule:
    
    condition: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('condition'), 'exclude': lambda f: f is None }})
    r"""The filter rule conditions, written in [JEXL](http://commons.apache.org/proper/commons-jexl/).
    The rule might contain event context merge fields and data source merge fields. Data source merge fields must be from [the base object of the event or from the joined objects of the base object](https://knowledgecenter.zuora.com/DC_Developers/M_Export_ZOQL#Data_Sources_and_Objects). Notifications with invalid merge fields will fail to evaluate, thus will not be invoked. For example, to trigger an event when an invoice is posted with the amount over 1000, you would define the following condition on the `Invoice` object:
    
    ```changeType == 'UPDATE' && Invoice.Status == 'Posted' && Invoice.Status_old != 'Posted' && Invoice.Amount > 1000```
    
    There are conventions and keywords you need to be aware of. For example:
    
    * `changeType` is a keyword to specify what kind of change happened to the object. Allowed values are `INSERT`, `UPDATE` or `DELETE`.
    
    * `Invoice.Status` refers to field `Status` of the Zuora object `Invoice`.
    
    * A variable with the `_old` suffix means itâ€™s a previous value of the corresponding object field. The \"_old\" fields are only available on the base objects.
    """  
    description: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('description'), 'exclude': lambda f: f is None }})
    r"""The description of the filter rule."""  
    event_type_name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('eventTypeName'), 'exclude': lambda f: f is None }})
    r"""The value is `null`."""  
    id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id'), 'exclude': lambda f: f is None }})
    r"""The ID of the filter rule. If not specified or null, the notification definition is always qualified to process events of \\"eventType\\"."""  
    parameters: Optional[dict[str, shared_filterruleparameterdefinition.FilterRuleParameterDefinition]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('parameters'), 'exclude': lambda f: f is None }})
    r"""The parameters of the filter rule and their name must match those in the filter rule. And all parameters must be defined in the event type payload. The name of parameters can't be duplicate. The following reserved keywords should not be used as a parameter name: `AttachmentList`, `RecipientList`, `RecipientType`, `Exceptions`, `OCP_OBJECT_TYPE`, `OCP_OBJECT_ID`, `OCP_TRIGGER_BY`"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GETPublicNotificationDefinitionResponse:
    r"""OK"""
    
    active: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('active'), 'exclude': lambda f: f is None }})
    r"""The status of the notification definition. The default value is true."""  
    callout: Optional[GETPublicNotificationDefinitionResponseCallout] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('callout'), 'exclude': lambda f: f is None }})  
    callout_active: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('calloutActive'), 'exclude': lambda f: f is None }})
    r"""The status of the callout action. The default value is false."""  
    communication_profile_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('communicationProfileId'), 'exclude': lambda f: f is None }})
    r"""The profile that the notification definition belongs to."""  
    created_by: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('createdBy'), 'exclude': lambda f: f is None }})
    r"""The ID of the user who created the notification definition."""  
    created_on: Optional[datetime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('createdOn'), 'encoder': utils.datetimeisoformat(True), 'decoder': dateutil.parser.isoparse, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""The time when the notification definition was created. Specified in the UTC timezone in the ISO860 format (YYYY-MM-DDThh:mm:ss.sTZD). E.g. 1997-07-16T19:20:30.45+00:00"""  
    description: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('description'), 'exclude': lambda f: f is None }})
    r"""Description of the notification definition"""  
    email_active: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('emailActive'), 'exclude': lambda f: f is None }})
    r"""The status of the email action. The default value is false."""  
    email_template_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('emailTemplateId'), 'exclude': lambda f: f is None }})
    r"""The ID of the email template. In the request, there should be at least one email template or callout."""  
    event_type_name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('eventTypeName'), 'exclude': lambda f: f is None }})
    r"""The name of the event type."""  
    event_type_namespace: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('eventTypeNamespace'), 'exclude': lambda f: f is None }})
    r"""The namespace of the `eventTypeName` field."""  
    filter_rule: Optional[GETPublicNotificationDefinitionResponseFilterRule] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('filterRule'), 'exclude': lambda f: f is None }})  
    filter_rule_params: Optional[dict[str, str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('filterRuleParams'), 'exclude': lambda f: f is None }})
    r"""The parameter values used to configure the filter rule."""  
    id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id'), 'exclude': lambda f: f is None }})
    r"""The filter rule associated with this notification definition."""  
    name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name'), 'exclude': lambda f: f is None }})
    r"""The name of the notification definition."""  
    updated_by: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('updatedBy'), 'exclude': lambda f: f is None }})
    r"""The ID of the user who updated the notification definition."""  
    updated_on: Optional[datetime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('updatedOn'), 'encoder': utils.datetimeisoformat(True), 'decoder': dateutil.parser.isoparse, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""The time when the notification was updated. Specified in the UTC timezone in the ISO860 format (YYYY-MM-DDThh:mm:ss.sTZD). E.g. 1997-07-16T19:20:30.45+00:00"""  
    