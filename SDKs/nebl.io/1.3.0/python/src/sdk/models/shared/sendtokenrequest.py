"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
from dataclasses_json import Undefined, dataclass_json
from sdk import utils
from typing import Optional


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class SendTokenRequestFlags:
    r"""Object representing flags that potentialy modify this transaction"""
    
    split_change: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('splitChange'), 'exclude': lambda f: f is None }})
    r"""If true change will be split into 2 outputs, one for NEBL change and one for NTP1 change (recommended)"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class SendTokenRequestMetadataEncryptions:
    
    format: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('format'), 'exclude': lambda f: f is None }})
    r"""key format (pem or der)"""  
    key: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('key'), 'exclude': lambda f: f is None }})
    r"""userData key to encrypt"""  
    pubkey: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('pubkey'), 'exclude': lambda f: f is None }})
    r"""RSA public key used for encryption"""  
    type: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type'), 'exclude': lambda f: f is None }})
    r"""pkcs1 or pkcs8"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class SendTokenRequestMetadataRulesExpiration:
    r"""Object describing expiration rules of the token"""
    
    locked: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('locked'), 'exclude': lambda f: f is None }})
    r"""Whether this rule can be modified in future transactions"""  
    valid_until: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('validUntil'), 'exclude': lambda f: f is None }})
    r"""Blockheight at wh"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class SendTokenRequestMetadataRulesFeesItems:
    
    address: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('address'), 'exclude': lambda f: f is None }})
    r"""Address fee is auto sent to"""  
    token_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('tokenId'), 'exclude': lambda f: f is None }})
    r"""How fee should be paid, either with a tokenId, or with NEBL if null"""  
    value: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('value'), 'exclude': lambda f: f is None }})
    r"""Amount of NTP1 token, or NEBL (in satoshi) to pay as fee"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class SendTokenRequestMetadataRulesFees:
    
    items: Optional[list[SendTokenRequestMetadataRulesFeesItems]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('items'), 'exclude': lambda f: f is None }})
    r"""Array of objects describing fee rules"""  
    locked: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('locked'), 'exclude': lambda f: f is None }})
    r"""Whether this rule can be modified in future transactions"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class SendTokenRequestMetadataRulesHolders:
    
    address: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('address'), 'exclude': lambda f: f is None }})
    r"""Address that can hold the token"""  
    locked: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('locked'), 'exclude': lambda f: f is None }})
    r"""Whether this rule can be modified in future transactions"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class SendTokenRequestMetadataRules:
    r"""Object describing token rules"""
    
    expiration: Optional[SendTokenRequestMetadataRulesExpiration] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('expiration'), 'exclude': lambda f: f is None }})
    r"""Object describing expiration rules of the token"""  
    fees: Optional[SendTokenRequestMetadataRulesFees] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('fees'), 'exclude': lambda f: f is None }})  
    holders: Optional[list[SendTokenRequestMetadataRulesHolders]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('holders'), 'exclude': lambda f: f is None }})
    r"""Array of objects describing what addresses can hold the token"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class SendTokenRequestMetadataUrls:
    
    data_hash: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('dataHash'), 'exclude': lambda f: f is None }})
    r"""Hash of data at the URL, used for verification"""  
    mime_type: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('mimeType'), 'exclude': lambda f: f is None }})
    r"""mimeType of URL content"""  
    name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name'), 'exclude': lambda f: f is None }})
    r"""Name of the URL"""  
    url: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('url'), 'exclude': lambda f: f is None }})
    r"""Actual URL"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class SendTokenRequestMetadataUserDataMeta:
    
    key: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('key'), 'exclude': lambda f: f is None }})  
    value: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('value'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class SendTokenRequestMetadataUserData:
    r"""Metadata set by user on token"""
    
    meta: Optional[list[SendTokenRequestMetadataUserDataMeta]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('meta'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class SendTokenRequestMetadata:
    r"""Object representing all metadata at token issuance"""
    
    description: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('description'), 'exclude': lambda f: f is None }})
    r"""Long name or description of token (ex. Nibble)"""  
    encryptions: Optional[list[SendTokenRequestMetadataEncryptions]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('encryptions'), 'exclude': lambda f: f is None }})
    r"""Array of encryption instruction objects for encrypting userData"""  
    issuer: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('issuer'), 'exclude': lambda f: f is None }})
    r"""Name of token issuer"""  
    rules: Optional[SendTokenRequestMetadataRules] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('rules'), 'exclude': lambda f: f is None }})
    r"""Object describing token rules"""  
    token_name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('tokenName'), 'exclude': lambda f: f is None }})
    r"""Token Symbol it will be identified by (ex. NIBBL)"""  
    urls: Optional[list[SendTokenRequestMetadataUrls]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('urls'), 'exclude': lambda f: f is None }})  
    user_data: Optional[SendTokenRequestMetadataUserData] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('userData'), 'exclude': lambda f: f is None }})
    r"""Metadata set by user on token"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class SendTokenRequestTo:
    
    address: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('address'), 'exclude': lambda f: f is None }})
    r"""Address to transfer tokens to"""  
    amount: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('amount'), 'exclude': lambda f: f is None }})
    r"""Number of tokens to send"""  
    token_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('tokenId'), 'exclude': lambda f: f is None }})
    r"""ID of token we are sending"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class SendTokenRequest:
    r"""Object representing the token to be sent"""
    
    fee: float = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('fee') }})
    r"""Fee in satoshi to include in the issuance transaction min 10000 (0.0001 NEBL)"""  
    to: list[SendTokenRequestTo] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('to') }})  
    flags: Optional[SendTokenRequestFlags] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('flags'), 'exclude': lambda f: f is None }})
    r"""Object representing flags that potentialy modify this transaction"""  
    from_: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('from'), 'exclude': lambda f: f is None }})
    r"""Array of addresses to send the token from"""  
    metadata: Optional[SendTokenRequestMetadata] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('metadata'), 'exclude': lambda f: f is None }})
    r"""Object representing all metadata at token issuance"""  
    sendutxo: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('sendutxo'), 'exclude': lambda f: f is None }})
    r"""Array of UTXOs to send the token from"""  
    