/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { SpeakeasyBase, SpeakeasyMetadata } from "../../../internal/utils";
import { DestinyDefinitionsAnimationsDestinyAnimationReference } from "./destinydefinitionsanimationsdestinyanimationreference";
import { DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition } from "./destinydefinitionscommondestinydisplaypropertiesdefinition";
import { DestinyDefinitionsDestinyGearArtArrangementReference } from "./destinydefinitionsdestinygearartarrangementreference";
import { DestinyDefinitionsDestinyInventoryItemStatDefinition } from "./destinydefinitionsdestinyinventoryitemstatdefinition";
import { DestinyDefinitionsDestinyItemActionRequiredItemDefinition } from "./destinydefinitionsdestinyitemactionrequireditemdefinition";
import { DestinyDefinitionsDestinyItemCraftingBlockBonusPlugDefinition } from "./destinydefinitionsdestinyitemcraftingblockbonusplugdefinition";
import { DestinyDefinitionsDestinyItemIntrinsicSocketEntryDefinition } from "./destinydefinitionsdestinyitemintrinsicsocketentrydefinition";
import { DestinyDefinitionsDestinyItemInvestmentStatDefinition } from "./destinydefinitionsdestinyiteminvestmentstatdefinition";
import { DestinyDefinitionsDestinyItemPerkEntryDefinition } from "./destinydefinitionsdestinyitemperkentrydefinition";
import { DestinyDefinitionsDestinyItemSetBlockEntryDefinition } from "./destinydefinitionsdestinyitemsetblockentrydefinition";
import { DestinyDefinitionsDestinyItemSocketCategoryDefinition } from "./destinydefinitionsdestinyitemsocketcategorydefinition";
import { DestinyDefinitionsDestinyItemSocketEntryDefinition } from "./destinydefinitionsdestinyitemsocketentrydefinition";
import { DestinyDefinitionsDestinyItemTooltipNotification } from "./destinydefinitionsdestinyitemtooltipnotification";
import { DestinyDefinitionsDestinyItemVendorSourceReference } from "./destinydefinitionsdestinyitemvendorsourcereference";
import { DestinyDefinitionsDestinyItemVersionDefinition } from "./destinydefinitionsdestinyitemversiondefinition";
import { DestinyDefinitionsDestinyObjectiveDisplayProperties } from "./destinydefinitionsdestinyobjectivedisplayproperties";
import { DestinyDefinitionsDestinyProgressionRewardDefinition } from "./destinydefinitionsdestinyprogressionrewarddefinition";
import { DestinyDefinitionsItemsDestinyDerivedItemCategoryDefinition } from "./destinydefinitionsitemsdestinyderiveditemcategorydefinition";
import { DestinyDefinitionsItemsDestinyPlugRuleDefinition } from "./destinydefinitionsitemsdestinyplugruledefinition";
import { DestinyDefinitionsSourcesDestinyItemSourceDefinition } from "./destinydefinitionssourcesdestinyitemsourcedefinition";
import { DestinyDestinyItemQuantity } from "./destinydestinyitemquantity";
import { DestinyDyeReference } from "./destinydyereference";
import { LinksHyperlinkReference } from "./linkshyperlinkreference";

/**
 * If an item can have an action performed on it (like "Dismantle"), it will be defined here if you care.
 */
export class DestinyDefinitionsDestinyInventoryItemDefinitionAction extends SpeakeasyBase {
  /**
   * The internal identifier for the action.
   */
  @SpeakeasyMetadata()
  actionTypeLabel?: string;

  /**
   * If true, the entire stack is deleted when the action completes.
   */
  @SpeakeasyMetadata()
  consumeEntireStack?: boolean;

  /**
   * If true, the item is deleted when the action completes.
   */
  @SpeakeasyMetadata()
  deleteOnAction?: boolean;

  /**
   * The content has this property, however it's not entirely clear how it is used.
   */
  @SpeakeasyMetadata()
  isPositive?: boolean;

  /**
   * The icon associated with the overlay screen for the action, if any.
   */
  @SpeakeasyMetadata()
  overlayIcon?: string;

  /**
   * If the action has an overlay screen associated with it, this is the name of that screen. Unfortunately, we cannot return the screen's data itself.
   */
  @SpeakeasyMetadata()
  overlayScreenName?: string;

  /**
   * If performing this action earns you Progression, this is the list of progressions and values granted for those progressions by performing this action.
   */
  @SpeakeasyMetadata({
    elemType: DestinyDefinitionsDestinyProgressionRewardDefinition,
  })
  progressionRewards?: DestinyDefinitionsDestinyProgressionRewardDefinition[];

  /**
   * The identifier hash for the Cooldown associated with this action. We have not pulled this data yet for you to have more data to use for cooldowns.
   */
  @SpeakeasyMetadata()
  requiredCooldownHash?: number;

  /**
   * The number of seconds to delay before allowing this action to be performed again.
   */
  @SpeakeasyMetadata()
  requiredCooldownSeconds?: number;

  /**
   * If the action requires other items to exist or be destroyed, this is the list of those items and requirements.
   */
  @SpeakeasyMetadata({
    elemType: DestinyDefinitionsDestinyItemActionRequiredItemDefinition,
  })
  requiredItems?: DestinyDefinitionsDestinyItemActionRequiredItemDefinition[];

  /**
   * Theoretically, an item could have a localized string for a hint about the location in which the action should be performed. In practice, no items yet have this property.
   */
  @SpeakeasyMetadata()
  requiredLocation?: string;

  /**
   * If true, this action will be performed as soon as you earn this item. Some rewards work this way, providing you a single item to pick up from a reward-granting vendor in-game and then immediately consuming itself to provide you multiple items.
   */
  @SpeakeasyMetadata()
  useOnAcquire?: boolean;

  /**
   * Localized text describing the action being performed.
   */
  @SpeakeasyMetadata()
  verbDescription?: string;

  /**
   * Localized text for the verb of the action being performed.
   */
  @SpeakeasyMetadata()
  verbName?: string;
}

/**
 * Represents a color whose RGBA values are all represented as values between 0 and 255.
 */
export class DestinyDefinitionsDestinyInventoryItemDefinitionBackgroundColor extends SpeakeasyBase {
  @SpeakeasyMetadata()
  alpha?: string;

  @SpeakeasyMetadata()
  blue?: string;

  @SpeakeasyMetadata()
  green?: string;

  @SpeakeasyMetadata()
  red?: string;
}

/**
 * If an item can have an action performed on it (like "Dismantle"), it will be defined here if you care.
 */
export class DestinyDefinitionsDestinyInventoryItemDefinitionCrafting extends SpeakeasyBase {
  /**
   * A reference to the base material requirements for crafting with this recipe.
   */
  @SpeakeasyMetadata()
  baseMaterialRequirements?: number;

  /**
   * A list of 'bonus' socket plugs that may be available if certain requirements are met.
   */
  @SpeakeasyMetadata({
    elemType: DestinyDefinitionsDestinyItemCraftingBlockBonusPlugDefinition,
  })
  bonusPlugs?: DestinyDefinitionsDestinyItemCraftingBlockBonusPlugDefinition[];

  @SpeakeasyMetadata()
  failedRequirementStrings?: string[];

  /**
   * A reference to the item definition that is created when crafting with this 'recipe' item.
   */
  @SpeakeasyMetadata()
  outputItemHash?: number;

  /**
   * A list of socket type hashes that describes which sockets are required for crafting with this recipe.
   */
  @SpeakeasyMetadata()
  requiredSocketTypeHashes?: number[];
}

/**
 * Items that can be equipped define this block. It contains information we need to understand how and when the item can be equipped.
 */
export class DestinyDefinitionsDestinyInventoryItemDefinitionEquippingBlock extends SpeakeasyBase {
  /**
   * Ammo type used by a weapon is no longer determined by the bucket in which it is contained. If the item has an ammo type - i.e. if it is a weapon - this will be the type of ammunition expected.
   */
  @SpeakeasyMetadata()
  ammoType?: number;

  /**
   * These are custom attributes on the equippability of the item.
   *
   * @remarks
   * For now, this can only be "equip on acquire", which would mean that the item will be automatically equipped as soon as you pick it up.
   */
  @SpeakeasyMetadata()
  attributes?: number;

  /**
   * These are strings that represent the possible Game/Account/Character state failure conditions that can occur when trying to equip the item. They match up one-to-one with requiredUnlockExpressions.
   */
  @SpeakeasyMetadata()
  displayStrings?: string[];

  /**
   * An equipped item *must* be equipped in an Equipment Slot. This is the hash identifier of the DestinyEquipmentSlotDefinition into which it must be equipped.
   */
  @SpeakeasyMetadata()
  equipmentSlotTypeHash?: number;

  /**
   * If the item is part of a gearset, this is a reference to that gearset item.
   */
  @SpeakeasyMetadata()
  gearsetItemHash?: number;

  /**
   * If defined, this is the label used to check if the item has other items of matching types already equipped.
   *
   * @remarks
   * For instance, when you aren't allowed to equip more than one Exotic Weapon, that's because all exotic weapons have identical uniqueLabels and the game checks the to-be-equipped item's uniqueLabel vs. all other already equipped items (other than the item in the slot that's about to be occupied).
   */
  @SpeakeasyMetadata()
  uniqueLabel?: string;

  /**
   * The hash of that unique label. Does not point to a specific definition.
   */
  @SpeakeasyMetadata()
  uniqueLabelHash?: number;
}

/**
 * If an item has a related gearset, this is the list of items in that set, and an unlock expression that evaluates to a number representing the progress toward gearset completion (a very rare use for unlock expressions!)
 */
export class DestinyDefinitionsDestinyInventoryItemDefinitionGearset extends SpeakeasyBase {
  /**
   * The list of hashes for items in the gearset. Use them to look up DestinyInventoryItemDefinition entries for the items in the set.
   */
  @SpeakeasyMetadata()
  itemList?: number[];

  /**
   * The maximum possible number of items that can be collected.
   */
  @SpeakeasyMetadata()
  trackingValueMax?: number;
}

/**
 * If the item can exist in an inventory - the overwhelming majority of them can and do - then this is the basic properties regarding the item's relationship with the inventory.
 */
export class DestinyDefinitionsDestinyInventoryItemDefinitionInventory extends SpeakeasyBase {
  /**
   * The hash identifier for the DestinyInventoryBucketDefinition to which this item belongs. I should have named this "bucketHash", but too many things refer to it now. Sigh.
   */
  @SpeakeasyMetadata()
  bucketTypeHash?: number;

  /**
   * The tooltip message to show, if any, when the item expires.
   */
  @SpeakeasyMetadata()
  expirationTooltip?: string;

  /**
   * If the item expires while playing in an activity, we show a different message.
   */
  @SpeakeasyMetadata()
  expiredInActivityMessage?: string;

  /**
   * If the item expires in orbit, we show a... more different message. ("Consummate V's, consummate!")
   */
  @SpeakeasyMetadata()
  expiredInOrbitMessage?: string;

  /**
   * If TRUE, this item is instanced. Otherwise, it is a generic item that merely has a quantity in a stack (like Glimmer).
   */
  @SpeakeasyMetadata()
  isInstanceItem?: boolean;

  /**
   * The maximum quantity of this item that can exist in a stack.
   */
  @SpeakeasyMetadata()
  maxStackSize?: number;

  /**
   * A reference to the associated crafting 'recipe' item definition, if this item can be crafted.
   */
  @SpeakeasyMetadata()
  recipeItemHash?: number;

  /**
   * If the item is picked up by the lost loot queue, this is the hash identifier for the DestinyInventoryBucketDefinition into which it will be placed. Again, I should have named this recoveryBucketHash instead.
   */
  @SpeakeasyMetadata()
  recoveryBucketTypeHash?: number;

  /**
   * If this string is populated, you can't have more than one stack with this label in a given inventory. Note that this is different from the equipping block's unique label, which is used for equipping uniqueness.
   */
  @SpeakeasyMetadata()
  stackUniqueLabel?: string;

  @SpeakeasyMetadata()
  suppressExpirationWhenObjectivesComplete?: boolean;

  /**
   * The enumeration matching the tier type of the item to known values, again for convenience sake.
   */
  @SpeakeasyMetadata()
  tierType?: number;

  /**
   * The hash identifier for the Tier Type of the item, use to look up its DestinyItemTierTypeDefinition if you need to show localized data for the item's tier.
   */
  @SpeakeasyMetadata()
  tierTypeHash?: number;

  /**
   * The localized name of the tier type, which is a useful shortcut so you don't have to look up the definition every time. However, it's mostly a holdover from days before we had a DestinyItemTierTypeDefinition to refer to.
   */
  @SpeakeasyMetadata()
  tierTypeName?: string;
}

/**
 * The metrics available for display and selection on an item.
 */
export class DestinyDefinitionsDestinyInventoryItemDefinitionMetrics extends SpeakeasyBase {
  /**
   * Hash identifiers for any DestinyPresentationNodeDefinition entry that can be used to list available metrics. Any metric listed directly below these nodes, or in any of these nodes' children will be made available for selection.
   */
  @SpeakeasyMetadata()
  availableMetricCategoryNodeHashes?: number[];
}

/**
 * An item can have objectives on it. In practice, these are the exclusive purview of "Quest Step" items: DestinyInventoryItemDefinitions that represent a specific step in a Quest.
 *
 * @remarks
 * Quest steps have 1:M objectives that we end up processing and returning in live data as DestinyQuestStatus data, and other useful information.
 */
export class DestinyDefinitionsDestinyInventoryItemDefinitionObjectives extends SpeakeasyBase {
  /**
   * For every entry in objectiveHashes, there is a corresponding entry in this array at the same index. If the objective is meant to be associated with a specific DestinyActivityDefinition, there will be a valid hash at that index. Otherwise, it will be invalid (0).
   *
   * @remarks
   * Rendered somewhat obsolete by perObjectiveDisplayProperties, which currently has much the same information but may end up with more info in the future.
   */
  @SpeakeasyMetadata()
  displayActivityHashes?: number[];

  @SpeakeasyMetadata()
  displayAsStatTracker?: boolean;

  /**
   * The localized string for narrative text related to this quest step, if any.
   */
  @SpeakeasyMetadata()
  narrative?: string;

  /**
   * The hashes to Objectives (DestinyObjectiveDefinition) that are part of this Quest Step, in the order that they should be rendered.
   */
  @SpeakeasyMetadata()
  objectiveHashes?: number[];

  /**
   * The localized string describing an action to be performed associated with the objectives, if any.
   */
  @SpeakeasyMetadata()
  objectiveVerbName?: string;

  /**
   * One entry per Objective on the item, it will have related display information.
   */
  @SpeakeasyMetadata({
    elemType: DestinyDefinitionsDestinyObjectiveDisplayProperties,
  })
  perObjectiveDisplayProperties?: DestinyDefinitionsDestinyObjectiveDisplayProperties[];

  /**
   * A hashed value for the questTypeIdentifier, because apparently I like to be redundant.
   */
  @SpeakeasyMetadata()
  questTypeHash?: number;

  /**
   * The identifier for the type of quest being performed, if any. Not associated with any fixed definition, yet.
   */
  @SpeakeasyMetadata()
  questTypeIdentifier?: string;

  /**
   * The hash for the DestinyInventoryItemDefinition representing the Quest to which this Quest Step belongs.
   */
  @SpeakeasyMetadata()
  questlineItemHash?: number;

  /**
   * If True, all objectives must be completed for the step to be completed. If False, any one objective can be completed for the step to be completed.
   */
  @SpeakeasyMetadata()
  requireFullObjectiveCompletion?: boolean;
}

/**
 * Items can have Energy Capacity, and plugs can provide that capacity such as on a piece of Armor in Armor 2.0. This is how much "Energy" can be spent on activating plugs for this item.
 */
export class DestinyDefinitionsDestinyInventoryItemDefinitionPlugEnergyCapacity extends SpeakeasyBase {
  /**
   * How much energy capacity this plug provides.
   */
  @SpeakeasyMetadata()
  capacityValue?: number;

  /**
   * The Energy Type for this energy capacity, in enum form for easy use.
   */
  @SpeakeasyMetadata()
  energyType?: number;

  /**
   * Energy provided by a plug is always of a specific type - this is the hash identifier for the energy type for which it provides Capacity.
   */
  @SpeakeasyMetadata()
  energyTypeHash?: number;
}

/**
 * Some plugs cost Energy, which is a stat on the item that can be increased by other plugs (that, at least in Armor 2.0, have a "masterworks-like" mechanic for upgrading). If a plug has costs, the details of that cost are defined here.
 */
export class DestinyDefinitionsDestinyInventoryItemDefinitionPlugEnergyCost extends SpeakeasyBase {
  /**
   * The Energy cost for inserting this plug.
   */
  @SpeakeasyMetadata()
  energyCost?: number;

  /**
   * The type of energy that this plug costs, in enum form.
   */
  @SpeakeasyMetadata()
  energyType?: number;

  /**
   * The type of energy that this plug costs, as a reference to the DestinyEnergyTypeDefinition of the energy type.
   */
  @SpeakeasyMetadata()
  energyTypeHash?: number;
}

/**
 * Do you ever get the feeling that a system has become so overburdened by edge cases that it probably should have become some other system entirely? So do I!
 *
 * @remarks
 * In totally unrelated news, Plugs can now override properties of their parent items. This is some of the relevant definition data for those overrides.
 * If this is populated, it will have the override data to be applied when this plug is applied to an item.
 */
export class DestinyDefinitionsDestinyInventoryItemDefinitionPlugParentItemOverride extends SpeakeasyBase {
  @SpeakeasyMetadata()
  additionalEquipRequirementsDisplayStrings?: string[];

  @SpeakeasyMetadata()
  pipIcon?: string;
}

/**
 * If an item is a Plug, its DestinyInventoryItemDefinition.plug property will be populated with an instance of one of these bad boys.
 *
 * @remarks
 * This gives information about when it can be inserted, what the plug's category is (and thus whether it is compatible with a socket... see DestinySocketTypeDefinition for information about Plug Categories and socket compatibility), whether it is enabled and other Plug info.
 */
export class DestinyDefinitionsDestinyInventoryItemDefinitionPlug extends SpeakeasyBase {
  /**
   * The alternate plug of the plug: only applies when the item is in states that only the server can know about and control, unfortunately. See AlternateUiPlugLabel for the related label info.
   */
  @SpeakeasyMetadata()
  alternatePlugStyle?: number;

  /**
   * If the plug meets certain state requirements, it may have an alternative label applied to it. This is the alternative label that will be applied in such a situation.
   */
  @SpeakeasyMetadata()
  alternateUiPlugLabel?: string;

  /**
   * It's not enough for the plug to be inserted. It has to be enabled as well. For it to be enabled, it may require materials. This is the hash identifier for the DestinyMaterialRequirementSetDefinition for those requirements, if there is one.
   */
  @SpeakeasyMetadata()
  enabledMaterialRequirementHash?: number;

  /**
   * The rules around whether the plug, once inserted, is enabled and providing its benefits.
   *
   * @remarks
   * The live data DestinyItemPlugComponent.enableFailIndexes will be an index into this array, so you can pull out the failure strings appropriate for the user.
   */
  @SpeakeasyMetadata({
    elemType: DestinyDefinitionsItemsDestinyPlugRuleDefinition,
  })
  enabledRules?: DestinyDefinitionsItemsDestinyPlugRuleDefinition[];

  /**
   * IF not null, this plug provides Energy capacity to the item in which it is socketed. In Armor 2.0 for example, is implemented in a similar way to Masterworks, where visually it's a single area of the UI being clicked on to "Upgrade" to higher energy levels, but it's actually socketing new plugs.
   */
  @SpeakeasyMetadata()
  energyCapacity?: DestinyDefinitionsDestinyInventoryItemDefinitionPlugEnergyCapacity;

  /**
   * IF not null, this plug has an energy cost. This contains the details of that cost.
   */
  @SpeakeasyMetadata()
  energyCost?: DestinyDefinitionsDestinyInventoryItemDefinitionPlugEnergyCost;

  /**
   * If inserting this plug requires materials, this is the hash identifier for looking up the DestinyMaterialRequirementSetDefinition for those requirements.
   */
  @SpeakeasyMetadata()
  insertionMaterialRequirementHash?: number;

  /**
   * The rules around when this plug can be inserted into a socket, aside from the socket's individual restrictions.
   *
   * @remarks
   * The live data DestinyItemPlugComponent.insertFailIndexes will be an index into this array, so you can pull out the failure strings appropriate for the user.
   */
  @SpeakeasyMetadata({
    elemType: DestinyDefinitionsItemsDestinyPlugRuleDefinition,
  })
  insertionRules?: DestinyDefinitionsItemsDestinyPlugRuleDefinition[];

  /**
   * If TRUE, this plug is used for UI display purposes only, and doesn't have any interesting effects of its own.
   */
  @SpeakeasyMetadata()
  isDummyPlug?: boolean;

  /**
   * If you successfully socket the item, this will determine whether or not you get "refunded" on the plug.
   */
  @SpeakeasyMetadata()
  onActionRecreateSelf?: boolean;

  /**
   * Do you ever get the feeling that a system has become so overburdened by edge cases that it probably should have become some other system entirely? So do I!
   *
   * @remarks
   * In totally unrelated news, Plugs can now override properties of their parent items. This is some of the relevant definition data for those overrides.
   * If this is populated, it will have the override data to be applied when this plug is applied to an item.
   */
  @SpeakeasyMetadata()
  parentItemOverride?: DestinyDefinitionsDestinyInventoryItemDefinitionPlugParentItemOverride;

  /**
   * Indicates the rules about when this plug can be used. See the PlugAvailabilityMode enumeration for more information!
   */
  @SpeakeasyMetadata()
  plugAvailability?: number;

  /**
   * The hash for the plugCategoryIdentifier. You can use this instead if you wish: I put both in the definition for debugging purposes.
   */
  @SpeakeasyMetadata()
  plugCategoryHash?: number;

  /**
   * The string identifier for the plug's category. Use the socket's DestinySocketTypeDefinition.plugWhitelist to determine whether this plug can be inserted into the socket.
   */
  @SpeakeasyMetadata()
  plugCategoryIdentifier?: string;

  @SpeakeasyMetadata()
  plugStyle?: number;

  /**
   * In the game, if you're inspecting a plug item directly, this will be the item shown with the plug attached. Look up the DestinyInventoryItemDefinition for this hash for the item.
   */
  @SpeakeasyMetadata()
  previewItemOverrideHash?: number;

  /**
   * Plugs can have arbitrary, UI-defined identifiers that the UI designers use to determine the style applied to plugs. Unfortunately, we have neither a definitive list of these labels nor advance warning of when new labels might be applied or how that relates to how they get rendered. If you want to, you can refer to known labels to change your own styles: but know that new ones can be created arbitrarily, and we have no way of associating the labels with any specific UI style guidance... you'll have to piece that together on your end. Or do what we do, and just show plugs more generically, without specialized styles.
   */
  @SpeakeasyMetadata()
  uiPlugLabel?: string;
}

/**
 * Items like Sacks or Boxes can have items that it shows in-game when you view details that represent the items you can obtain if you use or acquire the item.
 *
 * @remarks
 * This defines those categories, and gives some insights into that data's source.
 */
export class DestinyDefinitionsDestinyInventoryItemDefinitionPreview extends SpeakeasyBase {
  /**
   * If this item should show you Artifact information when you preview it, this is the hash identifier of the DestinyArtifactDefinition for the artifact whose data should be shown.
   */
  @SpeakeasyMetadata()
  artifactHash?: number;

  /**
   * This is a list of the items being previewed, categorized in the same way as they are in the preview UI.
   */
  @SpeakeasyMetadata({
    elemType: DestinyDefinitionsItemsDestinyDerivedItemCategoryDefinition,
  })
  derivedItemCategories?: DestinyDefinitionsItemsDestinyDerivedItemCategoryDefinition[];

  /**
   * If the preview has an associated action (like "Open"), this will be the localized string for that action.
   */
  @SpeakeasyMetadata()
  previewActionString?: string;

  /**
   * If the preview data is derived from a fake "Preview" Vendor, this will be the hash identifier for the DestinyVendorDefinition of that fake vendor.
   */
  @SpeakeasyMetadata()
  previewVendorHash?: number;

  /**
   * A string that the game UI uses as a hint for which detail screen to show for the item. You, too, can leverage this for your own custom screen detail views. Note, however, that these are arbitrarily defined by designers: there's no guarantees of a fixed, known number of these - so fall back to something reasonable if you don't recognize it.
   */
  @SpeakeasyMetadata()
  screenStyle?: string;
}

/**
 * An item's "Quality" determines its calculated stats. The Level at which the item spawns is combined with its "qualityLevel" along with some additional calculations to determine the value of those stats.
 *
 * @remarks
 * In Destiny 2, most items don't have default item levels and quality, making this property less useful: these apparently are almost always determined by the complex mechanisms of the Reward system rather than statically. They are still provided here in case they are still useful for people. This also contains some information about Infusion.
 */
export class DestinyDefinitionsDestinyInventoryItemDefinitionQuality extends SpeakeasyBase {
  /**
   * The latest version available for this item.
   */
  @SpeakeasyMetadata()
  currentVersion?: number;

  /**
   * Icon overlays to denote the item version and power cap status.
   */
  @SpeakeasyMetadata()
  displayVersionWatermarkIcons?: string[];

  /**
   * The hash identifier for the infusion. It does not map to a Definition entity.
   *
   * @remarks
   * DEPRECATED: Items can now have multiple infusion categories. Please use infusionCategoryHashes instead.
   */
  @SpeakeasyMetadata()
  infusionCategoryHash?: number;

  /**
   * If any one of these hashes matches any value in another item's infusionCategoryHashes, the two can infuse with each other.
   */
  @SpeakeasyMetadata()
  infusionCategoryHashes?: number[];

  /**
   * The string identifier for this item's "infusability", if any.
   *
   * @remarks
   * Items that match the same infusionCategoryName are allowed to infuse with each other.
   * DEPRECATED: Items can now have multiple infusion categories. Please use infusionCategoryHashes instead.
   */
  @SpeakeasyMetadata()
  infusionCategoryName?: string;

  /**
   * The "base" defined level of an item. This is a list because, in theory, each Expansion could define its own base level for an item.
   *
   * @remarks
   * In practice, not only was that never done in Destiny 1, but now this isn't even populated at all. When it's not populated, the level at which it spawns has to be inferred by Reward information, of which BNet receives an imperfect view and will only be reliable on instanced data as a result.
   */
  @SpeakeasyMetadata()
  itemLevels?: number[];

  /**
   * An item can refer to pre-set level requirements. They are defined in DestinyProgressionLevelRequirementDefinition, and you can use this hash to find the appropriate definition.
   */
  @SpeakeasyMetadata()
  progressionLevelRequirementHash?: number;

  /**
   * qualityLevel is used in combination with the item's level to calculate stats like Attack and Defense. It plays a role in that calculation, but not nearly as large as itemLevel does.
   */
  @SpeakeasyMetadata()
  qualityLevel?: number;

  /**
   * The list of versions available for this item.
   */
  @SpeakeasyMetadata({
    elemType: DestinyDefinitionsDestinyItemVersionDefinition,
  })
  versions?: DestinyDefinitionsDestinyItemVersionDefinition[];
}

/**
 * Some items are "sacks" - they can be "opened" to produce other items. This is information related to its sack status, mostly UI strings. Engrams are an example of items that are considered to be "Sacks".
 */
export class DestinyDefinitionsDestinyInventoryItemDefinitionSack extends SpeakeasyBase {
  /**
   * A description of what will happen when you open the sack. As far as I can tell, this is blank currently. Unknown whether it will eventually be populated with useful info.
   */
  @SpeakeasyMetadata()
  detailAction?: string;

  /**
   * The localized name of the action being performed when you open the sack.
   */
  @SpeakeasyMetadata()
  openAction?: string;

  @SpeakeasyMetadata()
  openOnAcquire?: boolean;

  @SpeakeasyMetadata()
  selectItemCount?: number;

  @SpeakeasyMetadata()
  vendorSackType?: string;
}

/**
 * Primarily for Quests, this is the definition of properties related to the item if it is a quest and its various quest steps.
 */
export class DestinyDefinitionsDestinyInventoryItemDefinitionSetData extends SpeakeasyBase {
  /**
   * A collection of hashes of set items, for items such as Quest Metadata items that possess this data.
   */
  @SpeakeasyMetadata({
    elemType: DestinyDefinitionsDestinyItemSetBlockEntryDefinition,
  })
  itemList?: DestinyDefinitionsDestinyItemSetBlockEntryDefinition[];

  /**
   * The description of the quest line that this quest step is a part of.
   */
  @SpeakeasyMetadata()
  questLineDescription?: string;

  /**
   * The name of the quest line that this quest step is a part of.
   */
  @SpeakeasyMetadata()
  questLineName?: string;

  /**
   * An additional summary of this step in the quest line.
   */
  @SpeakeasyMetadata()
  questStepSummary?: string;

  /**
   * If true, items in the set can only be added in increasing order, and adding an item will remove any previous item. For Quests, this is by necessity true. Only one quest step is present at a time, and previous steps are removed as you advance in the quest.
   */
  @SpeakeasyMetadata()
  requireOrderedSetItemAdd?: boolean;

  /**
   * If true, the UI should treat this quest as "featured"
   */
  @SpeakeasyMetadata()
  setIsFeatured?: boolean;

  /**
   * A string identifier we can use to attempt to identify the category of the Quest.
   */
  @SpeakeasyMetadata()
  setType?: string;
}

/**
 * If defined, the item has at least one socket.
 */
export class DestinyDefinitionsDestinyInventoryItemDefinitionSockets extends SpeakeasyBase {
  /**
   * This was supposed to be a string that would give per-item details about sockets. In practice, it turns out that all this ever has is the localized word "details". ... that's lame, but perhaps it will become something cool in the future.
   */
  @SpeakeasyMetadata()
  detail?: string;

  /**
   * Each intrinsic (or immutable/permanent) socket on an item is defined here, along with the plug that is permanently affixed to the socket.
   */
  @SpeakeasyMetadata({
    elemType: DestinyDefinitionsDestinyItemIntrinsicSocketEntryDefinition,
  })
  intrinsicSockets?: DestinyDefinitionsDestinyItemIntrinsicSocketEntryDefinition[];

  /**
   * A convenience property, that refers to the sockets in the "sockets" property, pre-grouped by category and ordered in the manner that they should be grouped in the UI. You could form this yourself with the existing data, but why would you want to? Enjoy life man.
   */
  @SpeakeasyMetadata({
    elemType: DestinyDefinitionsDestinyItemSocketCategoryDefinition,
  })
  socketCategories?: DestinyDefinitionsDestinyItemSocketCategoryDefinition[];

  /**
   * Each non-intrinsic (or mutable) socket on an item is defined here. Check inside for more info.
   */
  @SpeakeasyMetadata({
    elemType: DestinyDefinitionsDestinyItemSocketEntryDefinition,
  })
  socketEntries?: DestinyDefinitionsDestinyItemSocketEntryDefinition[];
}

/**
 * Data about an item's "sources": ways that the item can be obtained.
 */
export class DestinyDefinitionsDestinyInventoryItemDefinitionSourceData extends SpeakeasyBase {
  /**
   * If we found that this item is exclusive to a specific platform, this will be set to the BungieMembershipType enumeration that matches that platform.
   */
  @SpeakeasyMetadata()
  exclusive?: number;

  /**
   * The list of hash identifiers for Reward Sources that hint where the item can be found (DestinyRewardSourceDefinition).
   */
  @SpeakeasyMetadata()
  sourceHashes?: number[];

  /**
   * A collection of details about the stats that were computed for the ways we found that the item could be spawned.
   */
  @SpeakeasyMetadata({
    elemType: DestinyDefinitionsSourcesDestinyItemSourceDefinition,
  })
  sources?: DestinyDefinitionsSourcesDestinyItemSourceDefinition[];

  /**
   * A denormalized reference back to vendors that potentially sell this item.
   */
  @SpeakeasyMetadata({
    elemType: DestinyDefinitionsDestinyItemVendorSourceReference,
  })
  vendorSources?: DestinyDefinitionsDestinyItemVendorSourceReference[];
}

/**
 * Information about the item's calculated stats, with as much data as we can find for the stats without having an actual instance of the item.
 *
 * @remarks
 * Note that this means the entire concept of providing these stats is fundamentally insufficient: we cannot predict with 100% accuracy the conditions under which an item can spawn, so we use various heuristics to attempt to simulate the conditions as accurately as possible. Actual stats for items in-game can and will vary, but these should at least be useful base points for comparison and display.
 * It is also worth noting that some stats, like Magazine size, have further calculations performed on them by scripts in-game and on the game servers that BNet does not have access to. We cannot know how those stats are further transformed, and thus some stats will be inaccurate even on instances of items in BNet vs. how they appear in-game. This is a known limitation of our item statistics, without any planned fix.
 */
export class DestinyDefinitionsDestinyInventoryItemDefinitionStats extends SpeakeasyBase {
  /**
   * If true, the game won't show the "primary" stat on this item when you inspect it.
   *
   * @remarks
   * NOTE: This is being manually mapped, because I happen to want it in a block that isn't going to directly create this derivative block.
   */
  @SpeakeasyMetadata()
  disablePrimaryStatDisplay?: boolean;

  /**
   * A quick and lazy way to determine whether any stat other than the "primary" stat is actually visible on the item. Items often have stats that we return in case people find them useful, but they're not part of the "Stat Group" and thus we wouldn't display them in our UI. If this is False, then we're not going to display any of these stats other than the primary one.
   */
  @SpeakeasyMetadata()
  hasDisplayableStats?: boolean;

  /**
   * This stat is determined to be the "primary" stat, and can be looked up in the stats or any other stat collection related to the item.
   *
   * @remarks
   * Use this hash to look up the stat's value using DestinyInventoryItemDefinition.stats.stats, and the renderable data for the primary stat in the related DestinyStatDefinition.
   */
  @SpeakeasyMetadata()
  primaryBaseStatHash?: number;

  /**
   * If the item's stats are meant to be modified by a DestinyStatGroupDefinition, this will be the identifier for that definition.
   *
   * @remarks
   * If you are using live data or precomputed stats data on the DestinyInventoryItemDefinition.stats.stats property, you don't have to worry about statGroupHash and how it alters stats: the already altered stats are provided to you. But if you want to see how the sausage gets made, or perform computations yourself, this is valuable information.
   */
  @SpeakeasyMetadata()
  statGroupHash?: number;

  /**
   * If you are looking for precomputed values for the stats on a weapon, this is where they are stored. Technically these are the "Display" stat values. Please see DestinyStatsDefinition for what Display Stat Values means, it's a very long story... but essentially these are the closest values BNet can get to the item stats that you see in-game.
   *
   * @remarks
   * These stats are keyed by the DestinyStatDefinition's hash identifier for the stat that's found on the item.
   */
  @SpeakeasyMetadata({
    elemType: DestinyDefinitionsDestinyInventoryItemStatDefinition,
  })
  stats?: Record<string, DestinyDefinitionsDestinyInventoryItemStatDefinition>;
}

/**
 * This appears to be information used when rendering rewards. We don't currently use it on BNet.
 */
export class DestinyDefinitionsDestinyInventoryItemDefinitionSummary extends SpeakeasyBase {
  /**
   * Apparently when rendering an item in a reward, this should be used as a sort priority. We're not doing it presently.
   */
  @SpeakeasyMetadata()
  sortPriority?: number;
}

/**
 * This defines information that can only come from a talent grid on an item. Items mostly have negligible talent grid data these days, but instanced items still retain grids as a source for some of this common information.
 *
 * @remarks
 * Builds/Subclasses are the only items left that still have talent grids with meaningful Nodes.
 */
export class DestinyDefinitionsDestinyInventoryItemDefinitionTalentGrid extends SpeakeasyBase {
  /**
   * A shortcut string identifier for the "build" in question, if this talent grid has an associated build. Doesn't map to anything we can expose at the moment.
   */
  @SpeakeasyMetadata()
  buildName?: string;

  /**
   * If the talent grid implies a damage type, this is the enum value for that damage type.
   */
  @SpeakeasyMetadata()
  hudDamageType?: number;

  /**
   * If the talent grid has a special icon that's shown in the game UI (like builds, funny that), this is the identifier for that icon. Sadly, we don't actually get that icon right now. I'll be looking to replace this with a path to the actual icon itself.
   */
  @SpeakeasyMetadata()
  hudIcon?: string;

  /**
   * This is meant to be a subtitle for looking at the talent grid. In practice, somewhat frustratingly, this always merely says the localized word for "Details". Great. Maybe it'll have more if talent grids ever get used for more than builds and subclasses again.
   */
  @SpeakeasyMetadata()
  itemDetailString?: string;

  /**
   * The hash identifier of the DestinyTalentGridDefinition attached to this item.
   */
  @SpeakeasyMetadata()
  talentGridHash?: number;
}

/**
 * This Block defines the rendering data associated with the item, if any.
 */
export class DestinyDefinitionsDestinyInventoryItemDefinitionTranslationBlock extends SpeakeasyBase {
  @SpeakeasyMetadata({
    elemType: DestinyDefinitionsDestinyGearArtArrangementReference,
  })
  arrangements?: DestinyDefinitionsDestinyGearArtArrangementReference[];

  @SpeakeasyMetadata({ elemType: DestinyDyeReference })
  customDyes?: DestinyDyeReference[];

  @SpeakeasyMetadata({ elemType: DestinyDyeReference })
  defaultDyes?: DestinyDyeReference[];

  @SpeakeasyMetadata()
  hasGeometry?: boolean;

  @SpeakeasyMetadata({ elemType: DestinyDyeReference })
  lockedDyes?: DestinyDyeReference[];

  @SpeakeasyMetadata()
  weaponPatternHash?: number;

  @SpeakeasyMetadata()
  weaponPatternIdentifier?: string;
}

/**
 * This defines an item's "Value". Unfortunately, this appears to be used in different ways depending on the way that the item itself is used.
 *
 * @remarks
 * For items being sold at a Vendor, this is the default "sale price" of the item. These days, the vendor itself almost always sets the price, but it still possible for the price to fall back to this value. For quests, it is a preview of rewards you can gain by completing the quest. For dummy items, if the itemValue refers to an Emblem, it is the emblem that should be shown as the reward. (jeez louise)
 * It will likely be used in a number of other ways in the future, it appears to be a bucket where they put arbitrary items and quantities into the item.
 */
export class DestinyDefinitionsDestinyInventoryItemDefinitionValue extends SpeakeasyBase {
  /**
   * References to the items that make up this item's "value", and the quantity.
   */
  @SpeakeasyMetadata({ elemType: DestinyDestinyItemQuantity })
  itemValue?: DestinyDestinyItemQuantity[];

  /**
   * If there's a localized text description of the value provided, this will be said description.
   */
  @SpeakeasyMetadata()
  valueDescription?: string;
}

/**
 * So much of what you see in Destiny is actually an Item used in a new and creative way. This is the definition for Items in Destiny, which started off as just entities that could exist in your Inventory but ended up being the backing data for so much more: quests, reward previews, slots, and subclasses.
 *
 * @remarks
 * In practice, you will want to associate this data with "live" item data from a Bungie.Net Platform call: these definitions describe the item in generic, non-instanced terms: but an actual instance of an item can vary widely from these generic definitions.
 */
export class DestinyDefinitionsDestinyInventoryItemDefinition extends SpeakeasyBase {
  /**
   * If the item can be "used", this block will be non-null, and will have data related to the action performed when using the item. (Guess what? 99% of the time, this action is "dismantle". Shocker)
   */
  @SpeakeasyMetadata()
  action?: DestinyDefinitionsDestinyInventoryItemDefinitionAction;

  /**
   * BNet may forbid the execution of actions on this item via the API. If that is occurring, allowActions will be set to false.
   */
  @SpeakeasyMetadata()
  allowActions?: boolean;

  /**
   * If any animations were extracted from game content for this item, these will be the definitions of those animations.
   */
  @SpeakeasyMetadata({
    elemType: DestinyDefinitionsAnimationsDestinyAnimationReference,
  })
  animations?: DestinyDefinitionsAnimationsDestinyAnimationReference[];

  /**
   * Sometimes, an item will have a background color. Most notably this occurs with Emblems, who use the Background Color for small character nameplates such as the "friends" view you see in-game. There are almost certainly other items that have background color as well, though I have not bothered to investigate what items have it nor what purposes they serve: use it as you will.
   */
  @SpeakeasyMetadata()
  backgroundColor?: DestinyDefinitionsDestinyInventoryItemDefinitionBackgroundColor;

  /**
   * Some weapons and plugs can have a "Breaker Type": a special ability that works sort of like damage type vulnerabilities. This is (almost?) always set on items by plugs.
   */
  @SpeakeasyMetadata()
  breakerType?: number;

  /**
   * Since we also have a breaker type definition, this is the hash for that breaker type for your convenience. Whether you use the enum or hash and look up the definition depends on what's cleanest for your code.
   */
  @SpeakeasyMetadata()
  breakerTypeHash?: number;

  /**
   * We run a similarly weak-sauce algorithm to try and determine whether an item is restricted to a specific class. If we find it to be restricted in such a way, we set this classType property to match the class' enumeration value so that users can easily identify class restricted items.
   *
   * @remarks
   * If you see a mis-classed item, please inform the developers in the Bungie API forum.
   */
  @SpeakeasyMetadata()
  classType?: number;

  /**
   * If this item has a collectible related to it, this is the hash identifier of that collectible entry.
   */
  @SpeakeasyMetadata()
  collectibleHash?: number;

  /**
   * Recipe items will have relevant crafting information available here.
   */
  @SpeakeasyMetadata()
  crafting?: DestinyDefinitionsDestinyInventoryItemDefinitionCrafting;

  /**
   * Theoretically, an item can have many possible damage types. In *practice*, this is not true, but just in case weapons start being made that have multiple (for instance, an item where a socket has reusable plugs for every possible damage type that you can choose from freely), this field will return all of the possible damage types that are available to the weapon by default.
   */
  @SpeakeasyMetadata()
  damageTypeHashes?: number[];

  /**
   * This is the list of all damage types that we know ahead of time the item can take on. Unfortunately, this does not preclude the possibility of something funky happening to give the item a damage type that cannot be predicted beforehand: for example, if some designer decides to create arbitrary non-reusable plugs that cause damage type to change.
   *
   * @remarks
   * This damage type prediction will only use the following to determine potential damage types:
   * - Intrinsic perks
   * - Talent Node perks
   * - Known, reusable plugs for sockets
   */
  @SpeakeasyMetadata()
  damageTypes?: number[];

  /**
   * If the item has a damage type that could be considered to be default, it will be populated here.
   *
   * @remarks
   * For various upsetting reasons, it's surprisingly cumbersome to figure this out. I hope you're happy.
   */
  @SpeakeasyMetadata()
  defaultDamageType?: number;

  /**
   * Similar to defaultDamageType, but represented as the hash identifier for a DestinyDamageTypeDefinition.
   *
   * @remarks
   * I will likely regret leaving in the enumeration versions of these properties, but for now they're very convenient.
   */
  @SpeakeasyMetadata()
  defaultDamageTypeHash?: number;

  /**
   * Many Destiny*Definition contracts - the "first order" entities of Destiny that have their own tables in the Manifest Database - also have displayable information. This is the base class for that display information.
   */
  @SpeakeasyMetadata()
  displayProperties?: DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition;

  /**
   * In theory, it is a localized string telling you about how you can find the item. I really wish this was more consistent. Many times, it has nothing. Sometimes, it's instead a more narrative-forward description of the item. Which is cool, and I wish all properties had that data, but it should really be its own property.
   */
  @SpeakeasyMetadata()
  displaySource?: string;

  /**
   * The boolean will indicate to us (and you!) whether something *could* happen when you transfer this item from the Postmaster that might be considered a "destructive" action.
   *
   * @remarks
   * It is not feasible currently to tell you (or ourelves!) in a consistent way whether this *will* actually cause a destructive action, so we are playing it safe: if it has the potential to do so, we will not allow it to be transferred from the Postmaster by default. You will need to check for this flag before transferring an item from the Postmaster, or else you'll end up receiving an error.
   */
  @SpeakeasyMetadata()
  doesPostmasterPullHaveSideEffects?: boolean;

  /**
   * If the item is an emblem that has a special Objective attached to it - for instance, if the emblem tracks PVP Kills, or what-have-you. This is a bit different from, for example, the Vanguard Kill Tracker mod, which pipes data into the "art channel". When I get some time, I would like to standardize these so you can get at the values they expose without having to care about what they're being used for and how they are wired up, but for now here's the raw data.
   */
  @SpeakeasyMetadata()
  emblemObjectiveHash?: number;

  /**
   * If true, then you will be allowed to equip the item if you pass its other requirements.
   *
   * @remarks
   * This being false means that you cannot equip the item under any circumstances.
   */
  @SpeakeasyMetadata()
  equippable?: boolean;

  /**
   * If this item can be equipped, this block will be non-null and will be populated with the conditions under which it can be equipped.
   */
  @SpeakeasyMetadata()
  equippingBlock?: DestinyDefinitionsDestinyInventoryItemDefinitionEquippingBlock;

  @SpeakeasyMetadata()
  flavorText?: string;

  /**
   * If this item has related items in a "Gear Set", this will be non-null and the relationships defined herein.
   */
  @SpeakeasyMetadata()
  gearset?: DestinyDefinitionsDestinyInventoryItemDefinitionGearset;

  /**
   * The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.
   *
   * @remarks
   * When entities refer to each other in Destiny content, it is this hash that they are referring to.
   */
  @SpeakeasyMetadata()
  hash?: number;

  /**
   * If available, this is the original 'active' release watermark overlay for the icon. If the item has different versions, this can be overridden by the 'display version watermark icon' from the 'quality' block. Alternatively, if there is no watermark for the version, and the item version has a power cap below the current season power cap, this can be overridden by the iconWatermarkShelved property.
   */
  @SpeakeasyMetadata()
  iconWatermark?: string;

  /**
   * If available, this is the 'shelved' release watermark overlay for the icon. If the item version has a power cap below the current season power cap, it can be treated as 'shelved', and should be shown with this 'shelved' watermark overlay.
   */
  @SpeakeasyMetadata()
  iconWatermarkShelved?: string;

  /**
   * The index of the entity as it was found in the investment tables.
   */
  @SpeakeasyMetadata()
  index?: number;

  /**
   * If this item can exist in an inventory, this block will be non-null. In practice, every item that currently exists has one of these blocks. But note that it is not necessarily guaranteed.
   */
  @SpeakeasyMetadata()
  inventory?: DestinyDefinitionsDestinyInventoryItemDefinitionInventory;

  /**
   * If the item has stats, this block will be defined. It has the "raw" investment stats for the item. These investment stats don't take into account the ways that the items can spawn, nor do they take into account any Stat Group transformations. I have retained them for debugging purposes, but I do not know how useful people will find them.
   */
  @SpeakeasyMetadata({
    elemType: DestinyDefinitionsDestinyItemInvestmentStatDefinition,
  })
  investmentStats?: DestinyDefinitionsDestinyItemInvestmentStatDefinition[];

  /**
   * If true, this is a dummy vendor-wrapped item template. Items purchased from Eververse will be "wrapped" by one of these items so that we can safely provide refund capabilities before the item is "unwrapped".
   */
  @SpeakeasyMetadata()
  isWrapper?: boolean;

  /**
   * BNet attempts to make a more formal definition of item "Categories", as defined by DestinyItemCategoryDefinition. This is a list of all Categories that we were able to algorithmically determine that this item is a member of. (for instance, that it's a "Weapon", that it's an "Auto Rifle", etc...)
   *
   * @remarks
   * The algorithm for these is, unfortunately, volatile. If you believe you see a miscategorized item, please let us know on the Bungie API forums.
   */
  @SpeakeasyMetadata()
  itemCategoryHashes?: number[];

  /**
   * A value indicating the "sub-type" of the item. For instance, where an item might have an itemType value "Weapon", this will be something more specific like "Auto Rifle".
   *
   * @remarks
   * itemCategoryHashes are the preferred way of identifying types, we have retained this enum for its convenience.
   */
  @SpeakeasyMetadata()
  itemSubType?: number;

  /**
   * A value indicating the "base" the of the item. This enum is a useful but dramatic oversimplification of what it means for an item to have a "Type". Still, it's handy in many situations.
   *
   * @remarks
   * itemCategoryHashes are the preferred way of identifying types, we have retained this enum for its convenience.
   */
  @SpeakeasyMetadata()
  itemType?: number;

  /**
   * It became a common enough pattern in our UI to show Item Type and Tier combined into a single localized string that I'm just going to go ahead and start pre-creating these for items.
   */
  @SpeakeasyMetadata()
  itemTypeAndTierDisplayName?: string;

  /**
   * The localized title/name of the item's type. This can be whatever the designers want, and has no guarantee of consistency between items.
   */
  @SpeakeasyMetadata()
  itemTypeDisplayName?: string;

  /**
   * If we added any help or informational URLs about this item, these will be those links.
   */
  @SpeakeasyMetadata({ elemType: LinksHyperlinkReference })
  links?: LinksHyperlinkReference[];

  /**
   * If the item has any related Lore (DestinyLoreDefinition), this will be the hash identifier you can use to look up the lore definition.
   */
  @SpeakeasyMetadata()
  loreHash?: number;

  /**
   * If this item has available metrics to be shown, this block will be non-null have the appropriate hashes defined.
   */
  @SpeakeasyMetadata()
  metrics?: DestinyDefinitionsDestinyInventoryItemDefinitionMetrics;

  /**
   * The intrinsic transferability of an item.
   *
   * @remarks
   * I hate that this boolean is negative - but there's a reason.
   * Just because an item is intrinsically transferrable doesn't mean that it can be transferred, and we don't want to imply that this is the only source of that transferability.
   */
  @SpeakeasyMetadata()
  nonTransferrable?: boolean;

  /**
   * If this item has Objectives (extra tasks that can be accomplished related to the item... most frequently when the item is a Quest Step and the Objectives need to be completed to move on to the next Quest Step), this block will be non-null and the objectives defined herein.
   */
  @SpeakeasyMetadata()
  objectives?: DestinyDefinitionsDestinyInventoryItemDefinitionObjectives;

  /**
   * If the item has any *intrinsic* Perks (Perks that it will provide regardless of Sockets, Talent Grid, and other transitory state), they will be defined here.
   */
  @SpeakeasyMetadata({
    elemType: DestinyDefinitionsDestinyItemPerkEntryDefinition,
  })
  perks?: DestinyDefinitionsDestinyItemPerkEntryDefinition[];

  /**
   * If this item *is* a Plug, this will be non-null and the info defined herein. See DestinyItemPlugDefinition for more information.
   */
  @SpeakeasyMetadata()
  plug?: DestinyDefinitionsDestinyInventoryItemDefinitionPlug;

  /**
   * If this item can be Used or Acquired to gain other items (for instance, how Eververse Boxes can be consumed to get items from the box), this block will be non-null and will give summary information for the items that can be acquired.
   */
  @SpeakeasyMetadata()
  preview?: DestinyDefinitionsDestinyInventoryItemDefinitionPreview;

  /**
   * If this item can have a level or stats, this block will be non-null and will be populated with default quality (item level, "quality", and infusion) data. See the block for more details, there's often less upfront information in D2 so you'll want to be aware of how you use quality and item level on the definition level now.
   */
  @SpeakeasyMetadata()
  quality?: DestinyDefinitionsDestinyInventoryItemDefinitionQuality;

  /**
   * If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!
   */
  @SpeakeasyMetadata()
  redacted?: boolean;

  /**
   * If this item is a "reward sack" that can be opened to provide other items, this will be non-null and the properties of the sack contained herein.
   */
  @SpeakeasyMetadata()
  sack?: DestinyDefinitionsDestinyInventoryItemDefinitionSack;

  /**
   * If we were able to acquire an in-game screenshot for the item, the path to that screenshot will be returned here. Note that not all items have screenshots: particularly not any non-equippable items.
   */
  @SpeakeasyMetadata()
  screenshot?: string;

  /**
   * If this item is related directly to a Season of Destiny, this is the hash identifier for that season.
   */
  @SpeakeasyMetadata()
  seasonHash?: number;

  /**
   * A secondary icon associated with the item. Currently this is used in very context specific applications, such as Emblem Nameplates.
   */
  @SpeakeasyMetadata()
  secondaryIcon?: string;

  /**
   * Pulled from the secondary icon, this is the "secondary background" of the secondary icon. Confusing? Sure, that's why I call it "overlay" here: because as far as it's been used thus far, it has been for an optional overlay image. We'll see if that holds up, but at least for now it explains what this image is a bit better.
   */
  @SpeakeasyMetadata()
  secondaryOverlay?: string;

  /**
   * Pulled from the Secondary Icon, this is the "special" background for the item. For Emblems, this is the background image used on the Details view: but it need not be limited to that for other types of items.
   */
  @SpeakeasyMetadata()
  secondarySpecial?: string;

  /**
   * If this item is a quest, this block will be non-null. In practice, I wish I had called this the Quest block, but at the time it wasn't clear to me whether it would end up being used for purposes other than quests. It will contain data about the steps in the quest, and mechanics we can use for displaying and tracking the quest.
   */
  @SpeakeasyMetadata()
  setData?: DestinyDefinitionsDestinyInventoryItemDefinitionSetData;

  /**
   * If this item has any Sockets, this will be non-null and the individual sockets on the item will be defined herein.
   */
  @SpeakeasyMetadata()
  sockets?: DestinyDefinitionsDestinyInventoryItemDefinitionSockets;

  /**
   * If this item has a known source, this block will be non-null and populated with source information. Unfortunately, at this time we are not generating sources: that is some aggressively manual work which we didn't have time for, and I'm hoping to get back to at some point in the future.
   */
  @SpeakeasyMetadata()
  sourceData?: DestinyDefinitionsDestinyInventoryItemDefinitionSourceData;

  /**
   * In Destiny 1, we identified some items as having particular categories that we'd like to know about for various internal logic purposes. These are defined in SpecialItemType, and while these days the itemCategoryHashes are the preferred way of identifying types, we have retained this enum for its convenience.
   */
  @SpeakeasyMetadata()
  specialItemType?: number;

  /**
   * If this item can have stats (such as a weapon, armor, or vehicle), this block will be non-null and populated with the stats found on the item.
   */
  @SpeakeasyMetadata()
  stats?: DestinyDefinitionsDestinyInventoryItemDefinitionStats;

  /**
   * Summary data about the item.
   */
  @SpeakeasyMetadata()
  summary?: DestinyDefinitionsDestinyInventoryItemDefinitionSummary;

  /**
   * There are times when the game will show you a "summary/vague" version of an item - such as a description of its type represented as a DestinyInventoryItemDefinition - rather than display the item itself.
   *
   * @remarks
   * This happens sometimes when summarizing possible rewards in a tooltip. This is the item displayed instead, if it exists.
   */
  @SpeakeasyMetadata()
  summaryItemHash?: number;

  /**
   * If the item has a Talent Grid, this will be non-null and the properties of the grid defined herein. Note that, while many items still have talent grids, the only ones with meaningful Nodes still on them will be Subclass/"Build" items.
   */
  @SpeakeasyMetadata()
  talentGrid?: DestinyDefinitionsDestinyInventoryItemDefinitionTalentGrid;

  /**
   * Tooltips that only come up conditionally for the item. Check the live data DestinyItemComponent.tooltipNotificationIndexes property for which of these should be shown at runtime.
   */
  @SpeakeasyMetadata({
    elemType: DestinyDefinitionsDestinyItemTooltipNotification,
  })
  tooltipNotifications?: DestinyDefinitionsDestinyItemTooltipNotification[];

  /**
   * An identifier that the game UI uses to determine what type of tooltip to show for the item. These have no corresponding definitions that BNet can link to: so it'll be up to you to interpret and display your UI differently according to these styles (or ignore it).
   */
  @SpeakeasyMetadata()
  tooltipStyle?: string;

  /**
   * These are the corresponding trait definition hashes for the entries in traitIds.
   */
  @SpeakeasyMetadata()
  traitHashes?: number[];

  /**
   * Traits are metadata tags applied to this item. For example: armor slot, weapon type, foundry, faction, etc. These IDs come from the game and don't map to any content, but should still be useful.
   */
  @SpeakeasyMetadata()
  traitIds?: string[];

  /**
   * If this item can be rendered, this block will be non-null and will be populated with rendering information.
   */
  @SpeakeasyMetadata()
  translationBlock?: DestinyDefinitionsDestinyInventoryItemDefinitionTranslationBlock;

  /**
   * A string identifier that the game's UI uses to determine how the item should be rendered in inventory screens and the like. This could really be anything - at the moment, we don't have the time to really breakdown and maintain all the possible strings this could be, partly because new ones could be added ad hoc. But if you want to use it to dictate your own UI, or look for items with a certain display style, go for it!
   */
  @SpeakeasyMetadata()
  uiItemDisplayStyle?: string;

  /**
   * The conceptual "Value" of an item, if any was defined. See the DestinyItemValueBlockDefinition for more details.
   */
  @SpeakeasyMetadata()
  value?: DestinyDefinitionsDestinyInventoryItemDefinitionValue;
}
