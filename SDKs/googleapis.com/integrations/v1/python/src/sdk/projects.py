"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Any, Optional

class Projects:
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def integrations_projects_get_clientmetadata(self, request: operations.IntegrationsProjectsGetClientmetadataRequest, security: operations.IntegrationsProjectsGetClientmetadataSecurity) -> operations.IntegrationsProjectsGetClientmetadataResponse:
        r"""Gets the metadata info for the requested client"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.IntegrationsProjectsGetClientmetadataRequest, base_url, '/v1/{parent}/clientmetadata', request)
        
        query_params = utils.get_query_params(operations.IntegrationsProjectsGetClientmetadataRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IntegrationsProjectsGetClientmetadataResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GoogleCloudIntegrationsV1alphaGetClientMetadataResponse])
                res.google_cloud_integrations_v1alpha_get_client_metadata_response = out

        return res

    def integrations_projects_locations_apps_script_projects_create(self, request: operations.IntegrationsProjectsLocationsAppsScriptProjectsCreateRequest, security: operations.IntegrationsProjectsLocationsAppsScriptProjectsCreateSecurity) -> operations.IntegrationsProjectsLocationsAppsScriptProjectsCreateResponse:
        r"""Creates an Apps Script project."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.IntegrationsProjectsLocationsAppsScriptProjectsCreateRequest, base_url, '/v1/{parent}/appsScriptProjects', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "google_cloud_integrations_v1alpha_create_apps_script_project_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.IntegrationsProjectsLocationsAppsScriptProjectsCreateRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IntegrationsProjectsLocationsAppsScriptProjectsCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GoogleCloudIntegrationsV1alphaCreateAppsScriptProjectResponse])
                res.google_cloud_integrations_v1alpha_create_apps_script_project_response = out

        return res

    def integrations_projects_locations_apps_script_projects_link(self, request: operations.IntegrationsProjectsLocationsAppsScriptProjectsLinkRequest, security: operations.IntegrationsProjectsLocationsAppsScriptProjectsLinkSecurity) -> operations.IntegrationsProjectsLocationsAppsScriptProjectsLinkResponse:
        r"""Links a existing Apps Script project."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.IntegrationsProjectsLocationsAppsScriptProjectsLinkRequest, base_url, '/v1/{parent}/appsScriptProjects:link', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "google_cloud_integrations_v1alpha_link_apps_script_project_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.IntegrationsProjectsLocationsAppsScriptProjectsLinkRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IntegrationsProjectsLocationsAppsScriptProjectsLinkResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GoogleCloudIntegrationsV1alphaLinkAppsScriptProjectResponse])
                res.google_cloud_integrations_v1alpha_link_apps_script_project_response = out

        return res

    def integrations_projects_locations_clients_deprovision(self, request: operations.IntegrationsProjectsLocationsClientsDeprovisionRequest, security: operations.IntegrationsProjectsLocationsClientsDeprovisionSecurity) -> operations.IntegrationsProjectsLocationsClientsDeprovisionResponse:
        r"""Perform the deprovisioning steps to disable a user GCP project to use IP and purge all related data in a wipeout-compliant way."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.IntegrationsProjectsLocationsClientsDeprovisionRequest, base_url, '/v1/{parent}/clients:deprovision', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.IntegrationsProjectsLocationsClientsDeprovisionRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IntegrationsProjectsLocationsClientsDeprovisionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.google_protobuf_empty = out

        return res

    def integrations_projects_locations_clients_provision(self, request: operations.IntegrationsProjectsLocationsClientsProvisionRequest, security: operations.IntegrationsProjectsLocationsClientsProvisionSecurity) -> operations.IntegrationsProjectsLocationsClientsProvisionResponse:
        r"""Perform the provisioning steps to enable a user GCP project to use IP. If GCP project already registered on IP end via Apigee Integration, provisioning will fail."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.IntegrationsProjectsLocationsClientsProvisionRequest, base_url, '/v1/{parent}/clients:provision', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "google_cloud_integrations_v1alpha_provision_client_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.IntegrationsProjectsLocationsClientsProvisionRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IntegrationsProjectsLocationsClientsProvisionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.google_protobuf_empty = out

        return res

    def integrations_projects_locations_clients_switch(self, request: operations.IntegrationsProjectsLocationsClientsSwitchRequest, security: operations.IntegrationsProjectsLocationsClientsSwitchSecurity) -> operations.IntegrationsProjectsLocationsClientsSwitchResponse:
        r"""Update client from GMEK to CMEK"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.IntegrationsProjectsLocationsClientsSwitchRequest, base_url, '/v1/{parent}/clients:switch', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "google_cloud_integrations_v1alpha_switch_encryption_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.IntegrationsProjectsLocationsClientsSwitchRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IntegrationsProjectsLocationsClientsSwitchResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.google_protobuf_empty = out

        return res

    def integrations_projects_locations_connections_list(self, request: operations.IntegrationsProjectsLocationsConnectionsListRequest, security: operations.IntegrationsProjectsLocationsConnectionsListSecurity) -> operations.IntegrationsProjectsLocationsConnectionsListResponse:
        r"""Lists Connections in a given project and location."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.IntegrationsProjectsLocationsConnectionsListRequest, base_url, '/v1/{parent}/connections', request)
        
        query_params = utils.get_query_params(operations.IntegrationsProjectsLocationsConnectionsListRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IntegrationsProjectsLocationsConnectionsListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GoogleCloudIntegrationsV1alphaListConnectionsResponse])
                res.google_cloud_integrations_v1alpha_list_connections_response = out

        return res

    def integrations_projects_locations_connections_runtime_action_schemas_list(self, request: operations.IntegrationsProjectsLocationsConnectionsRuntimeActionSchemasListRequest, security: operations.IntegrationsProjectsLocationsConnectionsRuntimeActionSchemasListSecurity) -> operations.IntegrationsProjectsLocationsConnectionsRuntimeActionSchemasListResponse:
        r"""Lists the JSON schemas for the inputs and outputs of actions, filtered by action name."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.IntegrationsProjectsLocationsConnectionsRuntimeActionSchemasListRequest, base_url, '/v1/{parent}/runtimeActionSchemas', request)
        
        query_params = utils.get_query_params(operations.IntegrationsProjectsLocationsConnectionsRuntimeActionSchemasListRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IntegrationsProjectsLocationsConnectionsRuntimeActionSchemasListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GoogleCloudIntegrationsV1alphaListRuntimeActionSchemasResponse])
                res.google_cloud_integrations_v1alpha_list_runtime_action_schemas_response = out

        return res

    def integrations_projects_locations_connections_runtime_entity_schemas_list(self, request: operations.IntegrationsProjectsLocationsConnectionsRuntimeEntitySchemasListRequest, security: operations.IntegrationsProjectsLocationsConnectionsRuntimeEntitySchemasListSecurity) -> operations.IntegrationsProjectsLocationsConnectionsRuntimeEntitySchemasListResponse:
        r"""Lists the JSON schemas for the properties of runtime entities, filtered by entity name."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.IntegrationsProjectsLocationsConnectionsRuntimeEntitySchemasListRequest, base_url, '/v1/{parent}/runtimeEntitySchemas', request)
        
        query_params = utils.get_query_params(operations.IntegrationsProjectsLocationsConnectionsRuntimeEntitySchemasListRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IntegrationsProjectsLocationsConnectionsRuntimeEntitySchemasListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GoogleCloudIntegrationsV1alphaListRuntimeEntitySchemasResponse])
                res.google_cloud_integrations_v1alpha_list_runtime_entity_schemas_response = out

        return res

    def integrations_projects_locations_get_clients(self, request: operations.IntegrationsProjectsLocationsGetClientsRequest, security: operations.IntegrationsProjectsLocationsGetClientsSecurity) -> operations.IntegrationsProjectsLocationsGetClientsResponse:
        r"""Gets the client configuration for the given project and location resource name"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.IntegrationsProjectsLocationsGetClientsRequest, base_url, '/v1/{parent}/clients', request)
        
        query_params = utils.get_query_params(operations.IntegrationsProjectsLocationsGetClientsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IntegrationsProjectsLocationsGetClientsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GoogleCloudIntegrationsV1alphaGetClientResponse])
                res.google_cloud_integrations_v1alpha_get_client_response = out

        return res

    def integrations_projects_locations_products_auth_configs_create(self, request: operations.IntegrationsProjectsLocationsProductsAuthConfigsCreateRequest, security: operations.IntegrationsProjectsLocationsProductsAuthConfigsCreateSecurity) -> operations.IntegrationsProjectsLocationsProductsAuthConfigsCreateResponse:
        r"""Creates an auth config record. Fetch corresponding credentials for specific auth types, e.g. access token for OAuth 2.0, JWT token for JWT. Encrypt the auth config with Cloud KMS and store the encrypted credentials in Spanner. Returns the encrypted auth config."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.IntegrationsProjectsLocationsProductsAuthConfigsCreateRequest, base_url, '/v1/{parent}/authConfigs', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "google_cloud_integrations_v1alpha_auth_config_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.IntegrationsProjectsLocationsProductsAuthConfigsCreateRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IntegrationsProjectsLocationsProductsAuthConfigsCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GoogleCloudIntegrationsV1alphaAuthConfig])
                res.google_cloud_integrations_v1alpha_auth_config = out

        return res

    def integrations_projects_locations_products_auth_configs_list(self, request: operations.IntegrationsProjectsLocationsProductsAuthConfigsListRequest, security: operations.IntegrationsProjectsLocationsProductsAuthConfigsListSecurity) -> operations.IntegrationsProjectsLocationsProductsAuthConfigsListResponse:
        r"""Lists all auth configs that match the filter. Restrict to auth configs belong to the current client only."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.IntegrationsProjectsLocationsProductsAuthConfigsListRequest, base_url, '/v1/{parent}/authConfigs', request)
        
        query_params = utils.get_query_params(operations.IntegrationsProjectsLocationsProductsAuthConfigsListRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IntegrationsProjectsLocationsProductsAuthConfigsListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GoogleCloudIntegrationsV1alphaListAuthConfigsResponse])
                res.google_cloud_integrations_v1alpha_list_auth_configs_response = out

        return res

    def integrations_projects_locations_products_certificates_create(self, request: operations.IntegrationsProjectsLocationsProductsCertificatesCreateRequest, security: operations.IntegrationsProjectsLocationsProductsCertificatesCreateSecurity) -> operations.IntegrationsProjectsLocationsProductsCertificatesCreateResponse:
        r"""Creates a new certificate. The certificate will be registered to the trawler service and will be encrypted using cloud KMS and stored in Spanner Returns the certificate."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.IntegrationsProjectsLocationsProductsCertificatesCreateRequest, base_url, '/v1/{parent}/certificates', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "google_cloud_integrations_v1alpha_certificate_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.IntegrationsProjectsLocationsProductsCertificatesCreateRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IntegrationsProjectsLocationsProductsCertificatesCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GoogleCloudIntegrationsV1alphaCertificate])
                res.google_cloud_integrations_v1alpha_certificate = out

        return res

    def integrations_projects_locations_products_certificates_list(self, request: operations.IntegrationsProjectsLocationsProductsCertificatesListRequest, security: operations.IntegrationsProjectsLocationsProductsCertificatesListSecurity) -> operations.IntegrationsProjectsLocationsProductsCertificatesListResponse:
        r"""List all the certificates that match the filter. Restrict to certificate of current client only."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.IntegrationsProjectsLocationsProductsCertificatesListRequest, base_url, '/v1/{parent}/certificates', request)
        
        query_params = utils.get_query_params(operations.IntegrationsProjectsLocationsProductsCertificatesListRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IntegrationsProjectsLocationsProductsCertificatesListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GoogleCloudIntegrationsV1alphaListCertificatesResponse])
                res.google_cloud_integrations_v1alpha_list_certificates_response = out

        return res

    def integrations_projects_locations_products_cloud_functions_create(self, request: operations.IntegrationsProjectsLocationsProductsCloudFunctionsCreateRequest, security: operations.IntegrationsProjectsLocationsProductsCloudFunctionsCreateSecurity) -> operations.IntegrationsProjectsLocationsProductsCloudFunctionsCreateResponse:
        r"""Creates an cloud function project."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.IntegrationsProjectsLocationsProductsCloudFunctionsCreateRequest, base_url, '/v1/{parent}/cloudFunctions', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "google_cloud_integrations_v1alpha_create_cloud_function_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.IntegrationsProjectsLocationsProductsCloudFunctionsCreateRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IntegrationsProjectsLocationsProductsCloudFunctionsCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GoogleCloudIntegrationsV1alphaCreateCloudFunctionResponse])
                res.google_cloud_integrations_v1alpha_create_cloud_function_response = out

        return res

    def integrations_projects_locations_products_integrations_execute(self, request: operations.IntegrationsProjectsLocationsProductsIntegrationsExecuteRequest, security: operations.IntegrationsProjectsLocationsProductsIntegrationsExecuteSecurity) -> operations.IntegrationsProjectsLocationsProductsIntegrationsExecuteResponse:
        r"""Executes integrations synchronously by passing the trigger id in the request body. The request is not returned until the requested executions are either fulfilled or experienced an error. If the integration name is not specified (passing `-`), all of the associated integration under the given trigger_id will be executed. Otherwise only the specified integration for the given `trigger_id` is executed. This is helpful for execution the integration from UI."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.IntegrationsProjectsLocationsProductsIntegrationsExecuteRequest, base_url, '/v1/{name}:execute', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "google_cloud_integrations_v1alpha_execute_integrations_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.IntegrationsProjectsLocationsProductsIntegrationsExecuteRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IntegrationsProjectsLocationsProductsIntegrationsExecuteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GoogleCloudIntegrationsV1alphaExecuteIntegrationsResponse])
                res.google_cloud_integrations_v1alpha_execute_integrations_response = out

        return res

    def integrations_projects_locations_products_integrations_executions_cancel(self, request: operations.IntegrationsProjectsLocationsProductsIntegrationsExecutionsCancelRequest, security: operations.IntegrationsProjectsLocationsProductsIntegrationsExecutionsCancelSecurity) -> operations.IntegrationsProjectsLocationsProductsIntegrationsExecutionsCancelResponse:
        r"""Cancellation of an execution"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.IntegrationsProjectsLocationsProductsIntegrationsExecutionsCancelRequest, base_url, '/v1/{name}:cancel', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.IntegrationsProjectsLocationsProductsIntegrationsExecutionsCancelRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IntegrationsProjectsLocationsProductsIntegrationsExecutionsCancelResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GoogleCloudIntegrationsV1alphaCancelExecutionResponse])
                res.google_cloud_integrations_v1alpha_cancel_execution_response = out

        return res

    def integrations_projects_locations_products_integrations_executions_list(self, request: operations.IntegrationsProjectsLocationsProductsIntegrationsExecutionsListRequest, security: operations.IntegrationsProjectsLocationsProductsIntegrationsExecutionsListSecurity) -> operations.IntegrationsProjectsLocationsProductsIntegrationsExecutionsListResponse:
        r"""Lists the results of all the integration executions. The response includes the same information as the [execution log](https://cloud.google.com/application-integration/docs/viewing-logs) in the Integration UI."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.IntegrationsProjectsLocationsProductsIntegrationsExecutionsListRequest, base_url, '/v1/{parent}/executions', request)
        
        query_params = utils.get_query_params(operations.IntegrationsProjectsLocationsProductsIntegrationsExecutionsListRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IntegrationsProjectsLocationsProductsIntegrationsExecutionsListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GoogleCloudIntegrationsV1alphaListExecutionsResponse])
                res.google_cloud_integrations_v1alpha_list_executions_response = out

        return res

    def integrations_projects_locations_products_integrations_executions_suspensions_lift(self, request: operations.IntegrationsProjectsLocationsProductsIntegrationsExecutionsSuspensionsLiftRequest, security: operations.IntegrationsProjectsLocationsProductsIntegrationsExecutionsSuspensionsLiftSecurity) -> operations.IntegrationsProjectsLocationsProductsIntegrationsExecutionsSuspensionsLiftResponse:
        r"""* Lifts suspension for advanced suspension task. Fetch corresponding suspension with provided suspension Id, resolve suspension, and set up suspension result for the Suspension Task."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.IntegrationsProjectsLocationsProductsIntegrationsExecutionsSuspensionsLiftRequest, base_url, '/v1/{name}:lift', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "google_cloud_integrations_v1alpha_lift_suspension_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.IntegrationsProjectsLocationsProductsIntegrationsExecutionsSuspensionsLiftRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IntegrationsProjectsLocationsProductsIntegrationsExecutionsSuspensionsLiftResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GoogleCloudIntegrationsV1alphaLiftSuspensionResponse])
                res.google_cloud_integrations_v1alpha_lift_suspension_response = out

        return res

    def integrations_projects_locations_products_integrations_executions_suspensions_list(self, request: operations.IntegrationsProjectsLocationsProductsIntegrationsExecutionsSuspensionsListRequest, security: operations.IntegrationsProjectsLocationsProductsIntegrationsExecutionsSuspensionsListSecurity) -> operations.IntegrationsProjectsLocationsProductsIntegrationsExecutionsSuspensionsListResponse:
        r"""* Lists suspensions associated with a specific execution. Only those with permissions to resolve the relevant suspensions will be able to view them."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.IntegrationsProjectsLocationsProductsIntegrationsExecutionsSuspensionsListRequest, base_url, '/v1/{parent}/suspensions', request)
        
        query_params = utils.get_query_params(operations.IntegrationsProjectsLocationsProductsIntegrationsExecutionsSuspensionsListRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IntegrationsProjectsLocationsProductsIntegrationsExecutionsSuspensionsListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GoogleCloudIntegrationsV1alphaListSuspensionsResponse])
                res.google_cloud_integrations_v1alpha_list_suspensions_response = out

        return res

    def integrations_projects_locations_products_integrations_executions_suspensions_resolve(self, request: operations.IntegrationsProjectsLocationsProductsIntegrationsExecutionsSuspensionsResolveRequest, security: operations.IntegrationsProjectsLocationsProductsIntegrationsExecutionsSuspensionsResolveSecurity) -> operations.IntegrationsProjectsLocationsProductsIntegrationsExecutionsSuspensionsResolveResponse:
        r"""* Resolves (lifts/rejects) any number of suspensions. If the integration is already running, only the status of the suspension is updated. Otherwise, the suspended integration will begin execution again."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.IntegrationsProjectsLocationsProductsIntegrationsExecutionsSuspensionsResolveRequest, base_url, '/v1/{name}:resolve', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "google_cloud_integrations_v1alpha_resolve_suspension_request_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.IntegrationsProjectsLocationsProductsIntegrationsExecutionsSuspensionsResolveRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IntegrationsProjectsLocationsProductsIntegrationsExecutionsSuspensionsResolveResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.google_cloud_integrations_v1alpha_resolve_suspension_response = out

        return res

    def integrations_projects_locations_products_integrations_list(self, request: operations.IntegrationsProjectsLocationsProductsIntegrationsListRequest, security: operations.IntegrationsProjectsLocationsProductsIntegrationsListSecurity) -> operations.IntegrationsProjectsLocationsProductsIntegrationsListResponse:
        r"""Returns the list of all integrations in the specified project."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.IntegrationsProjectsLocationsProductsIntegrationsListRequest, base_url, '/v1/{parent}/integrations', request)
        
        query_params = utils.get_query_params(operations.IntegrationsProjectsLocationsProductsIntegrationsListRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IntegrationsProjectsLocationsProductsIntegrationsListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GoogleCloudIntegrationsV1alphaListIntegrationsResponse])
                res.google_cloud_integrations_v1alpha_list_integrations_response = out

        return res

    def integrations_projects_locations_products_integrations_schedule(self, request: operations.IntegrationsProjectsLocationsProductsIntegrationsScheduleRequest, security: operations.IntegrationsProjectsLocationsProductsIntegrationsScheduleSecurity) -> operations.IntegrationsProjectsLocationsProductsIntegrationsScheduleResponse:
        r"""Schedules an integration for execution by passing the trigger id and the scheduled time in the request body."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.IntegrationsProjectsLocationsProductsIntegrationsScheduleRequest, base_url, '/v1/{name}:schedule', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "google_cloud_integrations_v1alpha_schedule_integrations_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.IntegrationsProjectsLocationsProductsIntegrationsScheduleRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IntegrationsProjectsLocationsProductsIntegrationsScheduleResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GoogleCloudIntegrationsV1alphaScheduleIntegrationsResponse])
                res.google_cloud_integrations_v1alpha_schedule_integrations_response = out

        return res

    def integrations_projects_locations_products_integrations_test(self, request: operations.IntegrationsProjectsLocationsProductsIntegrationsTestRequest, security: operations.IntegrationsProjectsLocationsProductsIntegrationsTestSecurity) -> operations.IntegrationsProjectsLocationsProductsIntegrationsTestResponse:
        r"""Execute the integration in draft state"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.IntegrationsProjectsLocationsProductsIntegrationsTestRequest, base_url, '/v1/{name}:test', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "google_cloud_integrations_v1alpha_test_integrations_request_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.IntegrationsProjectsLocationsProductsIntegrationsTestRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IntegrationsProjectsLocationsProductsIntegrationsTestResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GoogleCloudIntegrationsV1alphaTestIntegrationsResponse])
                res.google_cloud_integrations_v1alpha_test_integrations_response = out

        return res

    def integrations_projects_locations_products_integrations_versions_create(self, request: operations.IntegrationsProjectsLocationsProductsIntegrationsVersionsCreateRequest, security: operations.IntegrationsProjectsLocationsProductsIntegrationsVersionsCreateSecurity) -> operations.IntegrationsProjectsLocationsProductsIntegrationsVersionsCreateResponse:
        r"""Create a integration with a draft version in the specified project."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.IntegrationsProjectsLocationsProductsIntegrationsVersionsCreateRequest, base_url, '/v1/{parent}/versions', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "google_cloud_integrations_v1alpha_integration_version_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.IntegrationsProjectsLocationsProductsIntegrationsVersionsCreateRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IntegrationsProjectsLocationsProductsIntegrationsVersionsCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GoogleCloudIntegrationsV1alphaIntegrationVersion])
                res.google_cloud_integrations_v1alpha_integration_version = out

        return res

    def integrations_projects_locations_products_integrations_versions_download(self, request: operations.IntegrationsProjectsLocationsProductsIntegrationsVersionsDownloadRequest, security: operations.IntegrationsProjectsLocationsProductsIntegrationsVersionsDownloadSecurity) -> operations.IntegrationsProjectsLocationsProductsIntegrationsVersionsDownloadResponse:
        r"""Downloads an integration. Retrieves the `IntegrationVersion` for a given `integration_id` and returns the response as a string."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.IntegrationsProjectsLocationsProductsIntegrationsVersionsDownloadRequest, base_url, '/v1/{name}:download', request)
        
        query_params = utils.get_query_params(operations.IntegrationsProjectsLocationsProductsIntegrationsVersionsDownloadRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IntegrationsProjectsLocationsProductsIntegrationsVersionsDownloadResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GoogleCloudIntegrationsV1alphaDownloadIntegrationVersionResponse])
                res.google_cloud_integrations_v1alpha_download_integration_version_response = out

        return res

    def integrations_projects_locations_products_integrations_versions_list(self, request: operations.IntegrationsProjectsLocationsProductsIntegrationsVersionsListRequest, security: operations.IntegrationsProjectsLocationsProductsIntegrationsVersionsListSecurity) -> operations.IntegrationsProjectsLocationsProductsIntegrationsVersionsListResponse:
        r"""Returns the list of all integration versions in the specified project."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.IntegrationsProjectsLocationsProductsIntegrationsVersionsListRequest, base_url, '/v1/{parent}/versions', request)
        
        query_params = utils.get_query_params(operations.IntegrationsProjectsLocationsProductsIntegrationsVersionsListRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IntegrationsProjectsLocationsProductsIntegrationsVersionsListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GoogleCloudIntegrationsV1alphaListIntegrationVersionsResponse])
                res.google_cloud_integrations_v1alpha_list_integration_versions_response = out

        return res

    def integrations_projects_locations_products_integrations_versions_publish(self, request: operations.IntegrationsProjectsLocationsProductsIntegrationsVersionsPublishRequest, security: operations.IntegrationsProjectsLocationsProductsIntegrationsVersionsPublishSecurity) -> operations.IntegrationsProjectsLocationsProductsIntegrationsVersionsPublishResponse:
        r"""This RPC throws an exception if the integration is in ARCHIVED or ACTIVE state. This RPC throws an exception if the version being published is DRAFT, and if the `locked_by` user is not the same as the user performing the Publish. Audit fields updated include last_published_timestamp, last_published_by, last_modified_timestamp, last_modified_by. Any existing lock is on this integration is released."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.IntegrationsProjectsLocationsProductsIntegrationsVersionsPublishRequest, base_url, '/v1/{name}:publish', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.IntegrationsProjectsLocationsProductsIntegrationsVersionsPublishRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IntegrationsProjectsLocationsProductsIntegrationsVersionsPublishResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.google_cloud_integrations_v1alpha_publish_integration_version_response = out

        return res

    def integrations_projects_locations_products_integrations_versions_takeover_edit_lock(self, request: operations.IntegrationsProjectsLocationsProductsIntegrationsVersionsTakeoverEditLockRequest, security: operations.IntegrationsProjectsLocationsProductsIntegrationsVersionsTakeoverEditLockSecurity) -> operations.IntegrationsProjectsLocationsProductsIntegrationsVersionsTakeoverEditLockResponse:
        r"""Clears the `locked_by` and `locked_at_timestamp`in the DRAFT version of this integration. It then performs the same action as the CreateDraftIntegrationVersion (i.e., copies the DRAFT version of the integration as a SNAPSHOT and then creates a new DRAFT version with the `locked_by` set to the `user_taking_over` and the `locked_at_timestamp` set to the current timestamp). Both the `locked_by` and `user_taking_over` are notified via email about the takeover. This RPC throws an exception if the integration is not in DRAFT status or if the `locked_by` and `locked_at_timestamp` fields are not set.The TakeoverEdit lock is treated the same as an edit of the integration, and hence shares ACLs with edit. Audit fields updated include last_modified_timestamp, last_modified_by."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.IntegrationsProjectsLocationsProductsIntegrationsVersionsTakeoverEditLockRequest, base_url, '/v1/{integrationVersion}:takeoverEditLock', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.IntegrationsProjectsLocationsProductsIntegrationsVersionsTakeoverEditLockRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IntegrationsProjectsLocationsProductsIntegrationsVersionsTakeoverEditLockResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GoogleCloudIntegrationsV1alphaTakeoverEditLockResponse])
                res.google_cloud_integrations_v1alpha_takeover_edit_lock_response = out

        return res

    def integrations_projects_locations_products_integrations_versions_unpublish(self, request: operations.IntegrationsProjectsLocationsProductsIntegrationsVersionsUnpublishRequest, security: operations.IntegrationsProjectsLocationsProductsIntegrationsVersionsUnpublishSecurity) -> operations.IntegrationsProjectsLocationsProductsIntegrationsVersionsUnpublishResponse:
        r"""Sets the status of the ACTIVE integration to SNAPSHOT with a new tag \\"PREVIOUSLY_PUBLISHED\\" after validating it. The \\"HEAD\\" and \\"PUBLISH_REQUESTED\\" tags do not change. This RPC throws an exception if the version being snapshot is not ACTIVE. Audit fields added include action, action_by, action_timestamp."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.IntegrationsProjectsLocationsProductsIntegrationsVersionsUnpublishRequest, base_url, '/v1/{name}:unpublish', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.IntegrationsProjectsLocationsProductsIntegrationsVersionsUnpublishRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IntegrationsProjectsLocationsProductsIntegrationsVersionsUnpublishResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.google_protobuf_empty = out

        return res

    def integrations_projects_locations_products_integrations_versions_upload(self, request: operations.IntegrationsProjectsLocationsProductsIntegrationsVersionsUploadRequest, security: operations.IntegrationsProjectsLocationsProductsIntegrationsVersionsUploadSecurity) -> operations.IntegrationsProjectsLocationsProductsIntegrationsVersionsUploadResponse:
        r"""Uploads an integration. The content can be a previously downloaded integration. Performs the same function as CreateDraftIntegrationVersion, but accepts input in a string format, which holds the complete representation of the IntegrationVersion content."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.IntegrationsProjectsLocationsProductsIntegrationsVersionsUploadRequest, base_url, '/v1/{parent}/versions:upload', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "google_cloud_integrations_v1alpha_upload_integration_version_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.IntegrationsProjectsLocationsProductsIntegrationsVersionsUploadRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IntegrationsProjectsLocationsProductsIntegrationsVersionsUploadResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GoogleCloudIntegrationsV1alphaUploadIntegrationVersionResponse])
                res.google_cloud_integrations_v1alpha_upload_integration_version_response = out

        return res

    def integrations_projects_locations_sfdc_instances_create(self, request: operations.IntegrationsProjectsLocationsSfdcInstancesCreateRequest, security: operations.IntegrationsProjectsLocationsSfdcInstancesCreateSecurity) -> operations.IntegrationsProjectsLocationsSfdcInstancesCreateResponse:
        r"""Creates an sfdc instance record. Store the sfdc instance in Spanner. Returns the sfdc instance."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.IntegrationsProjectsLocationsSfdcInstancesCreateRequest, base_url, '/v1/{parent}/sfdcInstances', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "google_cloud_integrations_v1alpha_sfdc_instance_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.IntegrationsProjectsLocationsSfdcInstancesCreateRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IntegrationsProjectsLocationsSfdcInstancesCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GoogleCloudIntegrationsV1alphaSfdcInstance])
                res.google_cloud_integrations_v1alpha_sfdc_instance = out

        return res

    def integrations_projects_locations_sfdc_instances_list(self, request: operations.IntegrationsProjectsLocationsSfdcInstancesListRequest, security: operations.IntegrationsProjectsLocationsSfdcInstancesListSecurity) -> operations.IntegrationsProjectsLocationsSfdcInstancesListResponse:
        r"""Lists all sfdc instances that match the filter. Restrict to sfdc instances belonging to the current client only."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.IntegrationsProjectsLocationsSfdcInstancesListRequest, base_url, '/v1/{parent}/sfdcInstances', request)
        
        query_params = utils.get_query_params(operations.IntegrationsProjectsLocationsSfdcInstancesListRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IntegrationsProjectsLocationsSfdcInstancesListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GoogleCloudIntegrationsV1alphaListSfdcInstancesResponse])
                res.google_cloud_integrations_v1alpha_list_sfdc_instances_response = out

        return res

    def integrations_projects_locations_sfdc_instances_sfdc_channels_create(self, request: operations.IntegrationsProjectsLocationsSfdcInstancesSfdcChannelsCreateRequest, security: operations.IntegrationsProjectsLocationsSfdcInstancesSfdcChannelsCreateSecurity) -> operations.IntegrationsProjectsLocationsSfdcInstancesSfdcChannelsCreateResponse:
        r"""Creates an sfdc channel record. Store the sfdc channel in Spanner. Returns the sfdc channel."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.IntegrationsProjectsLocationsSfdcInstancesSfdcChannelsCreateRequest, base_url, '/v1/{parent}/sfdcChannels', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "google_cloud_integrations_v1alpha_sfdc_channel_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.IntegrationsProjectsLocationsSfdcInstancesSfdcChannelsCreateRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IntegrationsProjectsLocationsSfdcInstancesSfdcChannelsCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GoogleCloudIntegrationsV1alphaSfdcChannel])
                res.google_cloud_integrations_v1alpha_sfdc_channel = out

        return res

    def integrations_projects_locations_sfdc_instances_sfdc_channels_delete(self, request: operations.IntegrationsProjectsLocationsSfdcInstancesSfdcChannelsDeleteRequest, security: operations.IntegrationsProjectsLocationsSfdcInstancesSfdcChannelsDeleteSecurity) -> operations.IntegrationsProjectsLocationsSfdcInstancesSfdcChannelsDeleteResponse:
        r"""Deletes an sfdc channel."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.IntegrationsProjectsLocationsSfdcInstancesSfdcChannelsDeleteRequest, base_url, '/v1/{name}', request)
        
        query_params = utils.get_query_params(operations.IntegrationsProjectsLocationsSfdcInstancesSfdcChannelsDeleteRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IntegrationsProjectsLocationsSfdcInstancesSfdcChannelsDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.google_protobuf_empty = out

        return res

    def integrations_projects_locations_sfdc_instances_sfdc_channels_get(self, request: operations.IntegrationsProjectsLocationsSfdcInstancesSfdcChannelsGetRequest, security: operations.IntegrationsProjectsLocationsSfdcInstancesSfdcChannelsGetSecurity) -> operations.IntegrationsProjectsLocationsSfdcInstancesSfdcChannelsGetResponse:
        r"""Gets an sfdc channel. If the channel doesn't exist, Code.NOT_FOUND exception will be thrown."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.IntegrationsProjectsLocationsSfdcInstancesSfdcChannelsGetRequest, base_url, '/v1/{name}', request)
        
        query_params = utils.get_query_params(operations.IntegrationsProjectsLocationsSfdcInstancesSfdcChannelsGetRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IntegrationsProjectsLocationsSfdcInstancesSfdcChannelsGetResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GoogleCloudIntegrationsV1alphaSfdcChannel])
                res.google_cloud_integrations_v1alpha_sfdc_channel = out

        return res

    def integrations_projects_locations_sfdc_instances_sfdc_channels_list(self, request: operations.IntegrationsProjectsLocationsSfdcInstancesSfdcChannelsListRequest, security: operations.IntegrationsProjectsLocationsSfdcInstancesSfdcChannelsListSecurity) -> operations.IntegrationsProjectsLocationsSfdcInstancesSfdcChannelsListResponse:
        r"""Lists all sfdc channels that match the filter. Restrict to sfdc channels belonging to the current client only."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.IntegrationsProjectsLocationsSfdcInstancesSfdcChannelsListRequest, base_url, '/v1/{parent}/sfdcChannels', request)
        
        query_params = utils.get_query_params(operations.IntegrationsProjectsLocationsSfdcInstancesSfdcChannelsListRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IntegrationsProjectsLocationsSfdcInstancesSfdcChannelsListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GoogleCloudIntegrationsV1alphaListSfdcChannelsResponse])
                res.google_cloud_integrations_v1alpha_list_sfdc_channels_response = out

        return res

    def integrations_projects_locations_sfdc_instances_sfdc_channels_patch(self, request: operations.IntegrationsProjectsLocationsSfdcInstancesSfdcChannelsPatchRequest, security: operations.IntegrationsProjectsLocationsSfdcInstancesSfdcChannelsPatchSecurity) -> operations.IntegrationsProjectsLocationsSfdcInstancesSfdcChannelsPatchResponse:
        r"""Updates an sfdc channel. Updates the sfdc channel in spanner. Returns the sfdc channel."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.IntegrationsProjectsLocationsSfdcInstancesSfdcChannelsPatchRequest, base_url, '/v1/{name}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "google_cloud_integrations_v1alpha_sfdc_channel_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.IntegrationsProjectsLocationsSfdcInstancesSfdcChannelsPatchRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PATCH', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.IntegrationsProjectsLocationsSfdcInstancesSfdcChannelsPatchResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GoogleCloudIntegrationsV1alphaSfdcChannel])
                res.google_cloud_integrations_v1alpha_sfdc_channel = out

        return res

    