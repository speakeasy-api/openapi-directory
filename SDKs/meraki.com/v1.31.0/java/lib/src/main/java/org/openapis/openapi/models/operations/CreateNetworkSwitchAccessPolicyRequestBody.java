/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package org.openapis.openapi.models.operations;

import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;

public class CreateNetworkSwitchAccessPolicyRequestBody {
    /**
     * Access Type of the policy. Automatically 'Hybrid authentication' when hostMode is 'Multi-Domain'.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("accessPolicyType")
    public CreateNetworkSwitchAccessPolicyRequestBodyAccessPolicyTypeEnum accessPolicyType;
    public CreateNetworkSwitchAccessPolicyRequestBody withAccessPolicyType(CreateNetworkSwitchAccessPolicyRequestBodyAccessPolicyTypeEnum accessPolicyType) {
        this.accessPolicyType = accessPolicyType;
        return this;
    }
    
    /**
     * 802.1x Settings
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("dot1x")
    public CreateNetworkSwitchAccessPolicyRequestBodyDot1x dot1x;
    public CreateNetworkSwitchAccessPolicyRequestBody withDot1x(CreateNetworkSwitchAccessPolicyRequestBodyDot1x dot1x) {
        this.dot1x = dot1x;
        return this;
    }
    
    /**
     * ID for the guest VLAN allow unauthorized devices access to limited network resources
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("guestVlanId")
    public Long guestVlanId;
    public CreateNetworkSwitchAccessPolicyRequestBody withGuestVlanId(Long guestVlanId) {
        this.guestVlanId = guestVlanId;
        return this;
    }
    
    /**
     * Choose the Host Mode for the access policy.
     */
    @JsonProperty("hostMode")
    public CreateNetworkSwitchAccessPolicyRequestBodyHostModeEnum hostMode;
    public CreateNetworkSwitchAccessPolicyRequestBody withHostMode(CreateNetworkSwitchAccessPolicyRequestBodyHostModeEnum hostMode) {
        this.hostMode = hostMode;
        return this;
    }
    
    /**
     * Enabling this option will make switches execute 802.1X and MAC-bypass authentication simultaneously so that clients authenticate faster. Only required when accessPolicyType is 'Hybrid Authentication.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("increaseAccessSpeed")
    public Boolean increaseAccessSpeed;
    public CreateNetworkSwitchAccessPolicyRequestBody withIncreaseAccessSpeed(Boolean increaseAccessSpeed) {
        this.increaseAccessSpeed = increaseAccessSpeed;
        return this;
    }
    
    /**
     * Name of the access policy
     */
    @JsonProperty("name")
    public String name;
    public CreateNetworkSwitchAccessPolicyRequestBody withName(String name) {
        this.name = name;
        return this;
    }
    
    /**
     * Object for RADIUS Settings
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("radius")
    public CreateNetworkSwitchAccessPolicyRequestBodyRadius radius;
    public CreateNetworkSwitchAccessPolicyRequestBody withRadius(CreateNetworkSwitchAccessPolicyRequestBodyRadius radius) {
        this.radius = radius;
        return this;
    }
    
    /**
     * Enable to send start, interim-update and stop messages to a configured RADIUS accounting server for tracking connected clients
     */
    @JsonProperty("radiusAccountingEnabled")
    public Boolean radiusAccountingEnabled;
    public CreateNetworkSwitchAccessPolicyRequestBody withRadiusAccountingEnabled(Boolean radiusAccountingEnabled) {
        this.radiusAccountingEnabled = radiusAccountingEnabled;
        return this;
    }
    
    /**
     * List of RADIUS accounting servers to require connecting devices to authenticate against before granting network access
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("radiusAccountingServers")
    public CreateNetworkSwitchAccessPolicyRequestBodyRadiusAccountingServers[] radiusAccountingServers;
    public CreateNetworkSwitchAccessPolicyRequestBody withRadiusAccountingServers(CreateNetworkSwitchAccessPolicyRequestBodyRadiusAccountingServers[] radiusAccountingServers) {
        this.radiusAccountingServers = radiusAccountingServers;
        return this;
    }
    
    /**
     * Change of authentication for RADIUS re-authentication and disconnection
     */
    @JsonProperty("radiusCoaSupportEnabled")
    public Boolean radiusCoaSupportEnabled;
    public CreateNetworkSwitchAccessPolicyRequestBody withRadiusCoaSupportEnabled(Boolean radiusCoaSupportEnabled) {
        this.radiusCoaSupportEnabled = radiusCoaSupportEnabled;
        return this;
    }
    
    /**
     * Acceptable values are `""` for None, or `"11"` for Group Policies ACL
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("radiusGroupAttribute")
    public String radiusGroupAttribute;
    public CreateNetworkSwitchAccessPolicyRequestBody withRadiusGroupAttribute(String radiusGroupAttribute) {
        this.radiusGroupAttribute = radiusGroupAttribute;
        return this;
    }
    
    /**
     * List of RADIUS servers to require connecting devices to authenticate against before granting network access
     */
    @JsonProperty("radiusServers")
    public CreateNetworkSwitchAccessPolicyRequestBodyRadiusServers[] radiusServers;
    public CreateNetworkSwitchAccessPolicyRequestBody withRadiusServers(CreateNetworkSwitchAccessPolicyRequestBodyRadiusServers[] radiusServers) {
        this.radiusServers = radiusServers;
        return this;
    }
    
    /**
     * If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers
     */
    @JsonProperty("radiusTestingEnabled")
    public Boolean radiusTestingEnabled;
    public CreateNetworkSwitchAccessPolicyRequestBody withRadiusTestingEnabled(Boolean radiusTestingEnabled) {
        this.radiusTestingEnabled = radiusTestingEnabled;
        return this;
    }
    
    /**
     * Enable to restrict access for clients to a specific set of IP addresses or hostnames prior to authentication
     */
    @JsonProperty("urlRedirectWalledGardenEnabled")
    public Boolean urlRedirectWalledGardenEnabled;
    public CreateNetworkSwitchAccessPolicyRequestBody withUrlRedirectWalledGardenEnabled(Boolean urlRedirectWalledGardenEnabled) {
        this.urlRedirectWalledGardenEnabled = urlRedirectWalledGardenEnabled;
        return this;
    }
    
    /**
     * IP address ranges, in CIDR notation, to restrict access for clients to a specific set of IP addresses or hostnames prior to authentication
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("urlRedirectWalledGardenRanges")
    public String[] urlRedirectWalledGardenRanges;
    public CreateNetworkSwitchAccessPolicyRequestBody withUrlRedirectWalledGardenRanges(String[] urlRedirectWalledGardenRanges) {
        this.urlRedirectWalledGardenRanges = urlRedirectWalledGardenRanges;
        return this;
    }
    
    /**
     * CDP/LLDP capable voice clients will be able to use this VLAN. Automatically true when hostMode is 'Multi-Domain'.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("voiceVlanClients")
    public Boolean voiceVlanClients;
    public CreateNetworkSwitchAccessPolicyRequestBody withVoiceVlanClients(Boolean voiceVlanClients) {
        this.voiceVlanClients = voiceVlanClients;
        return this;
    }
    
}
