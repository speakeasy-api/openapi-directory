/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * Data source APIs
 */
export class DataSources {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Create an arista switch data source
   *
   * @remarks
   * Add arista switch data source
   */
  addAristaSwitch(
    req: shared.SwitchDataSourceRequest,
    security: operations.AddAristaSwitchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AddAristaSwitchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.SwitchDataSourceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/data-sources/arista-switches";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AddAristaSwitchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AddAristaSwitchResponse =
        new operations.AddAristaSwitchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.switchDataSource = utils.objectToClass(
              httpRes?.data,
              shared.SwitchDataSource
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 403, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Create a brocade switch data source
   *
   * @remarks
   * Add brocade switch as a data source
   */
  addBrocadeSwitch(
    req: shared.SwitchDataSourceRequest,
    security: operations.AddBrocadeSwitchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AddBrocadeSwitchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.SwitchDataSourceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/data-sources/brocade-switches";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AddBrocadeSwitchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AddBrocadeSwitchResponse =
        new operations.AddBrocadeSwitchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.switchDataSource = utils.objectToClass(
              httpRes?.data,
              shared.SwitchDataSource
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 403, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Create a checkpoint firewall
   *
   * @remarks
   * Add checkpoint firewall as data source
   */
  addCheckpointFirewall(
    req: shared.SwitchDataSourceRequest,
    security: operations.AddCheckpointFirewallSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AddCheckpointFirewallResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.SwitchDataSourceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/data-sources/checkpoint-firewalls";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AddCheckpointFirewallSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AddCheckpointFirewallResponse =
        new operations.AddCheckpointFirewallResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.switchDataSource = utils.objectToClass(
              httpRes?.data,
              shared.SwitchDataSource
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 403, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Create a cisco switch data source
   *
   * @remarks
   * Add cisco switch as data source. User must provide one of ip or fqdn field in the request body.
   * Appropriate proxy id is retrieved from infra/nodes URL to select the proxy node.
   */
  addCiscoSwitch(
    req: shared.CiscoSwitchDataSourceRequest,
    security: operations.AddCiscoSwitchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AddCiscoSwitchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.CiscoSwitchDataSourceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/data-sources/cisco-switches";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AddCiscoSwitchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AddCiscoSwitchResponse =
        new operations.AddCiscoSwitchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.ciscoSwitchDataSource = utils.objectToClass(
              httpRes?.data,
              shared.CiscoSwitchDataSource
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 403, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Create a dell switch data source
   *
   * @remarks
   * Add a dell switch as data source
   */
  addDellSwitch(
    req: shared.DellSwitchDataSourceRequest,
    security: operations.AddDellSwitchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AddDellSwitchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.DellSwitchDataSourceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/data-sources/dell-switches";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AddDellSwitchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AddDellSwitchResponse =
        new operations.AddDellSwitchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.dellSwitchDataSource = utils.objectToClass(
              httpRes?.data,
              shared.DellSwitchDataSource
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 403, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Create a hp oneview manager data source
   *
   * @remarks
   * Add a hp oneview manager data source
   */
  addHpovManager(
    req: shared.SwitchDataSource,
    security: operations.AddHpovManagerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AddHpovManagerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.SwitchDataSource(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/data-sources/hpov-managers";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AddHpovManagerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AddHpovManagerResponse =
        new operations.AddHpovManagerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.switchDataSource = utils.objectToClass(
              httpRes?.data,
              shared.SwitchDataSource
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 403, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Create a hpvc manager data source
   *
   * @remarks
   * Add hpvc manager data source
   */
  addHpvcManager(
    req: shared.SwitchDataSource,
    security: operations.AddHpvcManagerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AddHpvcManagerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.SwitchDataSource(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/data-sources/hpvc-managers";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AddHpvcManagerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AddHpvcManagerResponse =
        new operations.AddHpvcManagerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.switchDataSource = utils.objectToClass(
              httpRes?.data,
              shared.SwitchDataSource
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 403, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Add a juniper switch as data source
   *
   * @remarks
   * Add switch Datasource
   */
  addJuniperSwitch(
    req: shared.SwitchDataSourceRequest,
    security: operations.AddJuniperSwitchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AddJuniperSwitchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.SwitchDataSourceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/data-sources/juniper-switches";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AddJuniperSwitchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AddJuniperSwitchResponse =
        new operations.AddJuniperSwitchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.switchDataSource = utils.objectToClass(
              httpRes?.data,
              shared.SwitchDataSource
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 403, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Create a nsx-v manager data source
   *
   * @remarks
   * Add a nsx-v manager data source
   */
  addNsxvManagerDatasource(
    req: shared.NSXVManagerDataSourceRequest,
    security: operations.AddNsxvManagerDatasourceSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AddNsxvManagerDatasourceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.NSXVManagerDataSourceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/data-sources/nsxv-managers";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AddNsxvManagerDatasourceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AddNsxvManagerDatasourceResponse =
        new operations.AddNsxvManagerDatasourceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.nsxvManagerDataSource = utils.objectToClass(
              httpRes?.data,
              shared.NSXVManagerDataSource
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 403, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Create panorama firewall data source
   *
   * @remarks
   * Add panorama firewall as data source
   */
  addPanoramaFirewall(
    req: shared.SwitchDataSourceRequest,
    security: operations.AddPanoramaFirewallSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AddPanoramaFirewallResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.SwitchDataSourceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/data-sources/panorama-firewalls";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AddPanoramaFirewallSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AddPanoramaFirewallResponse =
        new operations.AddPanoramaFirewallResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.switchDataSource = utils.objectToClass(
              httpRes?.data,
              shared.SwitchDataSource
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 403, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Create an ucs manager data source
   *
   * @remarks
   * Add an ucs manager as data source
   */
  addUcsManager(
    req: shared.SwitchDataSource,
    security: operations.AddUcsManagerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AddUcsManagerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.SwitchDataSource(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/data-sources/ucs-managers";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AddUcsManagerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AddUcsManagerResponse =
        new operations.AddUcsManagerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.switchDataSource = utils.objectToClass(
              httpRes?.data,
              shared.SwitchDataSource
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 403, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Create a vCenter data source
   *
   * @remarks
   * Add a vcenter data source. User must provide one of ip or fqdn field in the request body.
   * Appropriate proxy id is retrieved from infra/nodes URL to select the proxy node.
   */
  addVcenterDatasource(
    req: shared.VCenterDataSourceRequest,
    security: operations.AddVcenterDatasourceSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AddVcenterDatasourceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.VCenterDataSourceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/data-sources/vcenters";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AddVcenterDatasourceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AddVcenterDatasourceResponse =
        new operations.AddVcenterDatasourceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.vCenterDataSource = utils.objectToClass(
              httpRes?.data,
              shared.VCenterDataSource
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 403, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Delete an arista switch data source
   *
   * @remarks
   * Delete an arista switch data source
   */
  deleteAristaSwitch(
    req: operations.DeleteAristaSwitchRequest,
    security: operations.DeleteAristaSwitchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteAristaSwitchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteAristaSwitchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/arista-switches/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteAristaSwitchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteAristaSwitchResponse =
        new operations.DeleteAristaSwitchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [200, 401, 403, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Delete a brocade switch data source
   *
   * @remarks
   * Delete a brocade switch data source
   */
  deleteBrocadeSwitch(
    req: operations.DeleteBrocadeSwitchRequest,
    security: operations.DeleteBrocadeSwitchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteBrocadeSwitchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteBrocadeSwitchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/brocade-switches/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteBrocadeSwitchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteBrocadeSwitchResponse =
        new operations.DeleteBrocadeSwitchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [200, 401, 403, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Delete a checkpoint firewall data source
   *
   * @remarks
   * Delete a checkpoint firewall data source
   */
  deleteCheckpointFirewall(
    req: operations.DeleteCheckpointFirewallRequest,
    security: operations.DeleteCheckpointFirewallSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteCheckpointFirewallResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteCheckpointFirewallRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/checkpoint-firewalls/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteCheckpointFirewallSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteCheckpointFirewallResponse =
        new operations.DeleteCheckpointFirewallResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [200, 401, 403, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Delete a cisco switch data source
   *
   * @remarks
   * Delete a cisco switch data source
   */
  deleteCiscoSwitch(
    req: operations.DeleteCiscoSwitchRequest,
    security: operations.DeleteCiscoSwitchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteCiscoSwitchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteCiscoSwitchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/cisco-switches/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteCiscoSwitchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteCiscoSwitchResponse =
        new operations.DeleteCiscoSwitchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [200, 401, 403, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Delete a dell switch data source
   *
   * @remarks
   * Delete a data source
   */
  deleteDellSwitch(
    req: operations.DeleteDellSwitchRequest,
    security: operations.DeleteDellSwitchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteDellSwitchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteDellSwitchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/dell-switches/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteDellSwitchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteDellSwitchResponse =
        new operations.DeleteDellSwitchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [200, 401, 403, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Delete a hp oneview data source
   *
   * @remarks
   * Delete a hp oneview data source
   */
  deleteHpovManager(
    req: operations.DeleteHpovManagerRequest,
    security: operations.DeleteHpovManagerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteHpovManagerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteHpovManagerRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/hpov-managers/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteHpovManagerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteHpovManagerResponse =
        new operations.DeleteHpovManagerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [200, 401, 403, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Delete a hpvc manager data source
   *
   * @remarks
   * Delete a hpvc manager data source
   */
  deleteHpvcManager(
    req: operations.DeleteHpvcManagerRequest,
    security: operations.DeleteHpvcManagerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteHpvcManagerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteHpvcManagerRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/hpvc-managers/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteHpvcManagerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteHpvcManagerResponse =
        new operations.DeleteHpvcManagerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [200, 401, 403, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Delete a juniper switch data source
   *
   * @remarks
   * Delete a juniper switch data source
   */
  deleteJuniperSwitch(
    req: operations.DeleteJuniperSwitchRequest,
    security: operations.DeleteJuniperSwitchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteJuniperSwitchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteJuniperSwitchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/juniper-switches/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteJuniperSwitchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteJuniperSwitchResponse =
        new operations.DeleteJuniperSwitchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [200, 401, 403, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Delete a nsx-v manager data source
   *
   * @remarks
   * Delete a nsx-v manager data source
   */
  deleteNsxvManager(
    req: operations.DeleteNsxvManagerRequest,
    security: operations.DeleteNsxvManagerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteNsxvManagerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteNsxvManagerRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/nsxv-managers/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteNsxvManagerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteNsxvManagerResponse =
        new operations.DeleteNsxvManagerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [200, 401, 403, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Delete a panorama firewall data source
   *
   * @remarks
   * Delete a panorama firewall data source
   */
  deletePanoramaFirewall(
    req: operations.DeletePanoramaFirewallRequest,
    security: operations.DeletePanoramaFirewallSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DeletePanoramaFirewallResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeletePanoramaFirewallRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/panorama-firewalls/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeletePanoramaFirewallSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeletePanoramaFirewallResponse =
        new operations.DeletePanoramaFirewallResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [200, 401, 403, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Delete an ucs manager data source
   *
   * @remarks
   * Delete an ucs manager data source
   */
  deleteUcsManager(
    req: operations.DeleteUcsManagerRequest,
    security: operations.DeleteUcsManagerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteUcsManagerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteUcsManagerRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/ucs-managers/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteUcsManagerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteUcsManagerResponse =
        new operations.DeleteUcsManagerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [200, 401, 403, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Delete a vCenter data source
   *
   * @remarks
   * Delete a data source
   */
  deleteVcenter(
    req: operations.DeleteVcenterRequest,
    security: operations.DeleteVcenterSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteVcenterResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteVcenterRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/vcenters/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteVcenterSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteVcenterResponse =
        new operations.DeleteVcenterResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 401, 403, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Disable an arista switch data source
   *
   * @remarks
   * Disable an arista switch data source
   */
  disableAristaSwitch(
    req: operations.DisableAristaSwitchRequest,
    security: operations.DisableAristaSwitchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DisableAristaSwitchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DisableAristaSwitchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/arista-switches/{id}/disable",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DisableAristaSwitchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DisableAristaSwitchResponse =
        new operations.DisableAristaSwitchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [200, 401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Disable a brocade switch data source
   */
  disableBrocadeSwitch(
    req: operations.DisableBrocadeSwitchRequest,
    security: operations.DisableBrocadeSwitchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DisableBrocadeSwitchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DisableBrocadeSwitchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/brocade-switches/{id}/disable",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DisableBrocadeSwitchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DisableBrocadeSwitchResponse =
        new operations.DisableBrocadeSwitchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [200, 401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Disable a checkpoint firewall data source
   *
   * @remarks
   * Disable a checkpoint firewall data source
   */
  disableCheckpointFirewall(
    req: operations.DisableCheckpointFirewallRequest,
    security: operations.DisableCheckpointFirewallSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DisableCheckpointFirewallResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DisableCheckpointFirewallRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/checkpoint-firewalls/{id}/disable",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DisableCheckpointFirewallSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DisableCheckpointFirewallResponse =
        new operations.DisableCheckpointFirewallResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [200, 401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Disable a cisco switch data source
   *
   * @remarks
   * Disable a cisco switch data source
   */
  disableCiscoSwitch(
    req: operations.DisableCiscoSwitchRequest,
    security: operations.DisableCiscoSwitchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DisableCiscoSwitchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DisableCiscoSwitchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/cisco-switches/{id}/disable",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DisableCiscoSwitchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DisableCiscoSwitchResponse =
        new operations.DisableCiscoSwitchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [200, 401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Disable a dell switch data source
   *
   * @remarks
   * Disable a dell switch data source
   */
  disableDellSwitch(
    req: operations.DisableDellSwitchRequest,
    security: operations.DisableDellSwitchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DisableDellSwitchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DisableDellSwitchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/dell-switches/{id}/disable",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DisableDellSwitchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DisableDellSwitchResponse =
        new operations.DisableDellSwitchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [200, 401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Disable a hp oneview data source
   *
   * @remarks
   * Disable a hp oneview data source
   */
  disableHpovManager(
    req: operations.DisableHpovManagerRequest,
    security: operations.DisableHpovManagerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DisableHpovManagerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DisableHpovManagerRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/hpov-managers/{id}/disable",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DisableHpovManagerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DisableHpovManagerResponse =
        new operations.DisableHpovManagerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [200, 401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Disable a hpvc manager data source
   *
   * @remarks
   * Disable a hpvc manager data source
   */
  disableHpvcManager(
    req: operations.DisableHpvcManagerRequest,
    security: operations.DisableHpvcManagerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DisableHpvcManagerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DisableHpvcManagerRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/hpvc-managers/{id}/disable",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DisableHpvcManagerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DisableHpvcManagerResponse =
        new operations.DisableHpvcManagerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [200, 401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Disable a juniper switch data source
   *
   * @remarks
   * Disable a juniper switch data source
   */
  disableJuniperSwitch(
    req: operations.DisableJuniperSwitchRequest,
    security: operations.DisableJuniperSwitchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DisableJuniperSwitchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DisableJuniperSwitchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/juniper-switches/{id}/disable",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DisableJuniperSwitchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DisableJuniperSwitchResponse =
        new operations.DisableJuniperSwitchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [200, 401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Disable a nsx-v manager data source
   *
   * @remarks
   * Disable a nsx-v manager data source
   */
  disableNsxvManager(
    req: operations.DisableNsxvManagerRequest,
    security: operations.DisableNsxvManagerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DisableNsxvManagerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DisableNsxvManagerRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/nsxv-managers/{id}/disable",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DisableNsxvManagerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DisableNsxvManagerResponse =
        new operations.DisableNsxvManagerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [200, 401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Disable a panorama firewall data source
   *
   * @remarks
   * Disable a panorama firewall data source
   */
  disablePanoramaFirewall(
    req: operations.DisablePanoramaFirewallRequest,
    security: operations.DisablePanoramaFirewallSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DisablePanoramaFirewallResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DisablePanoramaFirewallRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/panorama-firewalls/{id}/disable",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DisablePanoramaFirewallSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DisablePanoramaFirewallResponse =
        new operations.DisablePanoramaFirewallResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [200, 401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Disable an ucs manager data source
   *
   * @remarks
   * Disable an ucs manager data source
   */
  disableUcsManager(
    req: operations.DisableUcsManagerRequest,
    security: operations.DisableUcsManagerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DisableUcsManagerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DisableUcsManagerRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/ucs-managers/{id}/disable",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DisableUcsManagerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DisableUcsManagerResponse =
        new operations.DisableUcsManagerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [200, 401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Disable a vCenter data source
   *
   * @remarks
   * Disable a vCenter data source
   */
  disableVcenter(
    req: operations.DisableVcenterRequest,
    security: operations.DisableVcenterSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DisableVcenterResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DisableVcenterRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/vcenters/{id}/disable",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DisableVcenterSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DisableVcenterResponse =
        new operations.DisableVcenterResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [200, 401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Enable an arista switch data source
   *
   * @remarks
   * Enable an arista switch data source
   */
  enableAristaSwitch(
    req: operations.EnableAristaSwitchRequest,
    security: operations.EnableAristaSwitchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.EnableAristaSwitchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.EnableAristaSwitchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/arista-switches/{id}/enable",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.EnableAristaSwitchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.EnableAristaSwitchResponse =
        new operations.EnableAristaSwitchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [200, 401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Enable a brocade switch data source
   */
  enableBrocadeSwitch(
    req: operations.EnableBrocadeSwitchRequest,
    security: operations.EnableBrocadeSwitchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.EnableBrocadeSwitchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.EnableBrocadeSwitchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/brocade-switches/{id}/enable",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.EnableBrocadeSwitchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.EnableBrocadeSwitchResponse =
        new operations.EnableBrocadeSwitchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [200, 401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Enable a checkpoint firewall data source
   *
   * @remarks
   * Enable a checkpoint firewall data source
   */
  enableCheckpointFirewall(
    req: operations.EnableCheckpointFirewallRequest,
    security: operations.EnableCheckpointFirewallSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.EnableCheckpointFirewallResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.EnableCheckpointFirewallRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/checkpoint-firewalls/{id}/enable",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.EnableCheckpointFirewallSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.EnableCheckpointFirewallResponse =
        new operations.EnableCheckpointFirewallResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [200, 401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Enable a cisco switch data source
   *
   * @remarks
   * Enable a cisco switch data source
   */
  enableCiscoSwitch(
    req: operations.EnableCiscoSwitchRequest,
    security: operations.EnableCiscoSwitchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.EnableCiscoSwitchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.EnableCiscoSwitchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/cisco-switches/{id}/enable",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.EnableCiscoSwitchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.EnableCiscoSwitchResponse =
        new operations.EnableCiscoSwitchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [200, 401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Enable a dell switch data source
   *
   * @remarks
   * Enable a dell switch data source
   */
  enableDellSwitch(
    req: operations.EnableDellSwitchRequest,
    security: operations.EnableDellSwitchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.EnableDellSwitchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.EnableDellSwitchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/dell-switches/{id}/enable",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.EnableDellSwitchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.EnableDellSwitchResponse =
        new operations.EnableDellSwitchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [200, 401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Enable a hp oneview data source
   *
   * @remarks
   * Enable a hp oneview data source
   */
  enableHpovManager(
    req: operations.EnableHpovManagerRequest,
    security: operations.EnableHpovManagerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.EnableHpovManagerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.EnableHpovManagerRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/hpov-managers/{id}/enable",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.EnableHpovManagerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.EnableHpovManagerResponse =
        new operations.EnableHpovManagerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [200, 401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Enable a hpvc manager data source
   *
   * @remarks
   * Enable a hpvc manager data source
   */
  enableHpvcManager(
    req: operations.EnableHpvcManagerRequest,
    security: operations.EnableHpvcManagerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.EnableHpvcManagerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.EnableHpvcManagerRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/hpvc-managers/{id}/enable",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.EnableHpvcManagerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.EnableHpvcManagerResponse =
        new operations.EnableHpvcManagerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [200, 401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Enable a juniper switch data source
   *
   * @remarks
   * Enable a juniper switch data source
   */
  enableJuniperSwitch(
    req: operations.EnableJuniperSwitchRequest,
    security: operations.EnableJuniperSwitchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.EnableJuniperSwitchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.EnableJuniperSwitchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/juniper-switches/{id}/enable",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.EnableJuniperSwitchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.EnableJuniperSwitchResponse =
        new operations.EnableJuniperSwitchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [200, 401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Enable a nsx-v manager data source
   *
   * @remarks
   * Enable a nsx-v manager data source
   */
  enableNsxvManager(
    req: operations.EnableNsxvManagerRequest,
    security: operations.EnableNsxvManagerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.EnableNsxvManagerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.EnableNsxvManagerRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/nsxv-managers/{id}/enable",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.EnableNsxvManagerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.EnableNsxvManagerResponse =
        new operations.EnableNsxvManagerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [200, 401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Enable a panorama firewall data source
   *
   * @remarks
   * Enable a panorama firewall data source
   */
  enablePanoramaFirewall(
    req: operations.EnablePanoramaFirewallRequest,
    security: operations.EnablePanoramaFirewallSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.EnablePanoramaFirewallResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.EnablePanoramaFirewallRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/panorama-firewalls/{id}/enable",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.EnablePanoramaFirewallSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.EnablePanoramaFirewallResponse =
        new operations.EnablePanoramaFirewallResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [200, 401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Enable an ucs manager data source
   *
   * @remarks
   * Enable an ucs manager data source
   */
  enableUcsManager(
    req: operations.EnableUcsManagerRequest,
    security: operations.EnableUcsManagerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.EnableUcsManagerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.EnableUcsManagerRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/ucs-managers/{id}/enable",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.EnableUcsManagerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.EnableUcsManagerResponse =
        new operations.EnableUcsManagerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [200, 401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Enable a vCenter data source
   *
   * @remarks
   * Enable a vCenter data source
   */
  enableVcenter(
    req: operations.EnableVcenterRequest,
    security: operations.EnableVcenterSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.EnableVcenterResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.EnableVcenterRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/vcenters/{id}/enable",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.EnableVcenterSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.EnableVcenterResponse =
        new operations.EnableVcenterResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [200, 401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Show arista switch data source details
   *
   * @remarks
   * Show arista switch data source details
   */
  getAristaSwitch(
    req: operations.GetAristaSwitchRequest,
    security: operations.GetAristaSwitchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetAristaSwitchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetAristaSwitchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/arista-switches/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetAristaSwitchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetAristaSwitchResponse =
        new operations.GetAristaSwitchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.switchDataSource = utils.objectToClass(
              httpRes?.data,
              shared.SwitchDataSource
            );
          }
          break;
        case [401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Show snmp config for arista switch data source
   *
   * @remarks
   * Show snmp config for arista switch data source
   */
  getAristaSwitchSnmpConfig(
    req: operations.GetAristaSwitchSnmpConfigRequest,
    security: operations.GetAristaSwitchSnmpConfigSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetAristaSwitchSnmpConfigResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetAristaSwitchSnmpConfigRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/arista-switches/{id}/snmp-config",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetAristaSwitchSnmpConfigSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetAristaSwitchSnmpConfigResponse =
        new operations.GetAristaSwitchSnmpConfigResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.snmpConfig = utils.objectToClass(
              httpRes?.data,
              shared.SNMPConfig
            );
          }
          break;
        case [401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Show brocade switch data source details
   *
   * @remarks
   * Show brocade switch data source details
   */
  getBrocadeSwitch(
    req: operations.GetBrocadeSwitchRequest,
    security: operations.GetBrocadeSwitchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetBrocadeSwitchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetBrocadeSwitchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/brocade-switches/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetBrocadeSwitchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetBrocadeSwitchResponse =
        new operations.GetBrocadeSwitchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.switchDataSource = utils.objectToClass(
              httpRes?.data,
              shared.SwitchDataSource
            );
          }
          break;
        case [401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Show snmp config for brocade switch data source
   *
   * @remarks
   * Show snmp config for brocade switch data source
   */
  getBrocadeSwitchSnmpConfig(
    req: operations.GetBrocadeSwitchSnmpConfigRequest,
    security: operations.GetBrocadeSwitchSnmpConfigSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetBrocadeSwitchSnmpConfigResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetBrocadeSwitchSnmpConfigRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/brocade-switches/{id}/snmp-config",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetBrocadeSwitchSnmpConfigSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetBrocadeSwitchSnmpConfigResponse =
        new operations.GetBrocadeSwitchSnmpConfigResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.snmpConfig = utils.objectToClass(
              httpRes?.data,
              shared.SNMPConfig
            );
          }
          break;
        case [401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Show checkpoint firewall data source details
   *
   * @remarks
   * Show checkpoint firewall data source details
   */
  getCheckpointFirewall(
    req: operations.GetCheckpointFirewallRequest,
    security: operations.GetCheckpointFirewallSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetCheckpointFirewallResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetCheckpointFirewallRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/checkpoint-firewalls/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetCheckpointFirewallSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetCheckpointFirewallResponse =
        new operations.GetCheckpointFirewallResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.switchDataSource = utils.objectToClass(
              httpRes?.data,
              shared.SwitchDataSource
            );
          }
          break;
        case [401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Show cisco switch data source details
   *
   * @remarks
   * Show cisco switch data source details
   */
  getCiscoSwitch(
    req: operations.GetCiscoSwitchRequest,
    security: operations.GetCiscoSwitchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetCiscoSwitchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetCiscoSwitchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/cisco-switches/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetCiscoSwitchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetCiscoSwitchResponse =
        new operations.GetCiscoSwitchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.ciscoSwitchDataSource = utils.objectToClass(
              httpRes?.data,
              shared.CiscoSwitchDataSource
            );
          }
          break;
        case [401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Show snmp config for cisco switch data source
   *
   * @remarks
   * Show snmp config for cisco switch data source
   */
  getCiscoSwitchSnmpConfig(
    req: operations.GetCiscoSwitchSnmpConfigRequest,
    security: operations.GetCiscoSwitchSnmpConfigSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetCiscoSwitchSnmpConfigResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetCiscoSwitchSnmpConfigRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/cisco-switches/{id}/snmp-config",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetCiscoSwitchSnmpConfigSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetCiscoSwitchSnmpConfigResponse =
        new operations.GetCiscoSwitchSnmpConfigResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.snmpConfig = utils.objectToClass(
              httpRes?.data,
              shared.SNMPConfig
            );
          }
          break;
        case [401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Show dell switch data source details
   *
   * @remarks
   * Get a dell switch data source details
   */
  getDellSwitch(
    req: operations.GetDellSwitchRequest,
    security: operations.GetDellSwitchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetDellSwitchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetDellSwitchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/dell-switches/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetDellSwitchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetDellSwitchResponse =
        new operations.GetDellSwitchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.dellSwitchDataSource = utils.objectToClass(
              httpRes?.data,
              shared.DellSwitchDataSource
            );
          }
          break;
        case [401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Show snmp config for dell switch data source
   *
   * @remarks
   * Show snmp config for dell switch data source
   */
  getDellSwitchSnmpConfig(
    req: operations.GetDellSwitchSnmpConfigRequest,
    security: operations.GetDellSwitchSnmpConfigSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetDellSwitchSnmpConfigResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetDellSwitchSnmpConfigRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/dell-switches/{id}/snmp-config",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetDellSwitchSnmpConfigSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetDellSwitchSnmpConfigResponse =
        new operations.GetDellSwitchSnmpConfigResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.snmpConfig = utils.objectToClass(
              httpRes?.data,
              shared.SNMPConfig
            );
          }
          break;
        case [401, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Show hp oneview data source details
   *
   * @remarks
   * Show hp oneview data source details
   */
  getHpovManager(
    req: operations.GetHpovManagerRequest,
    security: operations.GetHpovManagerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetHpovManagerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetHpovManagerRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/hpov-managers/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetHpovManagerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetHpovManagerResponse =
        new operations.GetHpovManagerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.switchDataSource = utils.objectToClass(
              httpRes?.data,
              shared.SwitchDataSource
            );
          }
          break;
        case [401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Show hpvc data source details
   *
   * @remarks
   * Show hpvc data source details
   */
  getHpvcManager(
    req: operations.GetHpvcManagerRequest,
    security: operations.GetHpvcManagerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetHpvcManagerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetHpvcManagerRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/hpvc-managers/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetHpvcManagerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetHpvcManagerResponse =
        new operations.GetHpvcManagerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.switchDataSource = utils.objectToClass(
              httpRes?.data,
              shared.SwitchDataSource
            );
          }
          break;
        case [401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Show juniper switch data source details
   *
   * @remarks
   * Show juniper switch data source details
   */
  getJuniperSwitch(
    req: operations.GetJuniperSwitchRequest,
    security: operations.GetJuniperSwitchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetJuniperSwitchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetJuniperSwitchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/juniper-switches/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetJuniperSwitchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetJuniperSwitchResponse =
        new operations.GetJuniperSwitchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.switchDataSource = utils.objectToClass(
              httpRes?.data,
              shared.SwitchDataSource
            );
          }
          break;
        case [401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Show snmp config for juniper switch data source
   *
   * @remarks
   * Show snmp config for juniper switch data source
   */
  getJuniperSwitchSnmpConfig(
    req: operations.GetJuniperSwitchSnmpConfigRequest,
    security: operations.GetJuniperSwitchSnmpConfigSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetJuniperSwitchSnmpConfigResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetJuniperSwitchSnmpConfigRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/juniper-switches/{id}/snmp-config",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetJuniperSwitchSnmpConfigSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetJuniperSwitchSnmpConfigResponse =
        new operations.GetJuniperSwitchSnmpConfigResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.snmpConfig = utils.objectToClass(
              httpRes?.data,
              shared.SNMPConfig
            );
          }
          break;
        case [401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Show nsx controller-cluster details
   *
   * @remarks
   * Show nsx controller-cluster details
   */
  getNsxvControllerCluster(
    req: operations.GetNsxvControllerClusterRequest,
    security: operations.GetNsxvControllerClusterSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNsxvControllerClusterResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNsxvControllerClusterRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/nsxv-managers/{id}/controller-cluster",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetNsxvControllerClusterSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNsxvControllerClusterResponse =
        new operations.GetNsxvControllerClusterResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.nsxControllerDataCollection = utils.objectToClass(
              httpRes?.data,
              shared.NSXControllerDataCollection
            );
          }
          break;
        case [401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Show nsx-v manager data source details
   *
   * @remarks
   * Show nsx-v manager data source details
   */
  getNsxvManager(
    req: operations.GetNsxvManagerRequest,
    security: operations.GetNsxvManagerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNsxvManagerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNsxvManagerRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/nsxv-managers/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetNsxvManagerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNsxvManagerResponse =
        new operations.GetNsxvManagerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.nsxvManagerDataSource = utils.objectToClass(
              httpRes?.data,
              shared.NSXVManagerDataSource
            );
          }
          break;
        case [401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Show panorama firewall data source details
   *
   * @remarks
   * Show panorama firewall data source details
   */
  getPanoramaFirewall(
    req: operations.GetPanoramaFirewallRequest,
    security: operations.GetPanoramaFirewallSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetPanoramaFirewallResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetPanoramaFirewallRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/panorama-firewalls/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetPanoramaFirewallSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetPanoramaFirewallResponse =
        new operations.GetPanoramaFirewallResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.switchDataSource = utils.objectToClass(
              httpRes?.data,
              shared.SwitchDataSource
            );
          }
          break;
        case [401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Show ucs manager data source details
   *
   * @remarks
   * Show ucs manager data source details
   */
  getUcsManager(
    req: operations.GetUcsManagerRequest,
    security: operations.GetUcsManagerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetUcsManagerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetUcsManagerRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/ucs-managers/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetUcsManagerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetUcsManagerResponse =
        new operations.GetUcsManagerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.switchDataSource = utils.objectToClass(
              httpRes?.data,
              shared.SwitchDataSource
            );
          }
          break;
        case [401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Show snmp config for ucs fabric interconnects
   *
   * @remarks
   * Show snmp config for ucs fabric interconnects
   */
  getUcsSnmpConfig(
    req: operations.GetUcsSnmpConfigRequest,
    security: operations.GetUcsSnmpConfigSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetUcsSnmpConfigResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetUcsSnmpConfigRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/ucs-managers/{id}/snmp-config",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetUcsSnmpConfigSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetUcsSnmpConfigResponse =
        new operations.GetUcsSnmpConfigResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.snmpConfig = utils.objectToClass(
              httpRes?.data,
              shared.SNMPConfig
            );
          }
          break;
        case [401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Show vCenter data source details
   *
   * @remarks
   * Show vCenter data source details
   */
  getVcenter(
    req: operations.GetVcenterRequest,
    security: operations.GetVcenterSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetVcenterResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetVcenterRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/vcenters/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetVcenterSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetVcenterResponse =
        new operations.GetVcenterResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.vCenterDataSource = utils.objectToClass(
              httpRes?.data,
              shared.VCenterDataSource
            );
          }
          break;
        case [401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * List arista switch data sources
   *
   * @remarks
   * List arista switch data sources
   */
  listAristaSwitches(
    config?: AxiosRequestConfig
  ): Promise<operations.ListAristaSwitchesResponse> {
    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/data-sources/arista-switches";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListAristaSwitchesResponse =
        new operations.ListAristaSwitchesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.dataSourceListResponse = utils.objectToClass(
              httpRes?.data,
              shared.DataSourceListResponse
            );
          }
          break;
        case [401, 403, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * List brocade switch data sources
   *
   * @remarks
   * List brocade switch data sources
   */
  listBrocadeSwitches(
    config?: AxiosRequestConfig
  ): Promise<operations.ListBrocadeSwitchesResponse> {
    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/data-sources/brocade-switches";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListBrocadeSwitchesResponse =
        new operations.ListBrocadeSwitchesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.dataSourceListResponse = utils.objectToClass(
              httpRes?.data,
              shared.DataSourceListResponse
            );
          }
          break;
        case [401, 403, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * List checkpoint firewall data sources
   *
   * @remarks
   * List checkpoint firewall data sources
   */
  listCheckpointFirewalls(
    config?: AxiosRequestConfig
  ): Promise<operations.ListCheckpointFirewallsResponse> {
    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/data-sources/checkpoint-firewalls";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListCheckpointFirewallsResponse =
        new operations.ListCheckpointFirewallsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.dataSourceListResponse = utils.objectToClass(
              httpRes?.data,
              shared.DataSourceListResponse
            );
          }
          break;
        case [401, 403, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * List cisco switch data sources
   *
   * @remarks
   * List cisco switch data sources
   */
  listCiscoSwitches(
    config?: AxiosRequestConfig
  ): Promise<operations.ListCiscoSwitchesResponse> {
    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/data-sources/cisco-switches";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListCiscoSwitchesResponse =
        new operations.ListCiscoSwitchesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.dataSourceListResponse = utils.objectToClass(
              httpRes?.data,
              shared.DataSourceListResponse
            );
          }
          break;
        case [401, 403, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * List dell switch data sources
   *
   * @remarks
   * List dell switch data sources
   */
  listDellSwitches(
    config?: AxiosRequestConfig
  ): Promise<operations.ListDellSwitchesResponse> {
    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/data-sources/dell-switches";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListDellSwitchesResponse =
        new operations.ListDellSwitchesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.dataSourceListResponse = utils.objectToClass(
              httpRes?.data,
              shared.DataSourceListResponse
            );
          }
          break;
        case [401, 403, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * List hp oneview manager data sources
   *
   * @remarks
   * List hp oneview manager data sources
   */
  listHpovManagers(
    config?: AxiosRequestConfig
  ): Promise<operations.ListHpovManagersResponse> {
    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/data-sources/hpov-managers";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListHpovManagersResponse =
        new operations.ListHpovManagersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.dataSourceListResponse = utils.objectToClass(
              httpRes?.data,
              shared.DataSourceListResponse
            );
          }
          break;
        case [401, 403, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * List hpvc manager data sources
   *
   * @remarks
   * List hpvc manager data sources
   */
  listHpvcManagers(
    config?: AxiosRequestConfig
  ): Promise<operations.ListHpvcManagersResponse> {
    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/data-sources/hpvc-managers";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListHpvcManagersResponse =
        new operations.ListHpvcManagersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.dataSourceListResponse = utils.objectToClass(
              httpRes?.data,
              shared.DataSourceListResponse
            );
          }
          break;
        case [401, 403, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * List juniper switch data sources
   *
   * @remarks
   * List juniper switch data sources
   */
  listJuniperSwitches(
    config?: AxiosRequestConfig
  ): Promise<operations.ListJuniperSwitchesResponse> {
    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/data-sources/juniper-switches";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListJuniperSwitchesResponse =
        new operations.ListJuniperSwitchesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.dataSourceListResponse = utils.objectToClass(
              httpRes?.data,
              shared.DataSourceListResponse
            );
          }
          break;
        case [401, 403, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * List nsx-v manager data sources
   *
   * @remarks
   * List nsx-v manager data sources
   */
  listNsxvManagers(
    config?: AxiosRequestConfig
  ): Promise<operations.ListNsxvManagersResponse> {
    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/data-sources/nsxv-managers";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListNsxvManagersResponse =
        new operations.ListNsxvManagersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.dataSourceListResponse = utils.objectToClass(
              httpRes?.data,
              shared.DataSourceListResponse
            );
          }
          break;
        case [401, 403, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * List panorama firewall data sources
   *
   * @remarks
   * List panorama firewall data sources
   */
  listPanoramaFirewalls(
    config?: AxiosRequestConfig
  ): Promise<operations.ListPanoramaFirewallsResponse> {
    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/data-sources/panorama-firewalls";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListPanoramaFirewallsResponse =
        new operations.ListPanoramaFirewallsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.dataSourceListResponse = utils.objectToClass(
              httpRes?.data,
              shared.DataSourceListResponse
            );
          }
          break;
        case [401, 403, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * List ucs manager data sources
   *
   * @remarks
   * List ucs manager data sources
   */
  listUcsManagers(
    config?: AxiosRequestConfig
  ): Promise<operations.ListUcsManagersResponse> {
    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/data-sources/ucs-managers";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListUcsManagersResponse =
        new operations.ListUcsManagersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.dataSourceListResponse = utils.objectToClass(
              httpRes?.data,
              shared.DataSourceListResponse
            );
          }
          break;
        case [401, 403, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * List vCenter data sources
   *
   * @remarks
   * List vCenter data sources
   */
  listVcenters(
    config?: AxiosRequestConfig
  ): Promise<operations.ListVcentersResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/data-sources/vcenters";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListVcentersResponse =
        new operations.ListVcentersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.dataSourceListResponse = utils.objectToClass(
              httpRes?.data,
              shared.DataSourceListResponse
            );
          }
          break;
        case [401, 403, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an arista switch data source
   *
   * @remarks
   * Update an switch data source
   */
  updateAristaSwitch(
    req: operations.UpdateAristaSwitchRequest,
    security: operations.UpdateAristaSwitchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateAristaSwitchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateAristaSwitchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/arista-switches/{id}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "switchDataSource",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateAristaSwitchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateAristaSwitchResponse =
        new operations.UpdateAristaSwitchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.switchDataSource = utils.objectToClass(
              httpRes?.data,
              shared.SwitchDataSource
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update snmp config for arista switch data source
   *
   * @remarks
   * Update snmp config for arista switch data source
   */
  updateAristaSwitchSnmpConfig(
    req: operations.UpdateAristaSwitchSnmpConfigRequest,
    security: operations.UpdateAristaSwitchSnmpConfigSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateAristaSwitchSnmpConfigResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateAristaSwitchSnmpConfigRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/arista-switches/{id}/snmp-config",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "snmpConfig",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateAristaSwitchSnmpConfigSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateAristaSwitchSnmpConfigResponse =
        new operations.UpdateAristaSwitchSnmpConfigResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.snmpConfig = utils.objectToClass(
              httpRes?.data,
              shared.SNMPConfig
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update a brocade switch data source
   *
   * @remarks
   * Update a brocade switch data source. Only credentials, nickname and notes can be updated.
   */
  updateBrocadeSwitch(
    req: operations.UpdateBrocadeSwitchRequest,
    security: operations.UpdateBrocadeSwitchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateBrocadeSwitchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateBrocadeSwitchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/brocade-switches/{id}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "switchDataSource",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateBrocadeSwitchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateBrocadeSwitchResponse =
        new operations.UpdateBrocadeSwitchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.switchDataSource = utils.objectToClass(
              httpRes?.data,
              shared.SwitchDataSource
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update snmp config for brocade switch data source
   *
   * @remarks
   * Update snmp config for brocade switch data source
   */
  updateBrocadeSwitchSnmpConfig(
    req: operations.UpdateBrocadeSwitchSnmpConfigRequest,
    security: operations.UpdateBrocadeSwitchSnmpConfigSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateBrocadeSwitchSnmpConfigResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateBrocadeSwitchSnmpConfigRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/brocade-switches/{id}/snmp-config",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "snmpConfig",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateBrocadeSwitchSnmpConfigSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateBrocadeSwitchSnmpConfigResponse =
        new operations.UpdateBrocadeSwitchSnmpConfigResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.snmpConfig = utils.objectToClass(
              httpRes?.data,
              shared.SNMPConfig
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update a checkpoint firewall data source
   *
   * @remarks
   * Update a checkpoint firewall data source
   */
  updateCheckpointFirewall(
    req: operations.UpdateCheckpointFirewallRequest,
    security: operations.UpdateCheckpointFirewallSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateCheckpointFirewallResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateCheckpointFirewallRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/checkpoint-firewalls/{id}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "switchDataSource",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateCheckpointFirewallSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateCheckpointFirewallResponse =
        new operations.UpdateCheckpointFirewallResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.switchDataSource = utils.objectToClass(
              httpRes?.data,
              shared.SwitchDataSource
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update a cisco switch data source
   *
   * @remarks
   * Update a cisco switch data source. Only credentials, nickname and notes can be updated.
   */
  updateCiscoSwitch(
    req: operations.UpdateCiscoSwitchRequest,
    security: operations.UpdateCiscoSwitchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateCiscoSwitchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateCiscoSwitchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/cisco-switches/{id}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "ciscoSwitchDataSource",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateCiscoSwitchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateCiscoSwitchResponse =
        new operations.UpdateCiscoSwitchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.ciscoSwitchDataSource = utils.objectToClass(
              httpRes?.data,
              shared.CiscoSwitchDataSource
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update snmp config for cisco switch data source
   *
   * @remarks
   * Update snmp config for cisco switch data source
   */
  updateCiscoSwitchSnmpConfig(
    req: operations.UpdateCiscoSwitchSnmpConfigRequest,
    security: operations.UpdateCiscoSwitchSnmpConfigSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateCiscoSwitchSnmpConfigResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateCiscoSwitchSnmpConfigRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/cisco-switches/{id}/snmp-config",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "snmpConfig",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateCiscoSwitchSnmpConfigSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateCiscoSwitchSnmpConfigResponse =
        new operations.UpdateCiscoSwitchSnmpConfigResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.snmpConfig = utils.objectToClass(
              httpRes?.data,
              shared.SNMPConfig
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update a dell switch data source
   *
   * @remarks
   * Update a dell switch data source. Only credentials, nickname and notes can be updated
   */
  updateDellSwitch(
    req: operations.UpdateDellSwitchRequest,
    security: operations.UpdateDellSwitchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateDellSwitchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateDellSwitchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/dell-switches/{id}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "dellSwitchDataSource",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateDellSwitchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateDellSwitchResponse =
        new operations.UpdateDellSwitchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.dellSwitchDataSource = utils.objectToClass(
              httpRes?.data,
              shared.DellSwitchDataSource
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update snmp config for dell switch data source
   *
   * @remarks
   * Update snmp config for dell switch data source
   */
  updateDellSwitchSnmpConfig(
    req: operations.UpdateDellSwitchSnmpConfigRequest,
    security: operations.UpdateDellSwitchSnmpConfigSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateDellSwitchSnmpConfigResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateDellSwitchSnmpConfigRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/dell-switches/{id}/snmp-config",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "snmpConfig",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateDellSwitchSnmpConfigSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateDellSwitchSnmpConfigResponse =
        new operations.UpdateDellSwitchSnmpConfigResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.snmpConfig = utils.objectToClass(
              httpRes?.data,
              shared.SNMPConfig
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update a hp oneview data source
   *
   * @remarks
   * Update a hp oneview data source
   */
  updateHpovManager(
    req: operations.UpdateHpovManagerRequest,
    security: operations.UpdateHpovManagerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateHpovManagerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateHpovManagerRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/hpov-managers/{id}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "switchDataSource",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateHpovManagerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateHpovManagerResponse =
        new operations.UpdateHpovManagerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.switchDataSource = utils.objectToClass(
              httpRes?.data,
              shared.SwitchDataSource
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update a hpvc manager data source
   *
   * @remarks
   * Update a hpvc manager data source
   */
  updateHpvcManager(
    req: operations.UpdateHpvcManagerRequest,
    security: operations.UpdateHpvcManagerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateHpvcManagerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateHpvcManagerRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/hpvc-managers/{id}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "switchDataSource",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateHpvcManagerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateHpvcManagerResponse =
        new operations.UpdateHpvcManagerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.switchDataSource = utils.objectToClass(
              httpRes?.data,
              shared.SwitchDataSource
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update a juniper switch data source
   *
   * @remarks
   * Update a juniper switch data source
   */
  updateJuniperSwitch(
    req: operations.UpdateJuniperSwitchRequest,
    security: operations.UpdateJuniperSwitchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateJuniperSwitchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateJuniperSwitchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/juniper-switches/{id}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "switchDataSource",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateJuniperSwitchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateJuniperSwitchResponse =
        new operations.UpdateJuniperSwitchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.switchDataSource = utils.objectToClass(
              httpRes?.data,
              shared.SwitchDataSource
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update snmp config for a juniper switch data source
   *
   * @remarks
   * Update snmp config for a juniper switch data source
   */
  updateJuniperSwitchSnmpConfig(
    req: operations.UpdateJuniperSwitchSnmpConfigRequest,
    security: operations.UpdateJuniperSwitchSnmpConfigSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateJuniperSwitchSnmpConfigResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateJuniperSwitchSnmpConfigRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/juniper-switches/{id}/snmp-config",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "snmpConfig",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateJuniperSwitchSnmpConfigSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateJuniperSwitchSnmpConfigResponse =
        new operations.UpdateJuniperSwitchSnmpConfigResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.snmpConfig = utils.objectToClass(
              httpRes?.data,
              shared.SNMPConfig
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update nsx controller-cluster details
   *
   * @remarks
   * Update nsx controller-cluster details
   */
  updateNsxvControllerCluster(
    req: operations.UpdateNsxvControllerClusterRequest,
    security: operations.UpdateNsxvControllerClusterSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateNsxvControllerClusterResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateNsxvControllerClusterRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/nsxv-managers/{id}/controller-cluster",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "nsxControllerDataCollection",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateNsxvControllerClusterSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateNsxvControllerClusterResponse =
        new operations.UpdateNsxvControllerClusterResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.nsxControllerDataCollection = utils.objectToClass(
              httpRes?.data,
              shared.NSXControllerDataCollection
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update a nsx-v manager data source
   *
   * @remarks
   * Update a nsx-v manager data source
   */
  updateNsxvManager(
    req: operations.UpdateNsxvManagerRequest,
    security: operations.UpdateNsxvManagerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateNsxvManagerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateNsxvManagerRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/nsxv-managers/{id}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "nsxvManagerDataSource",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateNsxvManagerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateNsxvManagerResponse =
        new operations.UpdateNsxvManagerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.nsxvManagerDataSource = utils.objectToClass(
              httpRes?.data,
              shared.NSXVManagerDataSource
            );
          }
          break;
        case [401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update a panorama firewall data source
   *
   * @remarks
   * Update a panorama firewall data source
   */
  updatePanoramaFirewall(
    req: operations.UpdatePanoramaFirewallRequest,
    security: operations.UpdatePanoramaFirewallSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdatePanoramaFirewallResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdatePanoramaFirewallRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/panorama-firewalls/{id}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "switchDataSource",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdatePanoramaFirewallSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdatePanoramaFirewallResponse =
        new operations.UpdatePanoramaFirewallResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.switchDataSource = utils.objectToClass(
              httpRes?.data,
              shared.SwitchDataSource
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an ucs manager data source
   *
   * @remarks
   * Update an ucs manager data source
   */
  updateUcsManager(
    req: operations.UpdateUcsManagerRequest,
    security: operations.UpdateUcsManagerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateUcsManagerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateUcsManagerRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/ucs-managers/{id}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "switchDataSource",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateUcsManagerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateUcsManagerResponse =
        new operations.UpdateUcsManagerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.switchDataSource = utils.objectToClass(
              httpRes?.data,
              shared.SwitchDataSource
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update snmp config for ucs fabric interconnects
   *
   * @remarks
   * Update snmp config for ucs fabric interconnects
   */
  updateUcsSnmpConfig(
    req: operations.UpdateUcsSnmpConfigRequest,
    security: operations.UpdateUcsSnmpConfigSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateUcsSnmpConfigResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateUcsSnmpConfigRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/ucs-managers/{id}/snmp-config",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "snmpConfig",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateUcsSnmpConfigSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateUcsSnmpConfigResponse =
        new operations.UpdateUcsSnmpConfigResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.snmpConfig = utils.objectToClass(
              httpRes?.data,
              shared.SNMPConfig
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update a vCenter data source.
   *
   * @remarks
   * Update a vcenter data source. Only nickname, notes and credentials can be updated.
   */
  updateVcenter(
    req: operations.UpdateVcenterRequest,
    security: operations.UpdateVcenterSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateVcenterResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateVcenterRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/data-sources/vcenters/{id}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "vCenterDataSource",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateVcenterSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateVcenterResponse =
        new operations.UpdateVcenterResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.vCenterDataSource = utils.objectToClass(
              httpRes?.data,
              shared.VCenterDataSource
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 403, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }
}
