// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package sdk

import (
	"context"
	"fmt"
	"net/http"
	"openapi/pkg/models/operations"
	"openapi/pkg/models/shared"
	"openapi/pkg/utils"
)

// issueTracker - The issue resources provide functionality for getting information on
// issues in an issue tracker, creating new issues, updating them and deleting
// them.
//
// You can access public issues without authentication, but you can't gain access
// to private repositories' issues. By authenticating, you will get the ability
// to create issues, as well as access to updating data or deleting issues you
// have access to.
type issueTracker struct {
	defaultClient  HTTPClient
	securityClient HTTPClient
	serverURL      string
	language       string
	sdkVersion     string
	genVersion     string
}

func newIssueTracker(defaultClient, securityClient HTTPClient, serverURL, language, sdkVersion, genVersion string) *issueTracker {
	return &issueTracker{
		defaultClient:  defaultClient,
		securityClient: securityClient,
		serverURL:      serverURL,
		language:       language,
		sdkVersion:     sdkVersion,
		genVersion:     genVersion,
	}
}

// DeleteRepositoriesWorkspaceRepoSlugIssuesIssueID - Delete an issue
// Deletes the specified issue. This requires write access to the
// repository.
func (s *issueTracker) DeleteRepositoriesWorkspaceRepoSlugIssuesIssueID(ctx context.Context, request operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIDRequest) (*operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIDResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/issues/{issue_id}", request.PathParams, nil)

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, request.Security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Issue = out
		}
	case httpRes.StatusCode == 403:
		fallthrough
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIDAttachmentsPath - Delete an attachment for an issue
// Deletes an attachment.
func (s *issueTracker) DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIDAttachmentsPath(ctx context.Context, request operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIDAttachmentsPathRequest) (*operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIDAttachmentsPathResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/attachments/{path}", request.PathParams, nil)

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, request.Security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIDAttachmentsPathResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
		fallthrough
	case httpRes.StatusCode == 401:
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIDCommentsCommentID - Delete a comment on an issue
// Deletes the specified comment.
func (s *issueTracker) DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIDCommentsCommentID(ctx context.Context, request operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIDCommentsCommentIDRequest) (*operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIDCommentsCommentIDResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/comments/{comment_id}", request.PathParams, nil)

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, request.Security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIDCommentsCommentIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
	}

	return res, nil
}

// DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIDVote - Remove vote for an issue
// Retract your vote.
func (s *issueTracker) DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIDVote(ctx context.Context, request operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIDVoteRequest) (*operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIDVoteResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/vote", request.PathParams, nil)

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, request.Security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIDVoteResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	default:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIDWatch - Stop watching an issue
// Stop watching this issue.
func (s *issueTracker) DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIDWatch(ctx context.Context, request operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIDWatchRequest) (*operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIDWatchResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/watch", request.PathParams, nil)

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, request.Security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIDWatchResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
		fallthrough
	case httpRes.StatusCode == 401:
		fallthrough
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// GetRepositoriesWorkspaceRepoSlugComponents - List components
// Returns the components that have been defined in the issue tracker.
//
// This resource is only available on repositories that have the issue
// tracker enabled.
func (s *issueTracker) GetRepositoriesWorkspaceRepoSlugComponents(ctx context.Context, request operations.GetRepositoriesWorkspaceRepoSlugComponentsRequest) (*operations.GetRepositoriesWorkspaceRepoSlugComponentsResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/components", request.PathParams, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, request.Security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetRepositoriesWorkspaceRepoSlugComponentsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PaginatedComponents
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PaginatedComponents = out
		}
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// GetRepositoriesWorkspaceRepoSlugComponentsComponentID - Get a component for issues
// Returns the specified issue tracker component object.
func (s *issueTracker) GetRepositoriesWorkspaceRepoSlugComponentsComponentID(ctx context.Context, request operations.GetRepositoriesWorkspaceRepoSlugComponentsComponentIDRequest) (*operations.GetRepositoriesWorkspaceRepoSlugComponentsComponentIDResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/components/{component_id}", request.PathParams, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, request.Security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetRepositoriesWorkspaceRepoSlugComponentsComponentIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Component = out
		}
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// GetRepositoriesWorkspaceRepoSlugIssues - List issues
// Returns the issues in the issue tracker.
func (s *issueTracker) GetRepositoriesWorkspaceRepoSlugIssues(ctx context.Context, request operations.GetRepositoriesWorkspaceRepoSlugIssuesRequest) (*operations.GetRepositoriesWorkspaceRepoSlugIssuesResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/issues", request.PathParams, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, request.Security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetRepositoriesWorkspaceRepoSlugIssuesResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PaginatedIssues
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PaginatedIssues = out
		}
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// GetRepositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIDZip - Check issue export status
// This endpoint is used to poll for the progress of an issue export
// job and return the zip file after the job is complete.
// As long as the job is running, this will return a 200 response
// with in the response body a description of the current status.
//
// After the job has been scheduled, but before it starts executing, this
// endpoint's response is:
//
//	{
//	 "type": "issue_job_status",
//	 "status": "ACCEPTED",
//	 "phase": "Initializing",
//	 "total": 0,
//	 "count": 0,
//	 "pct": 0
//	}
//
// Then once it starts running, it becomes:
//
//	{
//	 "type": "issue_job_status",
//	 "status": "STARTED",
//	 "phase": "Attachments",
//	 "total": 15,
//	 "count": 11,
//	 "pct": 73
//	}
//
// Once the job has successfully completed, it returns a stream of the zip file.
func (s *issueTracker) GetRepositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIDZip(ctx context.Context, request operations.GetRepositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIDZipRequest) (*operations.GetRepositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIDZipResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/issues/export/{repo_name}-issues-{task_id}.zip", request.PathParams, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, request.Security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetRepositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIDZipResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 202:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.IssueJobStatus
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.IssueJobStatus = out
		}
	case httpRes.StatusCode == 401:
		fallthrough
	case httpRes.StatusCode == 403:
		fallthrough
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// GetRepositoriesWorkspaceRepoSlugIssuesImport - Check issue import status
// When using GET, this endpoint reports the status of the current import task. Request example:
//
// ```
// $ curl -u <username> -X GET https://api.bitbucket.org/2.0/repositories/<owner_username>/<repo_slug>/issues/import
// ```
//
// After the job has been scheduled, but before it starts executing, this endpoint's response is:
//
// ```
// < HTTP/1.1 202 Accepted
//
//	{
//	    "type": "issue_job_status",
//	    "status": "PENDING",
//	    "phase": "Attachments",
//	    "total": 15,
//	    "count": 0,
//	    "percent": 0
//	}
//
// ```
//
// Once it starts running, it is a 202 response with status STARTED and progress filled.
//
// After it is finished, it becomes a 200 response with status SUCCESS or FAILURE.
func (s *issueTracker) GetRepositoriesWorkspaceRepoSlugIssuesImport(ctx context.Context, request operations.GetRepositoriesWorkspaceRepoSlugIssuesImportRequest) (*operations.GetRepositoriesWorkspaceRepoSlugIssuesImportResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/issues/import", request.PathParams, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, request.Security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetRepositoriesWorkspaceRepoSlugIssuesImportResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		fallthrough
	case httpRes.StatusCode == 202:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.IssueJobStatus
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.IssueJobStatus = out
		}
	case httpRes.StatusCode == 401:
		fallthrough
	case httpRes.StatusCode == 403:
		fallthrough
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// GetRepositoriesWorkspaceRepoSlugIssuesIssueID - Get an issue
// Returns the specified issue.
func (s *issueTracker) GetRepositoriesWorkspaceRepoSlugIssuesIssueID(ctx context.Context, request operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDRequest) (*operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/issues/{issue_id}", request.PathParams, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, request.Security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Issue = out
		}
	case httpRes.StatusCode == 403:
		fallthrough
	case httpRes.StatusCode == 404:
		fallthrough
	case httpRes.StatusCode == 410:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// GetRepositoriesWorkspaceRepoSlugIssuesIssueIDAttachments - List attachments for an issue
// Returns all attachments for this issue.
//
// This returns the files' meta data. This does not return the files'
// actual contents.
//
// The files are always ordered by their upload date.
func (s *issueTracker) GetRepositoriesWorkspaceRepoSlugIssuesIssueIDAttachments(ctx context.Context, request operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDAttachmentsRequest) (*operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDAttachmentsResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/attachments", request.PathParams, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, request.Security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDAttachmentsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PaginatedIssueAttachments
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PaginatedIssueAttachments = out
		}
	case httpRes.StatusCode == 401:
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// GetRepositoriesWorkspaceRepoSlugIssuesIssueIDAttachmentsPath - Get attachment for an issue
// Returns the contents of the specified file attachment.
//
// Note that this endpoint does not return a JSON response, but instead
// returns a redirect pointing to the actual file that in turn will return
// the raw contents.
//
// The redirect URL contains a one-time token that has a limited lifetime.
// As a result, the link should not be persisted, stored, or shared.
func (s *issueTracker) GetRepositoriesWorkspaceRepoSlugIssuesIssueIDAttachmentsPath(ctx context.Context, request operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDAttachmentsPathRequest) (*operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDAttachmentsPathResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/attachments/{path}", request.PathParams, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, request.Security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDAttachmentsPathResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 302:
		res.Headers = httpRes.Header

	case httpRes.StatusCode == 401:
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// GetRepositoriesWorkspaceRepoSlugIssuesIssueIDChanges - List changes on an issue
// Returns the list of all changes that have been made to the specified
// issue. Changes are returned in chronological order with the oldest
// change first.
//
// Each time an issue is edited in the UI or through the API, an immutable
// change record is created under the `/issues/123/changes` endpoint. It
// also has a comment associated with the change.
//
// Note that this operation is changing significantly, due to privacy changes.
// See the [announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#changes-to-the-issue-changes-api)
// for details.
//
// ```
// $ curl -s https://api.bitbucket.org/2.0/repositories/evzijst/dogslow/issues/1/changes - | jq .
//
//	{
//	  "pagelen": 20,
//	  "values": [
//	    {
//	      "changes": {
//	        "priority": {
//	          "new": "trivial",
//	          "old": "major"
//	        },
//	        "assignee": {
//	          "new": "",
//	          "old": "evzijst"
//	        },
//	        "assignee_account_id": {
//	          "new": "",
//	          "old": "557058:c0b72ad0-1cb5-4018-9cdc-0cde8492c443"
//	        },
//	        "kind": {
//	          "new": "enhancement",
//	          "old": "bug"
//	        }
//	      },
//	      "links": {
//	        "self": {
//	          "href": "https://api.bitbucket.org/2.0/repositories/evzijst/dogslow/issues/1/changes/2"
//	        },
//	        "html": {
//	          "href": "https://bitbucket.org/evzijst/dogslow/issues/1#comment-2"
//	        }
//	      },
//	      "issue": {
//	        "links": {
//	          "self": {
//	            "href": "https://api.bitbucket.org/2.0/repositories/evzijst/dogslow/issues/1"
//	          }
//	        },
//	        "type": "issue",
//	        "id": 1,
//	        "repository": {
//	          "links": {
//	            "self": {
//	              "href": "https://api.bitbucket.org/2.0/repositories/evzijst/dogslow"
//	            },
//	            "html": {
//	              "href": "https://bitbucket.org/evzijst/dogslow"
//	            },
//	            "avatar": {
//	              "href": "https://bitbucket.org/evzijst/dogslow/avatar/32/"
//	            }
//	          },
//	          "type": "repository",
//	          "name": "dogslow",
//	          "full_name": "evzijst/dogslow",
//	          "uuid": "{988b17c6-1a47-4e70-84ee-854d5f012bf6}"
//	        },
//	        "title": "Updated title"
//	      },
//	      "created_on": "2018-03-03T00:35:28.353630+00:00",
//	      "user": {
//	        "username": "evzijst",
//	        "nickname": "evzijst",
//	        "display_name": "evzijst",
//	        "type": "user",
//	        "uuid": "{aaa7972b-38af-4fb1-802d-6e3854c95778}",
//	        "links": {
//	          "self": {
//	            "href": "https://api.bitbucket.org/2.0/users/evzijst"
//	          },
//	          "html": {
//	            "href": "https://bitbucket.org/evzijst/"
//	          },
//	          "avatar": {
//	            "href": "https://bitbucket.org/account/evzijst/avatar/32/"
//	          }
//	        }
//	      },
//	      "message": {
//	        "raw": "Removed assignee, changed kind and priority.",
//	        "markup": "markdown",
//	        "html": "<p>Removed assignee, changed kind and priority.</p>",
//	        "type": "rendered"
//	      },
//	      "type": "issue_change",
//	      "id": 2
//	    }
//	  ],
//	  "page": 1
//	}
//
// ```
//
// Changes support [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) that
// can be used to search for specific changes. For instance, to see
// when an issue transitioned to "resolved":
//
// ```
//
//	$ curl -s https://api.bitbucket.org/2.0/repositories/site/master/issues/1/changes \
//	   -G --data-urlencode='q=changes.state.new = "resolved"'
//
// ```
//
// This resource is only available on repositories that have the issue
// tracker enabled.
//
// N.B.
//
// The `changes.assignee` and `changes.assignee_account_id` fields are not
// a `user` object. Instead, they contain the raw `username` and
// `account_id` of the user. This is to protect the integrity of the audit
// log even after a user account gets deleted.
//
// The `changes.assignee` field is deprecated will disappear in the
// future. Use `changes.assignee_account_id` instead.
func (s *issueTracker) GetRepositoriesWorkspaceRepoSlugIssuesIssueIDChanges(ctx context.Context, request operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDChangesRequest) (*operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDChangesResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/changes", request.PathParams, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request.QueryParams, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, request.Security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDChangesResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PaginatedLogEntries
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PaginatedLogEntries = out
		}
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// GetRepositoriesWorkspaceRepoSlugIssuesIssueIDChangesChangeID - Get issue change object
// Returns the specified issue change object.
//
// This resource is only available on repositories that have the issue
// tracker enabled.
func (s *issueTracker) GetRepositoriesWorkspaceRepoSlugIssuesIssueIDChangesChangeID(ctx context.Context, request operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDChangesChangeIDRequest) (*operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDChangesChangeIDResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/changes/{change_id}", request.PathParams, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, request.Security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDChangesChangeIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.IssueChange = out
		}
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// GetRepositoriesWorkspaceRepoSlugIssuesIssueIDComments - List comments on an issue
// Returns a paginated list of all comments that were made on the
// specified issue.
//
// The default sorting is oldest to newest and can be overridden with
// the `sort` query parameter.
//
// This endpoint also supports filtering and sorting of the results. See
// [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
func (s *issueTracker) GetRepositoriesWorkspaceRepoSlugIssuesIssueIDComments(ctx context.Context, request operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDCommentsRequest) (*operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDCommentsResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/comments", request.PathParams, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request.QueryParams, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, request.Security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDCommentsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PaginatedIssueComments
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PaginatedIssueComments = out
		}
	}

	return res, nil
}

// GetRepositoriesWorkspaceRepoSlugIssuesIssueIDCommentsCommentID - Get a comment on an issue
// Returns the specified issue comment object.
func (s *issueTracker) GetRepositoriesWorkspaceRepoSlugIssuesIssueIDCommentsCommentID(ctx context.Context, request operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDCommentsCommentIDRequest) (*operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDCommentsCommentIDResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/comments/{comment_id}", request.PathParams, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, request.Security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDCommentsCommentIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.IssueComment = out
		}
	}

	return res, nil
}

// GetRepositoriesWorkspaceRepoSlugIssuesIssueIDVote - Check if current user voted for an issue
// Check whether the authenticated user has voted for this issue.
// A 204 status code indicates that the user has voted, while a 404
// implies they haven't.
func (s *issueTracker) GetRepositoriesWorkspaceRepoSlugIssuesIssueIDVote(ctx context.Context, request operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDVoteRequest) (*operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDVoteResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/vote", request.PathParams, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, request.Security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDVoteResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
		fallthrough
	case httpRes.StatusCode == 401:
		fallthrough
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// GetRepositoriesWorkspaceRepoSlugIssuesIssueIDWatch - Check if current user is watching a issue
// Indicated whether or not the authenticated user is watching this
// issue.
func (s *issueTracker) GetRepositoriesWorkspaceRepoSlugIssuesIssueIDWatch(ctx context.Context, request operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDWatchRequest) (*operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDWatchResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/watch", request.PathParams, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, request.Security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDWatchResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
		fallthrough
	case httpRes.StatusCode == 401:
		fallthrough
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// GetRepositoriesWorkspaceRepoSlugMilestones - List milestones
// Returns the milestones that have been defined in the issue tracker.
//
// This resource is only available on repositories that have the issue
// tracker enabled.
func (s *issueTracker) GetRepositoriesWorkspaceRepoSlugMilestones(ctx context.Context, request operations.GetRepositoriesWorkspaceRepoSlugMilestonesRequest) (*operations.GetRepositoriesWorkspaceRepoSlugMilestonesResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/milestones", request.PathParams, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, request.Security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetRepositoriesWorkspaceRepoSlugMilestonesResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PaginatedMilestones
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PaginatedMilestones = out
		}
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// GetRepositoriesWorkspaceRepoSlugMilestonesMilestoneID - Get a milestone
// Returns the specified issue tracker milestone object.
func (s *issueTracker) GetRepositoriesWorkspaceRepoSlugMilestonesMilestoneID(ctx context.Context, request operations.GetRepositoriesWorkspaceRepoSlugMilestonesMilestoneIDRequest) (*operations.GetRepositoriesWorkspaceRepoSlugMilestonesMilestoneIDResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/milestones/{milestone_id}", request.PathParams, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, request.Security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetRepositoriesWorkspaceRepoSlugMilestonesMilestoneIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Milestone = out
		}
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// GetRepositoriesWorkspaceRepoSlugVersions - List defined versions for issues
// Returns the versions that have been defined in the issue tracker.
//
// This resource is only available on repositories that have the issue
// tracker enabled.
func (s *issueTracker) GetRepositoriesWorkspaceRepoSlugVersions(ctx context.Context, request operations.GetRepositoriesWorkspaceRepoSlugVersionsRequest) (*operations.GetRepositoriesWorkspaceRepoSlugVersionsResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/versions", request.PathParams, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, request.Security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetRepositoriesWorkspaceRepoSlugVersionsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.PaginatedVersions
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PaginatedVersions = out
		}
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// GetRepositoriesWorkspaceRepoSlugVersionsVersionID - Get a defined version for issues
// Returns the specified issue tracker version object.
func (s *issueTracker) GetRepositoriesWorkspaceRepoSlugVersionsVersionID(ctx context.Context, request operations.GetRepositoriesWorkspaceRepoSlugVersionsVersionIDRequest) (*operations.GetRepositoriesWorkspaceRepoSlugVersionsVersionIDResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/versions/{version_id}", request.PathParams, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, request.Security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetRepositoriesWorkspaceRepoSlugVersionsVersionIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Version = out
		}
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// PostRepositoriesWorkspaceRepoSlugIssues - Create an issue
// Creates a new issue.
//
// This call requires authentication. Private repositories or private
// issue trackers require the caller to authenticate with an account that
// has appropriate authorization.
//
// The authenticated user is used for the issue's `reporter` field.
func (s *issueTracker) PostRepositoriesWorkspaceRepoSlugIssues(ctx context.Context, request operations.PostRepositoriesWorkspaceRepoSlugIssuesRequest) (*operations.PostRepositoriesWorkspaceRepoSlugIssuesResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/issues", request.PathParams, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "Request", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s.defaultClient, request.Security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostRepositoriesWorkspaceRepoSlugIssuesResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Issue = out
		}
	case httpRes.StatusCode == 401:
		fallthrough
	case httpRes.StatusCode == 403:
		fallthrough
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// PostRepositoriesWorkspaceRepoSlugIssuesExport - Export issues
// A POST request to this endpoint initiates a new background celery task that archives the repo's issues.
//
// For example, you can run:
//
// curl -u <username> -X POST http://api.bitbucket.org/2.0/repositories/<owner_username>/<repo_slug>/
// issues/export
//
// When the job has been accepted, it will return a 202 (Accepted) along with a unique url to this job in the
// 'Location' response header. This url is the endpoint for where the user can obtain their zip files."
func (s *issueTracker) PostRepositoriesWorkspaceRepoSlugIssuesExport(ctx context.Context, request operations.PostRepositoriesWorkspaceRepoSlugIssuesExportRequest) (*operations.PostRepositoriesWorkspaceRepoSlugIssuesExportResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/issues/export", request.PathParams, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "Request", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s.defaultClient, request.Security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostRepositoriesWorkspaceRepoSlugIssuesExportResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 202:
	case httpRes.StatusCode == 401:
		fallthrough
	case httpRes.StatusCode == 403:
		fallthrough
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// PostRepositoriesWorkspaceRepoSlugIssuesImport - Import issues
// A POST request to this endpoint will import the zip file given by the archive parameter into the repository. All
// existing issues will be deleted and replaced by the contents of the imported zip file.
//
// Imports are done through a multipart/form-data POST. There is one valid and required form field, with the name
// "archive," which needs to be a file field:
//
// ```
// $ curl -u <username> -X POST -F archive=@/path/to/file.zip https://api.bitbucket.org/2.0/repositories/<owner_username>/<repo_slug>/issues/import
// ```
//
// When the import job is accepted, here is example output:
//
// ```
// < HTTP/1.1 202 Accepted
//
//	{
//	    "type": "issue_job_status",
//	    "status": "ACCEPTED",
//	    "phase": "Attachments",
//	    "total": 15,
//	    "count": 0,
//	    "percent": 0
//	}
//
// ```
func (s *issueTracker) PostRepositoriesWorkspaceRepoSlugIssuesImport(ctx context.Context, request operations.PostRepositoriesWorkspaceRepoSlugIssuesImportRequest) (*operations.PostRepositoriesWorkspaceRepoSlugIssuesImportResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/issues/import", request.PathParams, nil)

	req, err := http.NewRequestWithContext(ctx, "POST", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, request.Security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostRepositoriesWorkspaceRepoSlugIssuesImportResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 202:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.IssueJobStatus
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.IssueJobStatus = out
		}
	case httpRes.StatusCode == 401:
		fallthrough
	case httpRes.StatusCode == 403:
		fallthrough
	case httpRes.StatusCode == 404:
		fallthrough
	case httpRes.StatusCode == 409:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// PostRepositoriesWorkspaceRepoSlugIssuesIssueIDAttachments - Upload an attachment to an issue
// Upload new issue attachments.
//
// To upload files, perform a `multipart/form-data` POST containing one
// or more file fields.
//
// When a file is uploaded with the same name as an existing attachment,
// then the existing file will be replaced.
func (s *issueTracker) PostRepositoriesWorkspaceRepoSlugIssuesIssueIDAttachments(ctx context.Context, request operations.PostRepositoriesWorkspaceRepoSlugIssuesIssueIDAttachmentsRequest) (*operations.PostRepositoriesWorkspaceRepoSlugIssuesIssueIDAttachmentsResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/attachments", request.PathParams, nil)

	req, err := http.NewRequestWithContext(ctx, "POST", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, request.Security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostRepositoriesWorkspaceRepoSlugIssuesIssueIDAttachmentsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

	case httpRes.StatusCode == 400:
		fallthrough
	case httpRes.StatusCode == 401:
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// PostRepositoriesWorkspaceRepoSlugIssuesIssueIDChanges - Modify the state of an issue
// Makes a change to the specified issue.
//
// For example, to change an issue's state and assignee, create a new
// change object that modifies these fields:
//
// ```
//
//	curl https://api.bitbucket.org/2.0/site/master/issues/1234/changes \
//	  -s -u evzijst -X POST -H "Content-Type: application/json" \
//	  -d '{
//	    "changes": {
//	      "assignee_account_id": {
//	        "new": "557058:c0b72ad0-1cb5-4018-9cdc-0cde8492c443"
//	      },
//	      "state": {
//	        "new": 'resolved"
//	      }
//	    }
//	    "message": {
//	      "raw": "This is now resolved."
//	    }
//	  }'
//
// ```
//
// The above example also includes a custom comment to go alongside the
// change. This comment will also be visible on the issue page in the UI.
//
// The fields of the `changes` object are strings, not objects. This
// allows for immutable change log records, even after user accounts,
// milestones, or other objects recorded in a change entry, get renamed or
// deleted.
//
// The `assignee_account_id` field stores the account id. When POSTing a
// new change and changing the assignee, the client should therefore use
// the user's account_id in the `changes.assignee_account_id.new` field.
//
// This call requires authentication. Private repositories or private
// issue trackers require the caller to authenticate with an account that
// has appropriate authorization.
func (s *issueTracker) PostRepositoriesWorkspaceRepoSlugIssuesIssueIDChanges(ctx context.Context, request operations.PostRepositoriesWorkspaceRepoSlugIssuesIssueIDChangesRequest) (*operations.PostRepositoriesWorkspaceRepoSlugIssuesIssueIDChangesResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/changes", request.PathParams, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "Request", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s.defaultClient, request.Security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostRepositoriesWorkspaceRepoSlugIssuesIssueIDChangesResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.IssueChange = out
		}
	case httpRes.StatusCode == 401:
		fallthrough
	case httpRes.StatusCode == 403:
		fallthrough
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// PostRepositoriesWorkspaceRepoSlugIssuesIssueIDComments - Create a comment on an issue
// Creates a new issue comment.
//
// ```
//
//	$ curl https://api.bitbucket.org/2.0/repositories/atlassian/prlinks/issues/42/comments/ \
//	  -X POST -u evzijst \
//	  -H 'Content-Type: application/json' \
//	  -d '{"content": {"raw": "Lorem ipsum."}}'
//
// ```
func (s *issueTracker) PostRepositoriesWorkspaceRepoSlugIssuesIssueIDComments(ctx context.Context, request operations.PostRepositoriesWorkspaceRepoSlugIssuesIssueIDCommentsRequest) (*operations.PostRepositoriesWorkspaceRepoSlugIssuesIssueIDCommentsResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/comments", request.PathParams, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "Request", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s.defaultClient, request.Security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostRepositoriesWorkspaceRepoSlugIssuesIssueIDCommentsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		res.Headers = httpRes.Header

	case httpRes.StatusCode == 400:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// PutRepositoriesWorkspaceRepoSlugIssuesIssueID - Update an issue
// Modifies the issue.
//
// ```
//
//	$ curl https://api.bitbucket.org/2.0/repostories/evzijst/dogslow/issues/123 \
//	  -u evzijst -s -X PUT -H 'Content-Type: application/json' \
//	  -d '{
//	  "title": "Updated title",
//	  "assignee": {
//	    "account_id": "5d5355e8c6b9320d9ea5b28d"
//	  },
//	  "priority": "minor",
//	  "version": {
//	    "name": "1.0"
//	  },
//	  "component": null
//	}'
//
// ```
//
// This example changes the `title`, `assignee`, `priority` and the
// `version`. It also removes the value of the `component` from the issue
// by setting the field to `null`. Any field not present keeps its existing
// value.
//
// Each time an issue is edited in the UI or through the API, an immutable
// change record is created under the `/issues/123/changes` endpoint. It
// also has a comment associated with the change.
func (s *issueTracker) PutRepositoriesWorkspaceRepoSlugIssuesIssueID(ctx context.Context, request operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIDRequest) (*operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIDResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/issues/{issue_id}", request.PathParams, nil)

	req, err := http.NewRequestWithContext(ctx, "PUT", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, request.Security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Issue = out
		}
	case httpRes.StatusCode == 403:
		fallthrough
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// PutRepositoriesWorkspaceRepoSlugIssuesIssueIDCommentsCommentID - Update a comment on an issue
// Updates the content of the specified issue comment. Note that only
// the `content.raw` field can be modified.
//
// ```
//
//	$ curl https://api.bitbucket.org/2.0/repositories/atlassian/prlinks/issues/42/comments/5728901 \
//	  -X PUT -u evzijst \
//	  -H 'Content-Type: application/json' \
//	  -d '{"content": {"raw": "Lorem ipsum."}'
//
// ```
func (s *issueTracker) PutRepositoriesWorkspaceRepoSlugIssuesIssueIDCommentsCommentID(ctx context.Context, request operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIDCommentsCommentIDRequest) (*operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIDCommentsCommentIDResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/comments/{comment_id}", request.PathParams, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "Request", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "PUT", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := utils.ConfigureSecurityClient(s.defaultClient, request.Security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIDCommentsCommentIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.IssueComment = out
		}
	case httpRes.StatusCode == 400:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// PutRepositoriesWorkspaceRepoSlugIssuesIssueIDVote - Vote for an issue
// Vote for this issue.
//
// To cast your vote, do an empty PUT. The 204 status code indicates that
// the operation was successful.
func (s *issueTracker) PutRepositoriesWorkspaceRepoSlugIssuesIssueIDVote(ctx context.Context, request operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIDVoteRequest) (*operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIDVoteResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/vote", request.PathParams, nil)

	req, err := http.NewRequestWithContext(ctx, "PUT", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, request.Security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIDVoteResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
		fallthrough
	case httpRes.StatusCode == 401:
		fallthrough
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}

// PutRepositoriesWorkspaceRepoSlugIssuesIssueIDWatch - Watch an issue
// Start watching this issue.
//
// To start watching this issue, do an empty PUT. The 204 status code
// indicates that the operation was successful.
func (s *issueTracker) PutRepositoriesWorkspaceRepoSlugIssuesIssueIDWatch(ctx context.Context, request operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIDWatchRequest) (*operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIDWatchResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/watch", request.PathParams, nil)

	req, err := http.NewRequestWithContext(ctx, "PUT", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, request.Security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIDWatchResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 204:
		fallthrough
	case httpRes.StatusCode == 401:
		fallthrough
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]interface{}
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Error = out
		}
	}

	return res, nil
}
