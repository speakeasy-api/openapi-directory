/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Projects {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Constructs a new OAuth brand for the project if one does not exist. The created brand is "internal only", meaning that OAuth clients created under it only accept requests from users who belong to the same Google Workspace organization as the project. The brand is created in an un-reviewed status. NOTE: The "internal only" status can be manually changed in the Google Cloud Console. Requires that a brand does not already exist for the project, and that the specified support email is owned by the caller.
   */
  iapProjectsBrandsCreate(
    req: operations.IapProjectsBrandsCreateRequest,
    security: operations.IapProjectsBrandsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.IapProjectsBrandsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IapProjectsBrandsCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1/{parent}/brands", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "brandInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.IapProjectsBrandsCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IapProjectsBrandsCreateResponse =
        new operations.IapProjectsBrandsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.brand = utils.objectToClass(httpRes?.data, shared.Brand);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates an Identity Aware Proxy (IAP) OAuth client. The client is owned by IAP. Requires that the brand for the project exists and that it is set for internal-only use.
   */
  iapProjectsBrandsIdentityAwareProxyClientsCreate(
    req: operations.IapProjectsBrandsIdentityAwareProxyClientsCreateRequest,
    security: operations.IapProjectsBrandsIdentityAwareProxyClientsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.IapProjectsBrandsIdentityAwareProxyClientsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.IapProjectsBrandsIdentityAwareProxyClientsCreateRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{parent}/identityAwareProxyClients",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "identityAwareProxyClientInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.IapProjectsBrandsIdentityAwareProxyClientsCreateSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IapProjectsBrandsIdentityAwareProxyClientsCreateResponse =
        new operations.IapProjectsBrandsIdentityAwareProxyClientsCreateResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.identityAwareProxyClient = utils.objectToClass(
              httpRes?.data,
              shared.IdentityAwareProxyClient
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists the existing clients for the brand.
   */
  iapProjectsBrandsIdentityAwareProxyClientsList(
    req: operations.IapProjectsBrandsIdentityAwareProxyClientsListRequest,
    security: operations.IapProjectsBrandsIdentityAwareProxyClientsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.IapProjectsBrandsIdentityAwareProxyClientsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.IapProjectsBrandsIdentityAwareProxyClientsListRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{parent}/identityAwareProxyClients",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.IapProjectsBrandsIdentityAwareProxyClientsListSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IapProjectsBrandsIdentityAwareProxyClientsListResponse =
        new operations.IapProjectsBrandsIdentityAwareProxyClientsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listIdentityAwareProxyClientsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListIdentityAwareProxyClientsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Resets an Identity Aware Proxy (IAP) OAuth client secret. Useful if the secret was compromised. Requires that the client is owned by IAP.
   */
  iapProjectsBrandsIdentityAwareProxyClientsResetSecret(
    req: operations.IapProjectsBrandsIdentityAwareProxyClientsResetSecretRequest,
    security: operations.IapProjectsBrandsIdentityAwareProxyClientsResetSecretSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.IapProjectsBrandsIdentityAwareProxyClientsResetSecretResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.IapProjectsBrandsIdentityAwareProxyClientsResetSecretRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{name}:resetSecret",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.IapProjectsBrandsIdentityAwareProxyClientsResetSecretSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IapProjectsBrandsIdentityAwareProxyClientsResetSecretResponse =
        new operations.IapProjectsBrandsIdentityAwareProxyClientsResetSecretResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.identityAwareProxyClient = utils.objectToClass(
              httpRes?.data,
              shared.IdentityAwareProxyClient
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists the existing brands for the project.
   */
  iapProjectsBrandsList(
    req: operations.IapProjectsBrandsListRequest,
    security: operations.IapProjectsBrandsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.IapProjectsBrandsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IapProjectsBrandsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1/{parent}/brands", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.IapProjectsBrandsListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IapProjectsBrandsListResponse =
        new operations.IapProjectsBrandsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listBrandsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListBrandsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a new TunnelDestGroup.
   */
  iapProjectsIapTunnelLocationsDestGroupsCreate(
    req: operations.IapProjectsIapTunnelLocationsDestGroupsCreateRequest,
    security: operations.IapProjectsIapTunnelLocationsDestGroupsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.IapProjectsIapTunnelLocationsDestGroupsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IapProjectsIapTunnelLocationsDestGroupsCreateRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{parent}/destGroups",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "tunnelDestGroup",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.IapProjectsIapTunnelLocationsDestGroupsCreateSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IapProjectsIapTunnelLocationsDestGroupsCreateResponse =
        new operations.IapProjectsIapTunnelLocationsDestGroupsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tunnelDestGroup = utils.objectToClass(
              httpRes?.data,
              shared.TunnelDestGroup
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes a TunnelDestGroup.
   */
  iapProjectsIapTunnelLocationsDestGroupsDelete(
    req: operations.IapProjectsIapTunnelLocationsDestGroupsDeleteRequest,
    security: operations.IapProjectsIapTunnelLocationsDestGroupsDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.IapProjectsIapTunnelLocationsDestGroupsDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IapProjectsIapTunnelLocationsDestGroupsDeleteRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1/{name}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.IapProjectsIapTunnelLocationsDestGroupsDeleteSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IapProjectsIapTunnelLocationsDestGroupsDeleteResponse =
        new operations.IapProjectsIapTunnelLocationsDestGroupsDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.empty = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves an existing TunnelDestGroup.
   */
  iapProjectsIapTunnelLocationsDestGroupsGet(
    req: operations.IapProjectsIapTunnelLocationsDestGroupsGetRequest,
    security: operations.IapProjectsIapTunnelLocationsDestGroupsGetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.IapProjectsIapTunnelLocationsDestGroupsGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IapProjectsIapTunnelLocationsDestGroupsGetRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1/{name}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.IapProjectsIapTunnelLocationsDestGroupsGetSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IapProjectsIapTunnelLocationsDestGroupsGetResponse =
        new operations.IapProjectsIapTunnelLocationsDestGroupsGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tunnelDestGroup = utils.objectToClass(
              httpRes?.data,
              shared.TunnelDestGroup
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists the existing TunnelDestGroups. To group across all locations, use a `-` as the location ID. For example: `/v1/projects/123/iap_tunnel/locations/-/destGroups`
   */
  iapProjectsIapTunnelLocationsDestGroupsList(
    req: operations.IapProjectsIapTunnelLocationsDestGroupsListRequest,
    security: operations.IapProjectsIapTunnelLocationsDestGroupsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.IapProjectsIapTunnelLocationsDestGroupsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IapProjectsIapTunnelLocationsDestGroupsListRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{parent}/destGroups",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.IapProjectsIapTunnelLocationsDestGroupsListSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IapProjectsIapTunnelLocationsDestGroupsListResponse =
        new operations.IapProjectsIapTunnelLocationsDestGroupsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listTunnelDestGroupsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListTunnelDestGroupsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates a TunnelDestGroup.
   */
  iapProjectsIapTunnelLocationsDestGroupsPatch(
    req: operations.IapProjectsIapTunnelLocationsDestGroupsPatchRequest,
    security: operations.IapProjectsIapTunnelLocationsDestGroupsPatchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.IapProjectsIapTunnelLocationsDestGroupsPatchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IapProjectsIapTunnelLocationsDestGroupsPatchRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1/{name}", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "tunnelDestGroup",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.IapProjectsIapTunnelLocationsDestGroupsPatchSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IapProjectsIapTunnelLocationsDestGroupsPatchResponse =
        new operations.IapProjectsIapTunnelLocationsDestGroupsPatchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tunnelDestGroup = utils.objectToClass(
              httpRes?.data,
              shared.TunnelDestGroup
            );
          }
          break;
      }

      return res;
    });
  }
}
