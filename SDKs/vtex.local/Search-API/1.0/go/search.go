// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package sdk

import (
	"context"
	"fmt"
	"net/http"
	"openapi/pkg/models/operations"
	"openapi/pkg/utils"
	"strings"
)

type search struct {
	defaultClient  HTTPClient
	securityClient HTTPClient
	serverURL      string
	language       string
	sdkVersion     string
	genVersion     string
}

func newSearch(defaultClient, securityClient HTTPClient, serverURL, language, sdkVersion, genVersion string) *search {
	return &search{
		defaultClient:  defaultClient,
		securityClient: securityClient,
		serverURL:      serverURL,
		language:       language,
		sdkVersion:     sdkVersion,
		genVersion:     genVersion,
	}
}

// ProductSearch - Search for Products
// Retrieves general information about the products related to the term searched.
// This is the main search used by the store. The user can type anything to be searched.
//
// For example, if they search for a "decanter", this is the URL: `https://{{accountName}}.{{environment}}.com.br/api/catalog_system/pub/products/search/decanter`.
//
// Note that maybe the response can be HTTP 200 or 206, 206 means that it's a partial content response.
//
// If it is a 206 take a look at the Headers, will be an entry called resources. E.g.: resources → 0-9/19. This means that the response is showing items from 0 to 9, 10 items, but there were 19 items found. See more information at the paging route example.
func (s *search) ProductSearch(ctx context.Context, request operations.ProductSearchRequest, opts ...operations.Option) (*operations.ProductSearchResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.ProductSearchServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url := utils.GenerateURL(ctx, baseURL, "/api/catalog_system/pub/products/search/{search}", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	utils.PopulateHeaders(ctx, req, request)

	client := s.securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ProductSearchResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []operations.ProductSearch200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.ProductSearch200ApplicationJSONObjects = out
		}
	}

	return res, nil
}

// ProductSearchFilteredandOrdered - Search for Products with Filter, Order and Pagination
// Retrieves general information about the store products. This information can be filtered and ordered by a number of options. It also can be paginated, filtered and ordered.
//
// ## Filters
//
// - **Filter by full text** - `ft={searchWord}`
// E.g.: `ft=television`
//
// - **Filter by category** - `fq=C:/{a}/{b}`
// `{a}` and `{b}` are Category IDs
// E.g.: `fq=C:/1000041/1000049/`
//
// - **Filter by brand** - `fq=B:/{a}/{b}`
// `{a}` and `{b}` are Brand IDs
// E.g.: `fq=B:/189385/189387/`
//
// - **Filter by specification** - `fq=specificationFilter_{a}:{b}`
// `{a}` is the specification ID
// `{b}` is the specification value
// E.g.: To filter products where the color is Blue, find the specification ID for color. Suppose it is 123, then the query will be: `fq=specificationFilter_123:Blue`
//
// - **Filter by price range** - `fq=P:[{a} TO {b}]`
// `{a}`  is the minimum price "from"
// `{b}` is the highest price "to"
// E.g.: `fq=P:[0 TO 20]` will search products between 0.00 and 20.00.
//
// - **Filter by collection** - `fq=productClusterIds:{{productClusterId}}`
// `productClusterId` is the same as `collectionId`
// For more information about collections, read [Creating a product collection](https://help.vtex.com/en/tutorial/creating-a-product-collection).
//
// - **Filter by product ID** - `fq=productId:{{productId}}`
//
// - **Filter by SKU ID** - `fq=skuId:{{skuId}}`
//
// - **Filter by referenceId** - `fq=alternateIds_RefId:{{referenceId}}`
//
// - **Filter by EAN13** - `fq=alternateIds_Ean:{{ean13}}`
//
// - **Filter by availability at a specific sales channel** - `fq=isAvailablePerSalesChannel_{{sc}}:{{bool}}`
// `{{sc}}` is the desired sales channel
// `{{bool}}` is true ou false, 1 or 0.
// E.g.: seaching available products for the sales channel 4 would be `fq=isAvailablePerSalesChannel_4:1`
//
// - **Filter by available at a specific seller** - `fq=sellerId:{{sellerId}}`
// The search does not include White Label Sellers.
//
// ## Pagination
//
// - **Initial item number** - `_from={{first}}`
// - **Final item number** - `_to={{last}}`
//
// >⚠️ This endpoint returns a maximum of 50 items per response, so the difference between `_from` and `_to` should not exceed this number. The result order is descending, from the highest product ID to the lowest.
//
// ## Sorting
//
// - **Price**
// `O=OrderByPriceDESC`
// `O=OrderByPriceASC`
//
// - **Top Selling Products**
// `O=OrderByTopSaleDESC`
//
// - **Best Reviews**
// `O=OrderByReviewRateDESC`
//
// - **Name**
// `O=OrderByNameASC`
// `O=OrderByNameDESC`
//
// - **Release Date**
// `O=OrderByReleaseDateDESC`
//
// - **Best Discounts**
// `O=OrderByBestDiscountDESC`
//
// - **Score**
// `O=OrderByScoreDESC`
func (s *search) ProductSearchFilteredandOrdered(ctx context.Context, request operations.ProductSearchFilteredandOrderedRequest, opts ...operations.Option) (*operations.ProductSearchFilteredandOrderedResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.ProductSearchFilteredandOrderedServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url := strings.TrimSuffix(baseURL, "/") + "/api/catalog_system/pub/products/search"

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	utils.PopulateHeaders(ctx, req, request)

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s.securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ProductSearchFilteredandOrderedResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []operations.ProductSearchFilteredandOrdered200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.ProductSearchFilteredandOrdered200ApplicationJSONObjects = out
		}
	}

	return res, nil
}

// Searchbyproducturl - Search Product by Product URL
// Retrieves general information about the product of the URL you searched for.
func (s *search) Searchbyproducturl(ctx context.Context, request operations.SearchbyproducturlRequest, opts ...operations.Option) (*operations.SearchbyproducturlResponse, error) {
	o := operations.Options{}
	supportedOptions := []string{
		operations.SupportedOptionServerURL,
	}

	for _, opt := range opts {
		if err := opt(&o, supportedOptions...); err != nil {
			return nil, fmt.Errorf("error applying option: %w", err)
		}
	}
	baseURL := operations.SearchbyproducturlServerList[0]
	if o.ServerURL != nil {
		baseURL = *o.ServerURL
	}

	url := utils.GenerateURL(ctx, baseURL, "/api/catalog_system/pub/products/search/{product-text-link}/p", request, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	utils.PopulateHeaders(ctx, req, request)

	client := s.securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.SearchbyproducturlResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []operations.Searchbyproducturl200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Searchbyproducturl200ApplicationJSONObjects = out
		}
	}

	return res, nil
}
