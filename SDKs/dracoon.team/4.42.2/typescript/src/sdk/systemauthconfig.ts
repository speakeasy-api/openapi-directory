/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * System settings (authentication methods)
 */
export class SystemAuthConfig {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Create Active Directory configuration
   *
   * @remarks
   * ### Description:
   * Create a new Active Directory configuration.
   *
   * ### Precondition:
   * Right <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; change global config</span> of the Provider Customer required.
   *
   * ### Postcondition:
   * New Active Directory configuration created.
   *
   * ### Further Information:
   * None.
   */
  createAdConfig(
    req: operations.CreateAdConfigRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateAdConfigResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateAdConfigRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/v4/system/config/auth/ads";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "createActiveDirectoryConfigRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateAdConfigResponse =
        new operations.CreateAdConfigResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.activeDirectoryConfig = utils.objectToClass(
              httpRes?.data,
              shared.ActiveDirectoryConfig
            );
          }
          break;
        case [400, 401, 403, 404, 406, 409, 412].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create OAuth client
   *
   * @remarks
   * ### Description:
   * Create a new OAuth client.
   *
   * ### Precondition:
   * Right <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; change global config</span> and
   * role <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128100; Config Manager</span> of the Provider Customer required.
   *
   * ### Postcondition:
   * New OAuth client created.
   *
   * ### Further Information:
   * Client secret **MUST** have:
   * * at least 12 characters, at most 32 characters
   * * only lower case characters, upper case characters and digits
   * * at least 1 lower case character, 1 upper case character and 1 digit
   *
   * The client secret is optional and will be generated if it is left empty.
   *
   * Valid grant types are:
   * * `authorization_code`
   * * `implicit`
   * * `password`
   * * `client_credentials`
   * * `refresh_token`
   *
   * Grant type `client_credentials` is currently **NOT** permitted!
   *
   * Allowed characters for client ID are: `[a-zA-Z0-9_-]`
   *
   * If grant types `authorization_code` or `implicit` are used, a
   * redirect URI **MUST** be provided!
   *
   * Default access token validity: **8 hours**
   * Default refresh token validity: **30 days**
   * Default approval validity: **Â½ year**
   */
  createOAuthClient(
    req: operations.CreateOAuthClientRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateOAuthClientResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateOAuthClientRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/v4/system/config/oauth/clients";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "createOAuthClientRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateOAuthClientResponse =
        new operations.CreateOAuthClientResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.oAuthClient = utils.objectToClass(
              httpRes?.data,
              shared.OAuthClient
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.createOAuthClient400ApplicationJSONOneOf = httpRes?.data;
          }
          break;
        case [401, 403, 406, 409, 412].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create OpenID Connect IDP configuration
   *
   * @remarks
   * ### Description:
   * Create new OpenID Connect IDP configuration.
   *
   * ### Precondition:
   * Right <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; change global config</span> and
   * role <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128100; Config Manager</span> of the Provider Customer required.
   *
   * ### Postcondition:
   * New OpenID Connect IDP configuration is created.
   *
   * ### Further Information:
   * None.
   *
   * @see {@link http://openid.net/developers/specs} - OpenID Specifications
   */
  createOpenIdIdpConfig(
    req: operations.CreateOpenIdIdpConfigRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateOpenIdIdpConfigResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateOpenIdIdpConfigRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/v4/system/config/auth/openid/idps";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "createOpenIdIdpConfigRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateOpenIdIdpConfigResponse =
        new operations.CreateOpenIdIdpConfigResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.openIdIdpConfig = utils.objectToClass(
              httpRes?.data,
              shared.OpenIdIdpConfig
            );
          }
          break;
        case [400, 401, 403, 404, 406, 409, 412].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create RADIUS configuration
   *
   * @remarks
   * ### Description:
   * Create new RADIUS configuration.
   *
   * ### Precondition:
   * Right <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; change global config</span> and
   * role <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128100; Config Manager</span> of the Provider Customer required.
   *
   * ### Postcondition:
   * New RADIUS configuration is created.
   *
   * ### Further Information:
   * None.
   */
  createRadiusConfig(
    req: operations.CreateRadiusConfigRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateRadiusConfigResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateRadiusConfigRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/v4/system/config/auth/radius";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "radiusConfigCreateRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateRadiusConfigResponse =
        new operations.CreateRadiusConfigResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.radiusConfig = utils.objectToClass(
              httpRes?.data,
              shared.RadiusConfig
            );
          }
          break;
        case [400, 401, 403, 406, 409, 412].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Remove Active Directory configuration
   *
   * @remarks
   * ### Description:
   * Delete an existing Active Directory configuration.
   *
   * ### Precondition:
   * Right <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; change global config</span> of the Provider Customer required.
   *
   * ### Postcondition:
   * Active Directory configuration is removed.
   *
   * ### Further Information:
   * None.
   */
  removeAdConfig(
    req: operations.RemoveAdConfigRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RemoveAdConfigResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RemoveAdConfigRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v4/system/config/auth/ads/{ad_id}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RemoveAdConfigResponse =
        new operations.RemoveAdConfigResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        case [400, 401, 403, 404, 406, 409, 412].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Remove OAuth client
   *
   * @remarks
   * ### Description:
   * Delete an existing OAuth client.
   *
   * ### Precondition:
   * Right <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; change global config</span> and
   * role <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128100; Config Manager</span> of the Provider Customer required.
   *
   * ### Postcondition:
   * OAuth client is removed.
   *
   * ### Further Information:
   * None.
   */
  removeOAuthClient(
    req: operations.RemoveOAuthClientRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RemoveOAuthClientResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RemoveOAuthClientRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v4/system/config/oauth/clients/{client_id}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RemoveOAuthClientResponse =
        new operations.RemoveOAuthClientResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        case [400, 401, 403, 404, 406, 412].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Remove OpenID Connect IDP configuration
   *
   * @remarks
   * ### Description:
   * Delete an existing OpenID Connect IDP configuration.
   *
   * ### Precondition:
   * Right <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; change global config</span> and
   * role <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128100; Config Manager</span> of the Provider Customer required.
   *
   * ### Postcondition:
   * OpenID Connect IDP configuration is removed.
   *
   * ### Further Information:
   * None.
   *
   * @see {@link http://openid.net/developers/specs} - OpenID Specifications
   */
  removeOpenIdIdpConfig(
    req: operations.RemoveOpenIdIdpConfigRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RemoveOpenIdIdpConfigResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RemoveOpenIdIdpConfigRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v4/system/config/auth/openid/idps/{idp_id}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RemoveOpenIdIdpConfigResponse =
        new operations.RemoveOpenIdIdpConfigResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        case [400, 401, 403, 404, 406, 409, 412].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Remove RADIUS configuration
   *
   * @remarks
   * ### Description:
   * Delete existing RADIUS configuration.
   *
   * ### Precondition:
   * Right <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; change global config</span> and
   * role <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128100; Config Manager</span> of the Provider Customer required.
   *
   * ### Postcondition:
   * RADIUS configuration is deleted.
   *
   * ### Further Information:
   * None.
   */
  removeRadiusConfig(
    req: operations.RemoveRadiusConfigRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RemoveRadiusConfigResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RemoveRadiusConfigRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/v4/system/config/auth/radius";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RemoveRadiusConfigResponse =
        new operations.RemoveRadiusConfigResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        case [401, 403, 404, 406, 412].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Request Active Directory configuration
   *
   * @remarks
   * ### Description:
   * Retrieve the configuration of an Active Directory.
   *
   * ### Precondition:
   * Right <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; read global config</span> of the Provider Customer required.
   *
   * ### Postcondition:
   * Active Directory configuration is returned.
   *
   * ### Further Information:
   * None.
   */
  requestAdConfig(
    req: operations.RequestAdConfigRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RequestAdConfigResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RequestAdConfigRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v4/system/config/auth/ads/{ad_id}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RequestAdConfigResponse =
        new operations.RequestAdConfigResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.activeDirectoryConfig = utils.objectToClass(
              httpRes?.data,
              shared.ActiveDirectoryConfig
            );
          }
          break;
        case [400, 401, 403, 404, 406, 412].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Request list of Active Directory configurations
   *
   * @remarks
   * ### Description:
   * Retrieve a list of configured Active Directories.
   *
   * ### Precondition:
   * Right <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; read global config</span> of the Provider Customer required.
   *
   * ### Postcondition:
   * List of Active Directory configurations is returned.
   *
   * ### Further Information:
   * None.
   */
  requestAdConfigs(
    req: operations.RequestAdConfigsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RequestAdConfigsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RequestAdConfigsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/v4/system/config/auth/ads";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RequestAdConfigsResponse =
        new operations.RequestAdConfigsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.activeDirectoryConfigList = utils.objectToClass(
              httpRes?.data,
              shared.ActiveDirectoryConfigList
            );
          }
          break;
        case [401, 403, 406, 412].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Request OAuth client
   *
   * @remarks
   * ### Description:
   * Retrieve the configuration of an OAuth client.
   *
   * ### Precondition:
   * Right <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; change global config</span> and
   * role <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128100; Config Manager</span> of the Provider Customer required.
   *
   * ### Postcondition:
   * OAuth client is returned.
   *
   * ### Further Information:
   * None.
   */
  requestOAuthClient(
    req: operations.RequestOAuthClientRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RequestOAuthClientResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RequestOAuthClientRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v4/system/config/oauth/clients/{client_id}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RequestOAuthClientResponse =
        new operations.RequestOAuthClientResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.oAuthClient = utils.objectToClass(
              httpRes?.data,
              shared.OAuthClient
            );
          }
          break;
        case [400, 401, 403, 404, 406, 412].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Request list of OAuth clients
   *
   * @remarks
   * ### Description:
   * Retrieve a list of configured OAuth clients.
   *
   * ### Precondition:
   * Right <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; change global config</span> and
   * role <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128100; Config Manager</span> of the Provider Customer required.
   *
   * ### Postcondition:
   * List of OAuth clients is returned.
   *
   * ### Further Information:
   *
   * ### Filtering:
   * All filter fields are connected via logical conjunction (**AND**)
   * Filter string syntax: `FIELD_NAME:OPERATOR:VALUE[:VALUE...]`
   *
   * <details style="padding-left: 10px">
   * <summary style="cursor: pointer; outline: none"><strong>Example</strong></summary>
   *
   * `isStandard:eq:true`
   * Get standard OAuth clients.
   *
   * </details>
   *
   * ### Filtering options:
   * <details style="padding: 10px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px;">
   * <summary style="cursor: pointer; outline: none"><strong>Expand</strong></summary>
   *
   * | `FIELD_NAME` | Filter Description | `OPERATOR` | Operator Description | `VALUE` |
   * | :--- | :--- | :--- | :--- | :--- |
   * | `isStandard` | Standard client filter | `eq` |  | `true or false` |
   * | `isExternal` | External client filter | `eq` |  | `true or false` |
   * | `isEnabled` | Enabled/disabled clients filter | `eq` |  | `true or false` |
   *
   * </details>
   *
   * ---
   *
   * ### Sorting:
   * Sort string syntax: `FIELD_NAME:ORDER`
   * `ORDER` can be `asc` or `desc`.
   * Multiple sort criteria are possible.
   * Fields are connected via logical conjunction **AND**.
   *
   * <details style="padding-left: 10px">
   * <summary style="cursor: pointer; outline: none"><strong>Example</strong></summary>
   *
   * `clientName:desc|isStandard:asc`
   * Sort by `clientName` descending **AND** `isStandard` ascending.
   *
   * </details>
   *
   * ### Sorting options:
   * <details style="padding: 10px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px;">
   * <summary style="cursor: pointer; outline: none"><strong>Expand</strong></summary>
   *
   * | `FIELD_NAME` | Description |
   * | :--- | :--- |
   * | `clientName` | Client name |
   * | `isStandard` | Is a standard client |
   * | `isExternal` | Is a external client |
   * | `isEnabled` | Is a enabled client |
   *
   * </details>
   */
  requestOAuthClients(
    req: operations.RequestOAuthClientsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RequestOAuthClientsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RequestOAuthClientsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/v4/system/config/oauth/clients";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RequestOAuthClientsResponse =
        new operations.RequestOAuthClientsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.oAuthClients = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.oAuthClients = utils.objectToClass(
              httpRes?.data,
              shared.OAuthClient,
              resFieldDepth
            );
          }
          break;
        case [401, 403, 406, 412].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Request OpenID Connect IDP configuration
   *
   * @remarks
   * ### Description:
   * Retrieve an OpenID Connect IDP configuration.
   *
   * ### Precondition:
   * Right <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; change global config</span> and
   * role <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128100; Config Manager</span> of the Provider Customer required.
   *
   * ### Postcondition:
   * OpenID Connect IDP configuration is returned.
   *
   * ### Further Information:
   * None.
   *
   * @see {@link http://openid.net/developers/specs} - OpenID Specifications
   */
  requestOpenIdIdpConfig(
    req: operations.RequestOpenIdIdpConfigRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RequestOpenIdIdpConfigResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RequestOpenIdIdpConfigRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v4/system/config/auth/openid/idps/{idp_id}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RequestOpenIdIdpConfigResponse =
        new operations.RequestOpenIdIdpConfigResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.openIdIdpConfig = utils.objectToClass(
              httpRes?.data,
              shared.OpenIdIdpConfig
            );
          }
          break;
        case [400, 401, 403, 404, 406, 412].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Request list of OpenID Connect IDP configurations
   *
   * @remarks
   * ### Description:
   * Retrieve a list of configured OpenID Connect IDPs.
   *
   * ### Precondition:
   * Right <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; change global config</span> and
   * role <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128100; Config Manager</span> of the Provider Customer required.
   *
   * ### Postcondition:
   * List of OpenID Connect IDP configurations is returned.
   *
   * ### Further Information:
   * None.
   *
   * @see {@link http://openid.net/developers/specs} - OpenID Specifications
   */
  requestOpenIdIdpConfigs(
    req: operations.RequestOpenIdIdpConfigsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RequestOpenIdIdpConfigsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RequestOpenIdIdpConfigsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/v4/system/config/auth/openid/idps";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RequestOpenIdIdpConfigsResponse =
        new operations.RequestOpenIdIdpConfigsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.openIdIdpConfigs = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.openIdIdpConfigs = utils.objectToClass(
              httpRes?.data,
              shared.OpenIdIdpConfig,
              resFieldDepth
            );
          }
          break;
        case [401, 403, 406, 412].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Request RADIUS configuration
   *
   * @remarks
   * ### Description:
   * Retrieve a RADIUS configuration.
   *
   * ### Precondition:
   * Right <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; read global config</span> and
   * role <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128100; Config Manager</span> of the Provider Customer required.
   *
   * ### Postcondition:
   * RADIUS configuration is returned.
   *
   * ### Further Information:
   * None.
   */
  requestRadiusConfig(
    req: operations.RequestRadiusConfigRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RequestRadiusConfigResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RequestRadiusConfigRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/v4/system/config/auth/radius";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RequestRadiusConfigResponse =
        new operations.RequestRadiusConfigResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.radiusConfig = utils.objectToClass(
              httpRes?.data,
              shared.RadiusConfig
            );
          }
          break;
        case [401, 403, 404, 406, 412].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Test Active Directory configuration
   *
   * @remarks
   * ### Description:
   * Test Active Directory configuration.
   *
   * ### Precondition:
   * Right <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; change global config</span> of the Provider Customer required.
   *
   * ### Postcondition:
   * Active Directory configuration is returned if successful.
   *
   * ### Further Information:
   * DRACOON tries to establish a connection with the provided information.
   */
  testAdConfig(
    req: operations.TestAdConfigRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.TestAdConfigResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TestAdConfigRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/v4/system/config/actions/test/ad";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "testActiveDirectoryConfigRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TestAdConfigResponse =
        new operations.TestAdConfigResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.testActiveDirectoryConfigResponse = utils.objectToClass(
              httpRes?.data,
              shared.TestActiveDirectoryConfigResponse
            );
          }
          break;
        case [400, 401, 403, 404, 406, 412].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Test RADIUS server availability
   *
   * @remarks
   * ### Description:
   * Test RADIUS configuration.
   *
   * ### Precondition:
   * Right <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; read global config</span> of the Provider Customer required.
   *
   * ### Postcondition:
   * RADIUS configuration is returned if successful.
   *
   * ### Further Information:
   * DRACOON tries to establish a connection with the provided information.
   */
  testRadiusConfig(
    req: operations.TestRadiusConfigRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.TestRadiusConfigResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TestRadiusConfigRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/v4/system/config/actions/test/radius";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TestRadiusConfigResponse =
        new operations.TestRadiusConfigResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        case [401, 403, 404, 406, 412, 502].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update Active Directory configuration
   *
   * @remarks
   * ### Description:
   * Update an existing Active Directory configuration.
   *
   * ### Precondition:
   * Right <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; change global config</span> of the Provider Customer required.
   *
   * ### Postcondition:
   * Active Directory configuration updated.
   *
   * ### Further Information:
   * None.
   */
  updateAdConfig(
    req: operations.UpdateAdConfigRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateAdConfigResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateAdConfigRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v4/system/config/auth/ads/{ad_id}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "updateActiveDirectoryConfigRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateAdConfigResponse =
        new operations.UpdateAdConfigResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.activeDirectoryConfig = utils.objectToClass(
              httpRes?.data,
              shared.ActiveDirectoryConfig
            );
          }
          break;
        case [400, 401, 403, 404, 406, 409, 412].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update OAuth client
   *
   * @remarks
   * ### Description:
   * Update an existing OAuth client.
   *
   * ### Precondition:
   * Right <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; change global config</span> and
   * role <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128100; Config Manager</span> of the Provider Customer required.
   *
   * ### Postcondition:
   * OAuth client updated.
   *
   * ### Further Information:
   * Client secret **MUST** have:
   * * at least 12 characters, at most 32 characters
   * * only lower case characters, upper case characters and digits
   * * at least 1 lower case character, 1 upper case character and 1 digit
   *
   * The client secret is optional and will be generated if it is left empty.
   *
   * Valid grant types are:
   * * `authorization_code`
   * * `implicit`
   * * `password`
   * * `client_credentials`
   * * `refresh_token`
   *
   * Grant type `client_credentials` is currently **NOT** permitted!
   *
   * If grant types `authorization_code` or `implicit` are used, a
   * redirect URI **MUST** be provided!
   *
   */
  updateOAuthClient(
    req: operations.UpdateOAuthClientRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateOAuthClientResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateOAuthClientRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v4/system/config/oauth/clients/{client_id}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "updateOAuthClientRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateOAuthClientResponse =
        new operations.UpdateOAuthClientResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.oAuthClient = utils.objectToClass(
              httpRes?.data,
              shared.OAuthClient
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateOAuthClient400ApplicationJSONOneOf = httpRes?.data;
          }
          break;
        case [401, 403, 404, 406, 412].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update OpenID Connect IDP configuration
   *
   * @remarks
   * ### Description:
   * Update an existing OpenID Connect IDP configuration.
   *
   * ### Precondition:
   * Right <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; change global config</span> and
   * role <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128100; Config Manager</span> of the Provider Customer required.
   *
   * ### Postcondition:
   * OpenID Connect IDP configuration is updated.
   *
   * ### Further Information:
   * None.
   *
   * @see {@link http://openid.net/developers/specs} - OpenID Specifications
   */
  updateOpenIdIdpConfig(
    req: operations.UpdateOpenIdIdpConfigRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateOpenIdIdpConfigResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateOpenIdIdpConfigRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v4/system/config/auth/openid/idps/{idp_id}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "updateOpenIdIdpConfigRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateOpenIdIdpConfigResponse =
        new operations.UpdateOpenIdIdpConfigResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.openIdIdpConfig = utils.objectToClass(
              httpRes?.data,
              shared.OpenIdIdpConfig
            );
          }
          break;
        case [400, 401, 403, 404, 406, 409, 412].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update RADIUS configuration
   *
   * @remarks
   * ### Description:
   * Update existing RADIUS configuration.
   *
   * ### Precondition:
   * Right <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; change global config</span> and
   * role <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128100; Config Manager</span> of the Provider Customer required.
   *
   * ### Postcondition:
   * RADIUS configuration is updated.
   *
   * ### Further Information:
   * None.
   */
  updateRadiusConfig(
    req: operations.UpdateRadiusConfigRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateRadiusConfigResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateRadiusConfigRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/v4/system/config/auth/radius";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "radiusConfigUpdateRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateRadiusConfigResponse =
        new operations.UpdateRadiusConfigResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.radiusConfig = utils.objectToClass(
              httpRes?.data,
              shared.RadiusConfig
            );
          }
          break;
        case [400, 401, 403, 404, 406, 412].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }
}
