/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package org.openapis.openapi.models.shared;

import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;

/**
 * GeocodingSummary - Detailed summary of the result from geocoding an address
 */
public class GeocodingSummary {
    /**
     * Represents the best estimate of whether or not the input address was fully understood and the address is correctly componentized. Mirrors the same-name field in geostore.staging.AddressLinkupScoringProto.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("addressUnderstood")
    public Boolean addressUnderstood;
    public GeocodingSummary withAddressUnderstood(Boolean addressUnderstood) {
        this.addressUnderstood = addressUnderstood;
        return this;
    }
    
    /**
     * A globally unique identifier associated with each feature. We use 128-bit identifiers so that we have lots of bits available to distinguish between features. The feature id currently consists of a 64-bit "cell id" that **sometimes** corresponds to the approximate centroid of the feature, plus a 64-bit fingerprint of other identifying information. See more on each respective field in its comments. Feature ids are first assigned when the data is created in MapFacts. After initial creation of the feature, they are immutable. This means that the only properties that you should rely on are that they are unique, and that cell_ids often - but not always - preserve spatial locality. The degree of locality varies as the feature undergoes geometry changes, and should not in general be considered a firm guarantee of the location of any particular feature. In fact, some locationless features have randomized cell IDs! Consumers of FeatureProtos from Mapfacts are guaranteed that fprints in the id field of features will be globally unique. Using the fprint allows consumers who don't need the spatial benefit of cell ids to uniquely identify features in a 64-bit address space. This property is not guaranteed for other sources of FeatureProtos.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("featureId")
    public FeatureIdProto featureId;
    public GeocodingSummary withFeatureId(FeatureIdProto featureId) {
        this.featureId = featureId;
        return this;
    }
    
    /**
     * The feature type for the FeatureProto returned by the geocoder
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("featureType")
    public GeocodingSummaryFeatureTypeEnum featureType;
    public GeocodingSummary withFeatureType(GeocodingSummaryFeatureTypeEnum featureType) {
        this.featureType = featureType;
        return this;
    }
    
    /**
     * Precision of the center point (lat/long) of the geocoded FeatureProto
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("positionPrecisionMeters")
    public Double positionPrecisionMeters;
    public GeocodingSummary withPositionPrecisionMeters(Double positionPrecisionMeters) {
        this.positionPrecisionMeters = positionPrecisionMeters;
        return this;
    }
    
    /**
     * The query sent to the geocoder
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("queryString")
    public String queryString;
    public GeocodingSummary withQueryString(String queryString) {
        this.queryString = queryString;
        return this;
    }
    
}
