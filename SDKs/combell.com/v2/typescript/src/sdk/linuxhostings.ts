/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * Manage your linux hostings.
 */
export class LinuxHostings {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Add a scheduled task
   */
  addScheduledTasks(
    req: operations.AddScheduledTasksRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.AddScheduledTasksResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AddScheduledTasksRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/linuxhostings/{domainName}/scheduledtasks",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "scheduledTask",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AddScheduledTasksResponse =
        new operations.AddScheduledTasksResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          break;
      }

      return res;
    });
  }

  /**
   * Add a SSH key
   */
  addSshKey(
    req: operations.AddSshKeyRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.AddSshKeyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AddSshKeyRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/linuxhostings/{domainName}/ssh/keys",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "addSshKeyRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AddSshKeyResponse =
        new operations.AddSshKeyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          break;
      }

      return res;
    });
  }

  /**
   * Configure PHP APCu setting
   */
  changeApcu(
    req: operations.ChangeApcuRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ChangeApcuResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ChangeApcuRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/linuxhostings/{domainName}/phpsettings/apcu",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "updatePhpAPcuRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ChangeApcuResponse =
        new operations.ChangeApcuResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Configure auto redirect
   */
  changeAutoRedirect(
    req: operations.ChangeAutoRedirectRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ChangeAutoRedirectResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ChangeAutoRedirectRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/linuxhostings/{domainName}/sslsettings/{hostname}/autoredirect",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "autoRedirectConfig",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ChangeAutoRedirectResponse =
        new operations.ChangeAutoRedirectResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Enable/disable GZIP compression
   */
  changeGzipCompression(
    req: operations.ChangeGzipCompressionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ChangeGzipCompressionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ChangeGzipCompressionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/linuxhostings/{domainName}/settings/gzipcompression",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "gzipConfig",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ChangeGzipCompressionResponse =
        new operations.ChangeGzipCompressionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Configure let's encrypt
   */
  changeLetsEncrypt(
    req: operations.ChangeLetsEncryptRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ChangeLetsEncryptResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ChangeLetsEncryptRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/linuxhostings/{domainName}/sslsettings/{hostname}/letsencrypt",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "letsEncryptConfig",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ChangeLetsEncryptResponse =
        new operations.ChangeLetsEncryptResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Configure PHP memory limit
   */
  changePhpMemoryLimit(
    req: operations.ChangePhpMemoryLimitRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ChangePhpMemoryLimitResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ChangePhpMemoryLimitRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/linuxhostings/{domainName}/phpsettings/memorylimit",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "updatePhpMemoryLimitRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ChangePhpMemoryLimitResponse =
        new operations.ChangePhpMemoryLimitResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Change the Linux hosting PHP version.
   */
  changePhpVersion(
    req: operations.ChangePhpVersionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ChangePhpVersionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ChangePhpVersionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/linuxhostings/{domainName}/phpsettings/version",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "phpVersion",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ChangePhpVersionResponse =
        new operations.ChangePhpVersionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Configure FTP
   */
  configureFtp(
    req: operations.ConfigureFtpRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ConfigureFtpResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ConfigureFtpRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/linuxhostings/{domainName}/ftp/configuration",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "ftpConfiguration",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ConfigureFtpResponse =
        new operations.ConfigureFtpResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Configure HTTP/2
   */
  configureHttp2(
    req: operations.ConfigureHttp2Request,
    config?: AxiosRequestConfig
  ): Promise<operations.ConfigureHttp2Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ConfigureHttp2Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/linuxhostings/{domainName}/sites/{siteName}/http2/configuration",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "http2Configuration",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ConfigureHttp2Response =
        new operations.ConfigureHttp2Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Configure a scheduled task
   */
  configureScheduledTask(
    req: operations.ConfigureScheduledTaskRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ConfigureScheduledTaskResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ConfigureScheduledTaskRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/linuxhostings/{domainName}/scheduledtasks/{scheduledTaskId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "scheduledTask",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ConfigureScheduledTaskResponse =
        new operations.ConfigureScheduledTaskResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Configure SSH
   */
  configureSsh(
    req: operations.ConfigureSshRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ConfigureSshResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ConfigureSshRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/linuxhostings/{domainName}/ssh/configuration",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "sshConfiguration",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ConfigureSshResponse =
        new operations.ConfigureSshResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Create a host header
   */
  createHostHeader(
    req: operations.CreateHostHeaderRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateHostHeaderResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateHostHeaderRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/linuxhostings/{domainName}/sites/{siteName}/hostheaders",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "addHostHeaderRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateHostHeaderResponse =
        new operations.CreateHostHeaderResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          break;
      }

      return res;
    });
  }

  /**
   * Create a subsite
   */
  createSubsite(
    req: operations.CreateSubsiteRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateSubsiteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateSubsiteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/linuxhostings/{domainName}/subsites",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "addSubsiteRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateSubsiteResponse =
        new operations.CreateSubsiteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a scheduled task
   */
  deleteScheduledTask(
    req: operations.DeleteScheduledTaskRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteScheduledTaskResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteScheduledTaskRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/linuxhostings/{domainName}/scheduledtasks/{scheduledTaskId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteScheduledTaskResponse =
        new operations.DeleteScheduledTaskResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Delete a SSH key
   */
  deleteSshKey(
    req: operations.DeleteSshKeyRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSshKeyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteSshKeyRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/linuxhostings/{domainName}/ssh/keys/{fingerprint}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSshKeyResponse =
        new operations.DeleteSshKeyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Delete a subsite
   */
  deleteSubsite(
    req: operations.DeleteSubsiteRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSubsiteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteSubsiteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/linuxhostings/{domainName}/subsites/{siteName}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSubsiteResponse =
        new operations.DeleteSubsiteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Get the available PHP versions.
   */
  getAvailablePhpVersions(
    req: operations.GetAvailablePhpVersionsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetAvailablePhpVersionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetAvailablePhpVersionsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/linuxhostings/{domainName}/phpsettings/availableversions",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetAvailablePhpVersionsResponse =
        new operations.GetAvailablePhpVersionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.phpVersions = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.phpVersions = utils.objectToClass(
              httpRes?.data,
              shared.PhpVersion,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Linux hosting detail
   */
  getLinuxHosting(
    req: operations.GetLinuxHostingRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetLinuxHostingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetLinuxHostingRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/linuxhostings/{domainName}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetLinuxHostingResponse =
        new operations.GetLinuxHostingResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linuxHostingDetail = utils.objectToClass(
              httpRes?.data,
              shared.LinuxHostingDetail
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Overview of linux hostings
   */
  getLinuxHostings(
    req: operations.GetLinuxHostingsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetLinuxHostingsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetLinuxHostingsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/linuxhostings";

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetLinuxHostingsResponse =
        new operations.GetLinuxHostingsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linuxHostings = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.linuxHostings = utils.objectToClass(
              httpRes?.data,
              shared.LinuxHosting,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get scheduled task detail
   */
  getScheduledTask(
    req: operations.GetScheduledTaskRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetScheduledTaskResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetScheduledTaskRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/linuxhostings/{domainName}/scheduledtasks/{scheduledTaskId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetScheduledTaskResponse =
        new operations.GetScheduledTaskResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.scheduledTask = utils.objectToClass(
              httpRes?.data,
              shared.ScheduledTask
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Overview of scheduled tasks
   *
   * @remarks
   * Manage scheduled tasks which are also manageable via the control panel.
   */
  getScheduledTasks(
    req: operations.GetScheduledTasksRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetScheduledTasksResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetScheduledTasksRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/linuxhostings/{domainName}/scheduledtasks",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetScheduledTasksResponse =
        new operations.GetScheduledTasksResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.scheduledTasks = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.scheduledTasks = utils.objectToClass(
              httpRes?.data,
              shared.ScheduledTask,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Overview of SSH keys
   */
  getSshKeys(
    req: operations.GetSshKeysRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSshKeysResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSshKeysRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/linuxhostings/{domainName}/ssh/keys",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSshKeysResponse =
        new operations.GetSshKeysResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.sshKeys = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.sshKeys = utils.objectToClass(
              httpRes?.data,
              shared.SshKey,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }
}
