/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import axios from "axios";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * Contains the list of servers available to the SDK
 */
export const ServerList = ["https://flex-api.twilio.com"] as const;

/**
 * The available configuration options for the SDK
 */
export type SDKProps = {
  /**
   * Allows overriding the default axios client used by the SDK
   */
  defaultClient?: AxiosInstance;
  /**
   * Allows overriding the default server URL used by the SDK
   */
  serverURL?: string;
};

/**
 * This is the public Twilio REST API.
 */
export class SDK {
  public _defaultClient: AxiosInstance;
  public _securityClient: AxiosInstance;
  public _serverURL: string;
  private _language = "typescript";
  private _sdkVersion = "0.0.1";
  private _genVersion = "internal";
  private _globals: any;

  constructor(props?: SDKProps) {
    this._serverURL = props?.serverURL ?? ServerList[0];

    this._defaultClient =
      props?.defaultClient ?? axios.create({ baseURL: this._serverURL });
    this._securityClient = this._defaultClient;
  }

  createChannel(
    req: operations.CreateChannelCreateChannelRequest,
    security: operations.CreateChannelSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateChannelResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateChannelCreateChannelRequest(req);
    }

    let baseURL: string = operations.CreateChannelServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/Channels";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateChannelSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateChannelResponse =
        new operations.CreateChannelResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.flexV1Channel = utils.objectToClass(
              httpRes?.data,
              shared.FlexV1Channel
            );
          }
          break;
      }

      return res;
    });
  }

  createFlexFlow(
    req: operations.CreateFlexFlowCreateFlexFlowRequest,
    security: operations.CreateFlexFlowSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateFlexFlowResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateFlexFlowCreateFlexFlowRequest(req);
    }

    let baseURL: string = operations.CreateFlexFlowServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/FlexFlows";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateFlexFlowSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateFlexFlowResponse =
        new operations.CreateFlexFlowResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.flexV1FlexFlow = utils.objectToClass(
              httpRes?.data,
              shared.FlexV1FlexFlow
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add assessments against conversation to dynamo db. Used in assessments screen by user. Users can select the questionnaire and pick up answers for each and every question.
   */
  createInsightsAssessments(
    req: operations.CreateInsightsAssessmentsRequest,
    security: operations.CreateInsightsAssessmentsSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateInsightsAssessmentsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateInsightsAssessmentsRequest(req);
    }

    let baseURL: string = operations.CreateInsightsAssessmentsServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string =
      baseURL.replace(/\/$/, "") + "/v1/Insights/QM/Assessments";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateInsightsAssessmentsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateInsightsAssessmentsResponse =
        new operations.CreateInsightsAssessmentsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.flexV1InsightsAssessments = utils.objectToClass(
              httpRes?.data,
              shared.FlexV1InsightsAssessments
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * To create a comment assessment for a conversation
   */
  createInsightsAssessmentsComment(
    req: operations.CreateInsightsAssessmentsCommentRequest,
    security: operations.CreateInsightsAssessmentsCommentSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateInsightsAssessmentsCommentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateInsightsAssessmentsCommentRequest(req);
    }

    let baseURL: string =
      operations.CreateInsightsAssessmentsCommentServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string =
      baseURL.replace(/\/$/, "") + "/v1/Insights/QM/Assessments/Comments";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateInsightsAssessmentsCommentSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateInsightsAssessmentsCommentResponse =
        new operations.CreateInsightsAssessmentsCommentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.flexV1InsightsAssessmentsComment = utils.objectToClass(
              httpRes?.data,
              shared.FlexV1InsightsAssessmentsComment
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * To create a Questionnaire
   */
  createInsightsQuestionnaires(
    req: operations.CreateInsightsQuestionnairesRequest,
    security: operations.CreateInsightsQuestionnairesSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateInsightsQuestionnairesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateInsightsQuestionnairesRequest(req);
    }

    let baseURL: string = operations.CreateInsightsQuestionnairesServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string =
      baseURL.replace(/\/$/, "") + "/v1/Insights/QM/Questionnaires";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateInsightsQuestionnairesSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateInsightsQuestionnairesResponse =
        new operations.CreateInsightsQuestionnairesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.flexV1InsightsQuestionnaires = utils.objectToClass(
              httpRes?.data,
              shared.FlexV1InsightsQuestionnaires
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * To create a category for Questions
   */
  createInsightsQuestionnairesCategory(
    req: operations.CreateInsightsQuestionnairesCategoryRequest,
    security: operations.CreateInsightsQuestionnairesCategorySecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateInsightsQuestionnairesCategoryResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateInsightsQuestionnairesCategoryRequest(req);
    }

    let baseURL: string =
      operations.CreateInsightsQuestionnairesCategoryServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string =
      baseURL.replace(/\/$/, "") + "/v1/Insights/QM/Categories";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateInsightsQuestionnairesCategorySecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateInsightsQuestionnairesCategoryResponse =
        new operations.CreateInsightsQuestionnairesCategoryResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.flexV1InsightsQuestionnairesCategory = utils.objectToClass(
              httpRes?.data,
              shared.FlexV1InsightsQuestionnairesCategory
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * To create a question for a Category
   */
  createInsightsQuestionnairesQuestion(
    req: operations.CreateInsightsQuestionnairesQuestionRequest,
    security: operations.CreateInsightsQuestionnairesQuestionSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateInsightsQuestionnairesQuestionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateInsightsQuestionnairesQuestionRequest(req);
    }

    let baseURL: string =
      operations.CreateInsightsQuestionnairesQuestionServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string =
      baseURL.replace(/\/$/, "") + "/v1/Insights/QM/Questions";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateInsightsQuestionnairesQuestionSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateInsightsQuestionnairesQuestionResponse =
        new operations.CreateInsightsQuestionnairesQuestionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.flexV1InsightsQuestionnairesQuestion = utils.objectToClass(
              httpRes?.data,
              shared.FlexV1InsightsQuestionnairesQuestion
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * To obtain session details for fetching reports and dashboards
   */
  createInsightsSession(
    req: operations.CreateInsightsSessionRequest,
    security: operations.CreateInsightsSessionSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateInsightsSessionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateInsightsSessionRequest(req);
    }

    let baseURL: string = operations.CreateInsightsSessionServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/Insights/Session";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateInsightsSessionSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateInsightsSessionResponse =
        new operations.CreateInsightsSessionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.flexV1InsightsSession = utils.objectToClass(
              httpRes?.data,
              shared.FlexV1InsightsSession
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new Interaction.
   */
  createInteraction(
    req: operations.CreateInteractionCreateInteractionRequest,
    security: operations.CreateInteractionSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateInteractionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateInteractionCreateInteractionRequest(req);
    }

    let baseURL: string = operations.CreateInteractionServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/Interactions";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateInteractionSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateInteractionResponse =
        new operations.CreateInteractionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.flexV1Interaction = utils.objectToClass(
              httpRes?.data,
              shared.FlexV1Interaction
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Invite an Agent or a TaskQueue to a Channel.
   */
  createInteractionChannelInvite(
    req: operations.CreateInteractionChannelInviteRequest,
    security: operations.CreateInteractionChannelInviteSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateInteractionChannelInviteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateInteractionChannelInviteRequest(req);
    }

    let baseURL: string =
      operations.CreateInteractionChannelInviteServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Interactions/{InteractionSid}/Channels/{ChannelSid}/Invites",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateInteractionChannelInviteSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateInteractionChannelInviteResponse =
        new operations.CreateInteractionChannelInviteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.flexV1InteractionInteractionChannelInteractionChannelInvite =
              utils.objectToClass(
                httpRes?.data,
                shared.FlexV1InteractionInteractionChannelInteractionChannelInvite
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a Participant to a Channel.
   */
  createInteractionChannelParticipant(
    req: operations.CreateInteractionChannelParticipantRequest,
    security: operations.CreateInteractionChannelParticipantSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateInteractionChannelParticipantResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateInteractionChannelParticipantRequest(req);
    }

    let baseURL: string =
      operations.CreateInteractionChannelParticipantServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Interactions/{InteractionSid}/Channels/{ChannelSid}/Participants",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateInteractionChannelParticipantSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateInteractionChannelParticipantResponse =
        new operations.CreateInteractionChannelParticipantResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.flexV1InteractionInteractionChannelInteractionChannelParticipant =
              utils.objectToClass(
                httpRes?.data,
                shared.FlexV1InteractionInteractionChannelInteractionChannelParticipant
              );
          }
          break;
      }

      return res;
    });
  }

  createWebChannel(
    req: operations.CreateWebChannelCreateWebChannelRequest,
    security: operations.CreateWebChannelSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateWebChannelResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateWebChannelCreateWebChannelRequest(req);
    }

    let baseURL: string = operations.CreateWebChannelServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/WebChannels";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateWebChannelSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateWebChannelResponse =
        new operations.CreateWebChannelResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.flexV1WebChannel = utils.objectToClass(
              httpRes?.data,
              shared.FlexV1WebChannel
            );
          }
          break;
      }

      return res;
    });
  }

  deleteChannel(
    req: operations.DeleteChannelRequest,
    security: operations.DeleteChannelSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteChannelResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteChannelRequest(req);
    }

    let baseURL: string = operations.DeleteChannelServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v1/Channels/{Sid}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteChannelSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteChannelResponse =
        new operations.DeleteChannelResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  deleteFlexFlow(
    req: operations.DeleteFlexFlowRequest,
    security: operations.DeleteFlexFlowSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteFlexFlowResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteFlexFlowRequest(req);
    }

    let baseURL: string = operations.DeleteFlexFlowServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v1/FlexFlows/{Sid}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteFlexFlowSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteFlexFlowResponse =
        new operations.DeleteFlexFlowResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * To delete the questionnaire
   */
  deleteInsightsQuestionnaires(
    req: operations.DeleteInsightsQuestionnairesRequest,
    security: operations.DeleteInsightsQuestionnairesSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteInsightsQuestionnairesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteInsightsQuestionnairesRequest(req);
    }

    let baseURL: string = operations.DeleteInsightsQuestionnairesServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Insights/QM/Questionnaires/{Id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteInsightsQuestionnairesSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteInsightsQuestionnairesResponse =
        new operations.DeleteInsightsQuestionnairesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  deleteInsightsQuestionnairesCategory(
    req: operations.DeleteInsightsQuestionnairesCategoryRequest,
    security: operations.DeleteInsightsQuestionnairesCategorySecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteInsightsQuestionnairesCategoryResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteInsightsQuestionnairesCategoryRequest(req);
    }

    let baseURL: string =
      operations.DeleteInsightsQuestionnairesCategoryServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Insights/QM/Categories/{CategoryId}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteInsightsQuestionnairesCategorySecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteInsightsQuestionnairesCategoryResponse =
        new operations.DeleteInsightsQuestionnairesCategoryResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  deleteInsightsQuestionnairesQuestion(
    req: operations.DeleteInsightsQuestionnairesQuestionRequest,
    security: operations.DeleteInsightsQuestionnairesQuestionSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteInsightsQuestionnairesQuestionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteInsightsQuestionnairesQuestionRequest(req);
    }

    let baseURL: string =
      operations.DeleteInsightsQuestionnairesQuestionServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Insights/QM/Questions/{QuestionId}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteInsightsQuestionnairesQuestionSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteInsightsQuestionnairesQuestionResponse =
        new operations.DeleteInsightsQuestionnairesQuestionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  deleteWebChannel(
    req: operations.DeleteWebChannelRequest,
    security: operations.DeleteWebChannelSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteWebChannelResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteWebChannelRequest(req);
    }

    let baseURL: string = operations.DeleteWebChannelServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/WebChannels/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteWebChannelSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteWebChannelResponse =
        new operations.DeleteWebChannelResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  fetchChannel(
    req: operations.FetchChannelRequest,
    security: operations.FetchChannelSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchChannelResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchChannelRequest(req);
    }

    let baseURL: string = operations.FetchChannelServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v1/Channels/{Sid}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchChannelSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchChannelResponse =
        new operations.FetchChannelResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.flexV1Channel = utils.objectToClass(
              httpRes?.data,
              shared.FlexV1Channel
            );
          }
          break;
      }

      return res;
    });
  }

  fetchConfiguration(
    req: operations.FetchConfigurationRequest,
    security: operations.FetchConfigurationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchConfigurationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchConfigurationRequest(req);
    }

    let baseURL: string = operations.FetchConfigurationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/Configuration";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchConfigurationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchConfigurationResponse =
        new operations.FetchConfigurationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.flexV1Configuration = utils.objectToClass(
              httpRes?.data,
              shared.FlexV1Configuration
            );
          }
          break;
      }

      return res;
    });
  }

  fetchFlexFlow(
    req: operations.FetchFlexFlowRequest,
    security: operations.FetchFlexFlowSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchFlexFlowResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchFlexFlowRequest(req);
    }

    let baseURL: string = operations.FetchFlexFlowServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v1/FlexFlows/{Sid}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchFlexFlowSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchFlexFlowResponse =
        new operations.FetchFlexFlowResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.flexV1FlexFlow = utils.objectToClass(
              httpRes?.data,
              shared.FlexV1FlexFlow
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * To get the Questionnaire Detail
   */
  fetchInsightsQuestionnaires(
    req: operations.FetchInsightsQuestionnairesRequest,
    security: operations.FetchInsightsQuestionnairesSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchInsightsQuestionnairesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchInsightsQuestionnairesRequest(req);
    }

    let baseURL: string = operations.FetchInsightsQuestionnairesServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Insights/QM/Questionnaires/{Id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchInsightsQuestionnairesSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchInsightsQuestionnairesResponse =
        new operations.FetchInsightsQuestionnairesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.flexV1InsightsQuestionnaires = utils.objectToClass(
              httpRes?.data,
              shared.FlexV1InsightsQuestionnaires
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * To get the Segments of an Account
   */
  fetchInsightsSegments(
    req: operations.FetchInsightsSegmentsRequest,
    security: operations.FetchInsightsSegmentsSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchInsightsSegmentsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchInsightsSegmentsRequest(req);
    }

    let baseURL: string = operations.FetchInsightsSegmentsServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Insights/Segments/{SegmentId}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchInsightsSegmentsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchInsightsSegmentsResponse =
        new operations.FetchInsightsSegmentsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.flexV1InsightsSegments = utils.objectToClass(
              httpRes?.data,
              shared.FlexV1InsightsSegments
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * To get the Answer Set Settings for an Account
   */
  fetchInsightsSettingsAnswersets(
    req: operations.FetchInsightsSettingsAnswersetsRequest,
    security: operations.FetchInsightsSettingsAnswersetsSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchInsightsSettingsAnswersetsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchInsightsSettingsAnswersetsRequest(req);
    }

    let baseURL: string =
      operations.FetchInsightsSettingsAnswersetsServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string =
      baseURL.replace(/\/$/, "") + "/v1/Insights/QM/Settings/AnswerSets";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchInsightsSettingsAnswersetsSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchInsightsSettingsAnswersetsResponse =
        new operations.FetchInsightsSettingsAnswersetsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.flexV1InsightsSettingsAnswersets = utils.objectToClass(
              httpRes?.data,
              shared.FlexV1InsightsSettingsAnswersets
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * To get the Comment Settings for an Account
   */
  fetchInsightsSettingsComment(
    req: operations.FetchInsightsSettingsCommentRequest,
    security: operations.FetchInsightsSettingsCommentSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchInsightsSettingsCommentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchInsightsSettingsCommentRequest(req);
    }

    let baseURL: string = operations.FetchInsightsSettingsCommentServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string =
      baseURL.replace(/\/$/, "") + "/v1/Insights/QM/Settings/CommentTags";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchInsightsSettingsCommentSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchInsightsSettingsCommentResponse =
        new operations.FetchInsightsSettingsCommentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.flexV1InsightsSettingsComment = utils.objectToClass(
              httpRes?.data,
              shared.FlexV1InsightsSettingsComment
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * This is used by Flex UI and Quality Management to fetch the Flex Insights roles for the user
   */
  fetchInsightsUserRoles(
    req: operations.FetchInsightsUserRolesRequest,
    security: operations.FetchInsightsUserRolesSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchInsightsUserRolesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchInsightsUserRolesRequest(req);
    }

    let baseURL: string = operations.FetchInsightsUserRolesServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/Insights/UserRoles";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchInsightsUserRolesSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchInsightsUserRolesResponse =
        new operations.FetchInsightsUserRolesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.flexV1InsightsUserRoles = utils.objectToClass(
              httpRes?.data,
              shared.FlexV1InsightsUserRoles
            );
          }
          break;
      }

      return res;
    });
  }

  fetchInteraction(
    req: operations.FetchInteractionRequest,
    security: operations.FetchInteractionSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchInteractionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchInteractionRequest(req);
    }

    let baseURL: string = operations.FetchInteractionServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Interactions/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchInteractionSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchInteractionResponse =
        new operations.FetchInteractionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.flexV1Interaction = utils.objectToClass(
              httpRes?.data,
              shared.FlexV1Interaction
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a Channel for an Interaction.
   */
  fetchInteractionChannel(
    req: operations.FetchInteractionChannelRequest,
    security: operations.FetchInteractionChannelSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchInteractionChannelResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchInteractionChannelRequest(req);
    }

    let baseURL: string = operations.FetchInteractionChannelServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Interactions/{InteractionSid}/Channels/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchInteractionChannelSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchInteractionChannelResponse =
        new operations.FetchInteractionChannelResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.flexV1InteractionInteractionChannel = utils.objectToClass(
              httpRes?.data,
              shared.FlexV1InteractionInteractionChannel
            );
          }
          break;
      }

      return res;
    });
  }

  fetchWebChannel(
    req: operations.FetchWebChannelRequest,
    security: operations.FetchWebChannelSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchWebChannelResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchWebChannelRequest(req);
    }

    let baseURL: string = operations.FetchWebChannelServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/WebChannels/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchWebChannelSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchWebChannelResponse =
        new operations.FetchWebChannelResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.flexV1WebChannel = utils.objectToClass(
              httpRes?.data,
              shared.FlexV1WebChannel
            );
          }
          break;
      }

      return res;
    });
  }

  listChannel(
    req: operations.ListChannelRequest,
    security: operations.ListChannelSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListChannelResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListChannelRequest(req);
    }

    let baseURL: string = operations.ListChannelServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/Channels";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListChannelSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListChannelResponse =
        new operations.ListChannelResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listChannelResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListChannelListChannelResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listFlexFlow(
    req: operations.ListFlexFlowRequest,
    security: operations.ListFlexFlowSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListFlexFlowResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListFlexFlowRequest(req);
    }

    let baseURL: string = operations.ListFlexFlowServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/FlexFlows";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListFlexFlowSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListFlexFlowResponse =
        new operations.ListFlexFlowResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listFlexFlowResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListFlexFlowListFlexFlowResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get assessments done for a conversation by logged in user
   */
  listInsightsAssessments(
    req: operations.ListInsightsAssessmentsRequest,
    security: operations.ListInsightsAssessmentsSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListInsightsAssessmentsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListInsightsAssessmentsRequest(req);
    }

    let baseURL: string = operations.ListInsightsAssessmentsServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string =
      baseURL.replace(/\/$/, "") + "/v1/Insights/QM/Assessments";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListInsightsAssessmentsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListInsightsAssessmentsResponse =
        new operations.ListInsightsAssessmentsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listInsightsAssessmentsResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListInsightsAssessmentsListInsightsAssessmentsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * To create a comment assessment for a conversation
   */
  listInsightsAssessmentsComment(
    req: operations.ListInsightsAssessmentsCommentRequest,
    security: operations.ListInsightsAssessmentsCommentSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListInsightsAssessmentsCommentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListInsightsAssessmentsCommentRequest(req);
    }

    let baseURL: string =
      operations.ListInsightsAssessmentsCommentServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string =
      baseURL.replace(/\/$/, "") + "/v1/Insights/QM/Assessments/Comments";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListInsightsAssessmentsCommentSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListInsightsAssessmentsCommentResponse =
        new operations.ListInsightsAssessmentsCommentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listInsightsAssessmentsCommentResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListInsightsAssessmentsCommentListInsightsAssessmentsCommentResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * To get conversation with segment id
   */
  listInsightsConversations(
    req: operations.ListInsightsConversationsRequest,
    security: operations.ListInsightsConversationsSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListInsightsConversationsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListInsightsConversationsRequest(req);
    }

    let baseURL: string = operations.ListInsightsConversationsServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string =
      baseURL.replace(/\/$/, "") + "/v1/Insights/Conversations";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListInsightsConversationsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListInsightsConversationsResponse =
        new operations.ListInsightsConversationsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listInsightsConversationsResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListInsightsConversationsListInsightsConversationsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * To get all questionnaires with questions
   */
  listInsightsQuestionnaires(
    req: operations.ListInsightsQuestionnairesRequest,
    security: operations.ListInsightsQuestionnairesSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListInsightsQuestionnairesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListInsightsQuestionnairesRequest(req);
    }

    let baseURL: string = operations.ListInsightsQuestionnairesServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string =
      baseURL.replace(/\/$/, "") + "/v1/Insights/QM/Questionnaires";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListInsightsQuestionnairesSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListInsightsQuestionnairesResponse =
        new operations.ListInsightsQuestionnairesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listInsightsQuestionnairesResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListInsightsQuestionnairesListInsightsQuestionnairesResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * To get all the categories
   */
  listInsightsQuestionnairesCategory(
    req: operations.ListInsightsQuestionnairesCategoryRequest,
    security: operations.ListInsightsQuestionnairesCategorySecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListInsightsQuestionnairesCategoryResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListInsightsQuestionnairesCategoryRequest(req);
    }

    let baseURL: string =
      operations.ListInsightsQuestionnairesCategoryServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string =
      baseURL.replace(/\/$/, "") + "/v1/Insights/QM/Categories";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListInsightsQuestionnairesCategorySecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListInsightsQuestionnairesCategoryResponse =
        new operations.ListInsightsQuestionnairesCategoryResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listInsightsQuestionnairesCategoryResponse =
              utils.objectToClass(
                httpRes?.data,
                operations.ListInsightsQuestionnairesCategoryListInsightsQuestionnairesCategoryResponse
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * To get all the question for the given categories
   */
  listInsightsQuestionnairesQuestion(
    req: operations.ListInsightsQuestionnairesQuestionRequest,
    security: operations.ListInsightsQuestionnairesQuestionSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListInsightsQuestionnairesQuestionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListInsightsQuestionnairesQuestionRequest(req);
    }

    let baseURL: string =
      operations.ListInsightsQuestionnairesQuestionServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string =
      baseURL.replace(/\/$/, "") + "/v1/Insights/QM/Questions";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListInsightsQuestionnairesQuestionSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListInsightsQuestionnairesQuestionResponse =
        new operations.ListInsightsQuestionnairesQuestionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listInsightsQuestionnairesQuestionResponse =
              utils.objectToClass(
                httpRes?.data,
                operations.ListInsightsQuestionnairesQuestionListInsightsQuestionnairesQuestionResponse
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * To get segments for given reservation Ids
   */
  listInsightsSegments(
    req: operations.ListInsightsSegmentsRequest,
    security: operations.ListInsightsSegmentsSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListInsightsSegmentsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListInsightsSegmentsRequest(req);
    }

    let baseURL: string = operations.ListInsightsSegmentsServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/Insights/Segments";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListInsightsSegmentsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListInsightsSegmentsResponse =
        new operations.ListInsightsSegmentsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listInsightsSegmentsResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListInsightsSegmentsListInsightsSegmentsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List all Channels for an Interaction.
   */
  listInteractionChannel(
    req: operations.ListInteractionChannelRequest,
    security: operations.ListInteractionChannelSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListInteractionChannelResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListInteractionChannelRequest(req);
    }

    let baseURL: string = operations.ListInteractionChannelServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Interactions/{InteractionSid}/Channels",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListInteractionChannelSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListInteractionChannelResponse =
        new operations.ListInteractionChannelResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listInteractionChannelResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListInteractionChannelListInteractionChannelResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List all Invites for a Channel.
   */
  listInteractionChannelInvite(
    req: operations.ListInteractionChannelInviteRequest,
    security: operations.ListInteractionChannelInviteSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListInteractionChannelInviteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListInteractionChannelInviteRequest(req);
    }

    let baseURL: string = operations.ListInteractionChannelInviteServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Interactions/{InteractionSid}/Channels/{ChannelSid}/Invites",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListInteractionChannelInviteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListInteractionChannelInviteResponse =
        new operations.ListInteractionChannelInviteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listInteractionChannelInviteResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListInteractionChannelInviteListInteractionChannelInviteResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List all Participants for a Channel.
   */
  listInteractionChannelParticipant(
    req: operations.ListInteractionChannelParticipantRequest,
    security: operations.ListInteractionChannelParticipantSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListInteractionChannelParticipantResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListInteractionChannelParticipantRequest(req);
    }

    let baseURL: string =
      operations.ListInteractionChannelParticipantServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Interactions/{InteractionSid}/Channels/{ChannelSid}/Participants",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListInteractionChannelParticipantSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListInteractionChannelParticipantResponse =
        new operations.ListInteractionChannelParticipantResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listInteractionChannelParticipantResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListInteractionChannelParticipantListInteractionChannelParticipantResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listWebChannel(
    req: operations.ListWebChannelRequest,
    security: operations.ListWebChannelSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListWebChannelResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListWebChannelRequest(req);
    }

    let baseURL: string = operations.ListWebChannelServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/WebChannels";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListWebChannelSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListWebChannelResponse =
        new operations.ListWebChannelResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listWebChannelResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListWebChannelListWebChannelResponse
            );
          }
          break;
      }

      return res;
    });
  }

  updateFlexFlow(
    req: operations.UpdateFlexFlowRequest,
    security: operations.UpdateFlexFlowSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateFlexFlowResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateFlexFlowRequest(req);
    }

    let baseURL: string = operations.UpdateFlexFlowServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v1/FlexFlows/{Sid}", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateFlexFlowSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateFlexFlowResponse =
        new operations.UpdateFlexFlowResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.flexV1FlexFlow = utils.objectToClass(
              httpRes?.data,
              shared.FlexV1FlexFlow
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update a specific Assessment assessed earlier
   */
  updateInsightsAssessments(
    req: operations.UpdateInsightsAssessmentsRequest,
    security: operations.UpdateInsightsAssessmentsSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateInsightsAssessmentsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateInsightsAssessmentsRequest(req);
    }

    let baseURL: string = operations.UpdateInsightsAssessmentsServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Insights/QM/Assessments/{AssessmentId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateInsightsAssessmentsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateInsightsAssessmentsResponse =
        new operations.UpdateInsightsAssessmentsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.flexV1InsightsAssessments = utils.objectToClass(
              httpRes?.data,
              shared.FlexV1InsightsAssessments
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * To update the questionnaire
   */
  updateInsightsQuestionnaires(
    req: operations.UpdateInsightsQuestionnairesRequest,
    security: operations.UpdateInsightsQuestionnairesSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateInsightsQuestionnairesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateInsightsQuestionnairesRequest(req);
    }

    let baseURL: string = operations.UpdateInsightsQuestionnairesServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Insights/QM/Questionnaires/{Id}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateInsightsQuestionnairesSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateInsightsQuestionnairesResponse =
        new operations.UpdateInsightsQuestionnairesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.flexV1InsightsQuestionnaires = utils.objectToClass(
              httpRes?.data,
              shared.FlexV1InsightsQuestionnaires
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * To update the category for Questions
   */
  updateInsightsQuestionnairesCategory(
    req: operations.UpdateInsightsQuestionnairesCategoryRequest,
    security: operations.UpdateInsightsQuestionnairesCategorySecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateInsightsQuestionnairesCategoryResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateInsightsQuestionnairesCategoryRequest(req);
    }

    let baseURL: string =
      operations.UpdateInsightsQuestionnairesCategoryServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Insights/QM/Categories/{CategoryId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateInsightsQuestionnairesCategorySecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateInsightsQuestionnairesCategoryResponse =
        new operations.UpdateInsightsQuestionnairesCategoryResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.flexV1InsightsQuestionnairesCategory = utils.objectToClass(
              httpRes?.data,
              shared.FlexV1InsightsQuestionnairesCategory
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * To update the question
   */
  updateInsightsQuestionnairesQuestion(
    req: operations.UpdateInsightsQuestionnairesQuestionRequest,
    security: operations.UpdateInsightsQuestionnairesQuestionSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateInsightsQuestionnairesQuestionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateInsightsQuestionnairesQuestionRequest(req);
    }

    let baseURL: string =
      operations.UpdateInsightsQuestionnairesQuestionServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Insights/QM/Questions/{QuestionId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateInsightsQuestionnairesQuestionSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateInsightsQuestionnairesQuestionResponse =
        new operations.UpdateInsightsQuestionnairesQuestionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.flexV1InsightsQuestionnairesQuestion = utils.objectToClass(
              httpRes?.data,
              shared.FlexV1InsightsQuestionnairesQuestion
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing Interaction Channel.
   */
  updateInteractionChannel(
    req: operations.UpdateInteractionChannelRequest,
    security: operations.UpdateInteractionChannelSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateInteractionChannelResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateInteractionChannelRequest(req);
    }

    let baseURL: string = operations.UpdateInteractionChannelServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Interactions/{InteractionSid}/Channels/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateInteractionChannelSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateInteractionChannelResponse =
        new operations.UpdateInteractionChannelResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.flexV1InteractionInteractionChannel = utils.objectToClass(
              httpRes?.data,
              shared.FlexV1InteractionInteractionChannel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing Channel Participant.
   */
  updateInteractionChannelParticipant(
    req: operations.UpdateInteractionChannelParticipantRequest,
    security: operations.UpdateInteractionChannelParticipantSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateInteractionChannelParticipantResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateInteractionChannelParticipantRequest(req);
    }

    let baseURL: string =
      operations.UpdateInteractionChannelParticipantServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Interactions/{InteractionSid}/Channels/{ChannelSid}/Participants/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateInteractionChannelParticipantSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateInteractionChannelParticipantResponse =
        new operations.UpdateInteractionChannelParticipantResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.flexV1InteractionInteractionChannelInteractionChannelParticipant =
              utils.objectToClass(
                httpRes?.data,
                shared.FlexV1InteractionInteractionChannelInteractionChannelParticipant
              );
          }
          break;
      }

      return res;
    });
  }

  updateWebChannel(
    req: operations.UpdateWebChannelRequest,
    security: operations.UpdateWebChannelSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateWebChannelResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateWebChannelRequest(req);
    }

    let baseURL: string = operations.UpdateWebChannelServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/WebChannels/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateWebChannelSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateWebChannelResponse =
        new operations.UpdateWebChannelResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.flexV1WebChannel = utils.objectToClass(
              httpRes?.data,
              shared.FlexV1WebChannel
            );
          }
          break;
      }

      return res;
    });
  }
}
