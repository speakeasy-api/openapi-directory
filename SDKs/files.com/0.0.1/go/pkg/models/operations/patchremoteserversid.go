// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"fmt"
	"net/http"
	"openapi/pkg/models/shared"
)

type PatchRemoteServersIDPathParams struct {
	// Remote Server ID.
	ID int `pathParam:"style=simple,explode=false,name=id"`
}

// PatchRemoteServersIDRequestBodyOneDriveAccountTypeEnum - Either personal or business_other account types
type PatchRemoteServersIDRequestBodyOneDriveAccountTypeEnum string

const (
	PatchRemoteServersIDRequestBodyOneDriveAccountTypeEnumPersonal      PatchRemoteServersIDRequestBodyOneDriveAccountTypeEnum = "personal"
	PatchRemoteServersIDRequestBodyOneDriveAccountTypeEnumBusinessOther PatchRemoteServersIDRequestBodyOneDriveAccountTypeEnum = "business_other"
)

func (e *PatchRemoteServersIDRequestBodyOneDriveAccountTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "personal":
		fallthrough
	case "business_other":
		*e = PatchRemoteServersIDRequestBodyOneDriveAccountTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for PatchRemoteServersIDRequestBodyOneDriveAccountTypeEnum: %s", s)
	}
}

// PatchRemoteServersIDRequestBodyServerCertificateEnum - Remote server certificate
type PatchRemoteServersIDRequestBodyServerCertificateEnum string

const (
	PatchRemoteServersIDRequestBodyServerCertificateEnumRequireMatch PatchRemoteServersIDRequestBodyServerCertificateEnum = "require_match"
	PatchRemoteServersIDRequestBodyServerCertificateEnumAllowAny     PatchRemoteServersIDRequestBodyServerCertificateEnum = "allow_any"
)

func (e *PatchRemoteServersIDRequestBodyServerCertificateEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "require_match":
		fallthrough
	case "allow_any":
		*e = PatchRemoteServersIDRequestBodyServerCertificateEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for PatchRemoteServersIDRequestBodyServerCertificateEnum: %s", s)
	}
}

// PatchRemoteServersIDRequestBodyServerTypeEnum - Remote server type.
type PatchRemoteServersIDRequestBodyServerTypeEnum string

const (
	PatchRemoteServersIDRequestBodyServerTypeEnumFtp                PatchRemoteServersIDRequestBodyServerTypeEnum = "ftp"
	PatchRemoteServersIDRequestBodyServerTypeEnumSftp               PatchRemoteServersIDRequestBodyServerTypeEnum = "sftp"
	PatchRemoteServersIDRequestBodyServerTypeEnumS3                 PatchRemoteServersIDRequestBodyServerTypeEnum = "s3"
	PatchRemoteServersIDRequestBodyServerTypeEnumGoogleCloudStorage PatchRemoteServersIDRequestBodyServerTypeEnum = "google_cloud_storage"
	PatchRemoteServersIDRequestBodyServerTypeEnumWebdav             PatchRemoteServersIDRequestBodyServerTypeEnum = "webdav"
	PatchRemoteServersIDRequestBodyServerTypeEnumWasabi             PatchRemoteServersIDRequestBodyServerTypeEnum = "wasabi"
	PatchRemoteServersIDRequestBodyServerTypeEnumBackblazeB2        PatchRemoteServersIDRequestBodyServerTypeEnum = "backblaze_b2"
	PatchRemoteServersIDRequestBodyServerTypeEnumOneDrive           PatchRemoteServersIDRequestBodyServerTypeEnum = "one_drive"
	PatchRemoteServersIDRequestBodyServerTypeEnumRackspace          PatchRemoteServersIDRequestBodyServerTypeEnum = "rackspace"
	PatchRemoteServersIDRequestBodyServerTypeEnumBox                PatchRemoteServersIDRequestBodyServerTypeEnum = "box"
	PatchRemoteServersIDRequestBodyServerTypeEnumDropbox            PatchRemoteServersIDRequestBodyServerTypeEnum = "dropbox"
	PatchRemoteServersIDRequestBodyServerTypeEnumGoogleDrive        PatchRemoteServersIDRequestBodyServerTypeEnum = "google_drive"
	PatchRemoteServersIDRequestBodyServerTypeEnumAzure              PatchRemoteServersIDRequestBodyServerTypeEnum = "azure"
	PatchRemoteServersIDRequestBodyServerTypeEnumSharepoint         PatchRemoteServersIDRequestBodyServerTypeEnum = "sharepoint"
	PatchRemoteServersIDRequestBodyServerTypeEnumS3Compatible       PatchRemoteServersIDRequestBodyServerTypeEnum = "s3_compatible"
)

func (e *PatchRemoteServersIDRequestBodyServerTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "ftp":
		fallthrough
	case "sftp":
		fallthrough
	case "s3":
		fallthrough
	case "google_cloud_storage":
		fallthrough
	case "webdav":
		fallthrough
	case "wasabi":
		fallthrough
	case "backblaze_b2":
		fallthrough
	case "one_drive":
		fallthrough
	case "rackspace":
		fallthrough
	case "box":
		fallthrough
	case "dropbox":
		fallthrough
	case "google_drive":
		fallthrough
	case "azure":
		fallthrough
	case "sharepoint":
		fallthrough
	case "s3_compatible":
		*e = PatchRemoteServersIDRequestBodyServerTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for PatchRemoteServersIDRequestBodyServerTypeEnum: %s", s)
	}
}

// PatchRemoteServersIDRequestBodySslEnum - Should we require SSL?
type PatchRemoteServersIDRequestBodySslEnum string

const (
	PatchRemoteServersIDRequestBodySslEnumIfAvailable     PatchRemoteServersIDRequestBodySslEnum = "if_available"
	PatchRemoteServersIDRequestBodySslEnumRequire         PatchRemoteServersIDRequestBodySslEnum = "require"
	PatchRemoteServersIDRequestBodySslEnumRequireImplicit PatchRemoteServersIDRequestBodySslEnum = "require_implicit"
	PatchRemoteServersIDRequestBodySslEnumNever           PatchRemoteServersIDRequestBodySslEnum = "never"
)

func (e *PatchRemoteServersIDRequestBodySslEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "if_available":
		fallthrough
	case "require":
		fallthrough
	case "require_implicit":
		fallthrough
	case "never":
		*e = PatchRemoteServersIDRequestBodySslEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for PatchRemoteServersIDRequestBodySslEnum: %s", s)
	}
}

type PatchRemoteServersIDRequestBody struct {
	// AWS Access Key.
	AwsAccessKey *string `multipartForm:"name=aws_access_key"`
	// AWS secret key.
	AwsSecretKey *string `multipartForm:"name=aws_secret_key"`
	// Azure Blob Storage secret key.
	AzureBlobStorageAccessKey *string `multipartForm:"name=azure_blob_storage_access_key"`
	// Azure Blob Storage Account name
	AzureBlobStorageAccount *string `multipartForm:"name=azure_blob_storage_account"`
	// Azure Blob Storage Container name
	AzureBlobStorageContainer *string `multipartForm:"name=azure_blob_storage_container"`
	// Backblaze B2 Cloud Storage applicationKey.
	BackblazeB2ApplicationKey *string `multipartForm:"name=backblaze_b2_application_key"`
	// Backblaze B2 Cloud Storage Bucket name
	BackblazeB2Bucket *string `multipartForm:"name=backblaze_b2_bucket"`
	// Backblaze B2 Cloud Storage keyID.
	BackblazeB2KeyID *string `multipartForm:"name=backblaze_b2_key_id"`
	// Backblaze B2 Cloud Storage S3 Endpoint
	BackblazeB2S3Endpoint *string `multipartForm:"name=backblaze_b2_s3_endpoint"`
	// `true` if remote server only accepts connections from dedicated IPs
	EnableDedicatedIps *bool `multipartForm:"name=enable_dedicated_ips"`
	// Google Cloud Storage bucket name
	GoogleCloudStorageBucket *string `multipartForm:"name=google_cloud_storage_bucket"`
	// A JSON file that contains the private key. To generate see https://cloud.google.com/storage/docs/json_api/v1/how-tos/authorizing#APIKey
	GoogleCloudStorageCredentialsJSON *string `multipartForm:"name=google_cloud_storage_credentials_json"`
	// Google Cloud Project ID
	GoogleCloudStorageProjectID *string `multipartForm:"name=google_cloud_storage_project_id"`
	// Hostname or IP address
	Hostname *string `multipartForm:"name=hostname"`
	// Max number of parallel connections.  Ignored for S3 connections (we will parallelize these as much as possible).
	MaxConnections *int `multipartForm:"name=max_connections"`
	// Internal name for your reference
	Name *string `multipartForm:"name=name"`
	// Either personal or business_other account types
	OneDriveAccountType *PatchRemoteServersIDRequestBodyOneDriveAccountTypeEnum `multipartForm:"name=one_drive_account_type"`
	// Password if needed.
	Password *string `multipartForm:"name=password"`
	// Port for remote server.  Not needed for S3.
	Port *int `multipartForm:"name=port"`
	// Private key if needed.
	PrivateKey *string `multipartForm:"name=private_key"`
	// Rackspace API key from the Rackspace Cloud Control Panel.
	RackspaceAPIKey *string `multipartForm:"name=rackspace_api_key"`
	// The name of the container (top level directory) where files will sync.
	RackspaceContainer *string `multipartForm:"name=rackspace_container"`
	// Three letter airport code for Rackspace region. See https://support.rackspace.com/how-to/about-regions/
	RackspaceRegion *string `multipartForm:"name=rackspace_region"`
	// Rackspace username used to login to the Rackspace Cloud Control Panel.
	RackspaceUsername *string `multipartForm:"name=rackspace_username"`
	// Reset authenticated account
	ResetAuthentication *bool `multipartForm:"name=reset_authentication"`
	// S3 bucket name
	S3Bucket *string `multipartForm:"name=s3_bucket"`
	// S3-compatible access key
	S3CompatibleAccessKey *string `multipartForm:"name=s3_compatible_access_key"`
	// S3-compatible Bucket name
	S3CompatibleBucket *string `multipartForm:"name=s3_compatible_bucket"`
	// S3-compatible endpoint
	S3CompatibleEndpoint *string `multipartForm:"name=s3_compatible_endpoint"`
	// S3-compatible Bucket name
	S3CompatibleRegion *string `multipartForm:"name=s3_compatible_region"`
	// S3-compatible secret key
	S3CompatibleSecretKey *string `multipartForm:"name=s3_compatible_secret_key"`
	// S3 region
	S3Region *string `multipartForm:"name=s3_region"`
	// Remote server certificate
	ServerCertificate *PatchRemoteServersIDRequestBodyServerCertificateEnum `multipartForm:"name=server_certificate"`
	// Remote server SSH Host Key. If provided, we will require that the server host key matches the provided key. Uses OpenSSH format similar to what would go into ~/.ssh/known_hosts
	ServerHostKey *string `multipartForm:"name=server_host_key"`
	// Remote server type.
	ServerType *PatchRemoteServersIDRequestBodyServerTypeEnum `multipartForm:"name=server_type"`
	// Should we require SSL?
	Ssl *PatchRemoteServersIDRequestBodySslEnum `multipartForm:"name=ssl"`
	// SSL client certificate.
	SslCertificate *string `multipartForm:"name=ssl_certificate"`
	// Remote server username.  Not needed for S3 buckets.
	Username *string `multipartForm:"name=username"`
	// Wasabi access key.
	WasabiAccessKey *string `multipartForm:"name=wasabi_access_key"`
	// Wasabi Bucket name
	WasabiBucket *string `multipartForm:"name=wasabi_bucket"`
	// Wasabi region
	WasabiRegion *string `multipartForm:"name=wasabi_region"`
	// Wasabi secret key.
	WasabiSecretKey *string `multipartForm:"name=wasabi_secret_key"`
}

type PatchRemoteServersIDRequest struct {
	PathParams PatchRemoteServersIDPathParams
	Request    *PatchRemoteServersIDRequestBody `request:"mediaType=multipart/form-data"`
}

type PatchRemoteServersIDResponse struct {
	ContentType string
	// The RemoteServers object.
	RemoteServerEntity *shared.RemoteServerEntity
	StatusCode         int
	RawResponse        *http.Response
}
