"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
import requests as requests_http
from ..shared import artifactmetadata as shared_artifactmetadata
from ..shared import contentcreaterequest as shared_contentcreaterequest
from ..shared import error as shared_error
from ..shared import ifexists_enum as shared_ifexists_enum
from ..shared import ruleviolationerror as shared_ruleviolationerror
from enum import Enum
from typing import Optional

class CreateArtifactJSONXRegistryHashAlgorithmEnum(str, Enum):
    r"""The algorithm to use when checking the content validity. (available: SHA256, MD5; default: SHA256)"""
    SHA256 = 'SHA256'
    MD5 = 'MD5'


@dataclasses.dataclass
class CreateArtifactJSONRequest:
    
    content_create_request: shared_contentcreaterequest.ContentCreateRequest = dataclasses.field(metadata={'request': { 'media_type': 'application/vnd.create.extended+json' }})
    r"""The content of the artifact being created. This is often, but not always, JSON data
    representing one of the supported artifact types:
    
    * Avro (`AVRO`)
    * Protobuf (`PROTOBUF`)
    * JSON Schema (`JSON`)
    * Kafka Connect (`KCONNECT`)
    * OpenAPI (`OPENAPI`)
    * AsyncAPI (`ASYNCAPI`)
    * GraphQL (`GRAPHQL`)
    * Web Services Description Language (`WSDL`)
    * XML Schema (`XSD`)
    """  
    group_id: str = dataclasses.field(metadata={'path_param': { 'field_name': 'groupId', 'style': 'simple', 'explode': False }})
    r"""The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts."""  
    canonical: Optional[bool] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'canonical', 'style': 'form', 'explode': True }})
    r"""Used only when the `ifExists` query parameter is set to `RETURN_OR_UPDATE`, this parameter can be set to `true` to indicate that the server should \\"canonicalize\\" the content when searching for a matching version.  The canonicalization algorithm is unique to each artifact type, but typically involves removing extra whitespace and formatting the content in a consistent manner."""  
    if_exists: Optional[shared_ifexists_enum.IfExistsEnum] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'ifExists', 'style': 'form', 'explode': True }})
    r"""Set this option to instruct the server on what to do if the artifact already exists."""  
    x_registry_artifact_id: Optional[str] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'X-Registry-ArtifactId', 'style': 'simple', 'explode': False }})
    r"""A client-provided, globally unique identifier for the new artifact."""  
    x_registry_artifact_type: Optional[str] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'X-Registry-ArtifactType', 'style': 'simple', 'explode': False }})
    r"""Specifies the type of the artifact being added. Possible values include:
    
    * Avro (`AVRO`)
    * Protobuf (`PROTOBUF`)
    * JSON Schema (`JSON`)
    * Kafka Connect (`KCONNECT`)
    * OpenAPI (`OPENAPI`)
    * AsyncAPI (`ASYNCAPI`)
    * GraphQL (`GRAPHQL`)
    * Web Services Description Language (`WSDL`)
    * XML Schema (`XSD`)
    """  
    x_registry_content_hash: Optional[str] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'X-Registry-Content-Hash', 'style': 'simple', 'explode': False }})
    r"""Specifies the (optional) hash of the artifact to be verified."""  
    x_registry_description: Optional[str] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'X-Registry-Description', 'style': 'simple', 'explode': False }})
    r"""Specifies the description of artifact being added. Description must be ASCII-only string. If this is not provided, the server will extract the description from the artifact content."""  
    x_registry_description_encoded: Optional[str] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'X-Registry-Description-Encoded', 'style': 'simple', 'explode': False }})
    r"""Specifies the description of artifact being added. Value of this must be Base64 encoded string. If this is not provided, the server will extract the description from the artifact content."""  
    x_registry_hash_algorithm: Optional[CreateArtifactJSONXRegistryHashAlgorithmEnum] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'X-Registry-Hash-Algorithm', 'style': 'simple', 'explode': False }})
    r"""The algorithm to use when checking the content validity. (available: SHA256, MD5; default: SHA256)"""  
    x_registry_name: Optional[str] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'X-Registry-Name', 'style': 'simple', 'explode': False }})
    r"""Specifies the name of artifact being added. Name must be ASCII-only string. If this is not provided, the server will extract the name from the artifact content."""  
    x_registry_name_encoded: Optional[str] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'X-Registry-Name-Encoded', 'style': 'simple', 'explode': False }})
    r"""Specifies the name of artifact being added. Value of this must be Base64 encoded string. If this is not provided, the server will extract the name from the artifact content."""  
    x_registry_version: Optional[str] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'X-Registry-Version', 'style': 'simple', 'explode': False }})
    r"""Specifies the version number of this initial version of the artifact content.  This would typically
    be a simple integer or a SemVer value.  If not provided, the server will assign a version number
    automatically (starting with version `1`).
    """  
    

@dataclasses.dataclass
class CreateArtifactJSONResponse:
    
    content_type: str = dataclasses.field()  
    status_code: int = dataclasses.field()  
    artifact_meta_data: Optional[shared_artifactmetadata.ArtifactMetaData] = dataclasses.field(default=None)
    r"""Artifact was successfully created."""  
    error: Optional[shared_error.Error] = dataclasses.field(default=None)
    r"""Common response for all operations that can return a `400` error."""  
    raw_response: Optional[requests_http.Response] = dataclasses.field(default=None)  
    rule_violation_error: Optional[shared_ruleviolationerror.RuleViolationError] = dataclasses.field(default=None)
    r"""Common response used when an input conflicts with existing data."""  
    