<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class RootCluster 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * Add a KMIP server
     * 
     * Add the specified KMIP server to the set of active KMIP servers.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\AddKmipServerRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\AddKmipServerResponse
     */
	public function addKmipServer(
        \OpenAPI\OpenAPI\Models\Operations\AddKmipServerRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\AddKmipServerResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/cluster/{id}/security/kmip/server', \OpenAPI\OpenAPI\Models\Operations\AddKmipServerRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "kmipServerConfiguration", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\AddKmipServerResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 202) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->asyncRequestStatus = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AsyncRequestStatus', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Add a new syslog export rule
     * 
     * Adds a new rule specifying where to export the specified syslog information.
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\SyslogExportRuleFull $request
     * @return \OpenAPI\OpenAPI\Models\Operations\AddSyslogExportRuleResponse
     */
	public function addSyslogExportRule(
        \OpenAPI\OpenAPI\Models\Shared\SyslogExportRuleFull $request,
    ): \OpenAPI\OpenAPI\Models\Operations\AddSyslogExportRuleResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/syslog/export');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\AddSyslogExportRuleResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->syslogExportRuleSummary = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\SyslogExportRuleSummary', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Retrieve CDM versions available for upgrade
     * 
     * Retrieve a list of Rubrik CDM versions available to upgrade the Rubrik cluster.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\AvailableVersionRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\AvailableVersionResponse
     */
	public function availableVersion(
        \OpenAPI\OpenAPI\Models\Operations\AvailableVersionRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\AvailableVersionResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/cluster/{id}/upgrade/available_version', \OpenAPI\OpenAPI\Models\Operations\AvailableVersionRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\AvailableVersionRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\AvailableVersionResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->availableVersionInfos = $serializer->deserialize((string)$httpResponse->getBody(), 'array<OpenAPI\OpenAPI\Models\Shared\AvailableVersionInfo>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Change hostname for nodes in a Rubrik cluster
     * 
     * Change hostnames for multiple nodes at a time, for a specified Rubrik cluster.
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ChangeClusterNodeHostnamesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ChangeClusterNodeHostnamesResponse
     */
	public function changeClusterNodeHostnames(
        \OpenAPI\OpenAPI\Models\Operations\ChangeClusterNodeHostnamesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ChangeClusterNodeHostnamesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/cluster/{id}/node_hostname', \OpenAPI\OpenAPI\Models\Operations\ChangeClusterNodeHostnamesRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ChangeClusterNodeHostnamesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
	
    /**
     * Remove the specified KMIP server
     * 
     * Remove the server with the specified server address from the set of active KMIP servers.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteKmipServerRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteKmipServerResponse
     */
	public function deleteKmipServer(
        \OpenAPI\OpenAPI\Models\Operations\DeleteKmipServerRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteKmipServerResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/cluster/{id}/security/kmip/server', \OpenAPI\OpenAPI\Models\Operations\DeleteKmipServerRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DeleteKmipServerRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteKmipServerResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 202) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->asyncRequestStatus = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AsyncRequestStatus', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Delete the specified syslog export rule
     * 
     * Delete the syslog export rule specified by the given id.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteSyslogExportRuleRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteSyslogExportRuleResponse
     */
	public function deleteSyslogExportRule(
        \OpenAPI\OpenAPI\Models\Operations\DeleteSyslogExportRuleRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteSyslogExportRuleResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/syslog/export/{id}', \OpenAPI\OpenAPI\Models\Operations\DeleteSyslogExportRuleRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteSyslogExportRuleResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
	
    /**
     * Get asynchronous request details
     * 
     * Get asynchronous request details for an upgrade request.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetAsyncRequestStatusForUpgradeRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetAsyncRequestStatusForUpgradeResponse
     */
	public function getAsyncRequestStatusForUpgrade(
        \OpenAPI\OpenAPI\Models\Operations\GetAsyncRequestStatusForUpgradeRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetAsyncRequestStatusForUpgradeResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/cluster/{id}/upgrade/request/{request_id}', \OpenAPI\OpenAPI\Models\Operations\GetAsyncRequestStatusForUpgradeRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetAsyncRequestStatusForUpgradeResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 202) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->asyncRequestStatus = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AsyncRequestStatus', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get cluster REST API version
     * 
     * Retrieves software version of the Rubrik cluster.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetClusterApiVersionRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetClusterApiVersionResponse
     */
	public function getClusterApiVersion(
        \OpenAPI\OpenAPI\Models\Operations\GetClusterApiVersionRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetClusterApiVersionResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/cluster/{id}/api_version', \OpenAPI\OpenAPI\Models\Operations\GetClusterApiVersionRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetClusterApiVersionResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->clusterApiVersion = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ClusterApiVersion', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get the cluster certificate
     * 
     * Returns the cluster certificate.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetClusterCertificateRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetClusterCertificateResponse
     */
	public function getClusterCertificate(
        \OpenAPI\OpenAPI\Models\Operations\GetClusterCertificateRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetClusterCertificateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/cluster/{id}/certificate', \OpenAPI\OpenAPI\Models\Operations\GetClusterCertificateRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetClusterCertificateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->clusterCertificate = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ClusterCertificate', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get the node ID to hostname mapping for all the nodes in a Rubrik cluster
     * 
     * 
     * Retrieve the ID to hostname mapping for all the nodes that belong to a specified Rubrik cluster.
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetClusterNodeHostnamesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetClusterNodeHostnamesResponse
     */
	public function getClusterNodeHostnames(
        \OpenAPI\OpenAPI\Models\Operations\GetClusterNodeHostnamesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetClusterNodeHostnamesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/cluster/{id}/node_hostname', \OpenAPI\OpenAPI\Models\Operations\GetClusterNodeHostnamesRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetClusterNodeHostnamesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->nodeHostnameInfoListResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\NodeHostnameInfoListResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get the name of the nodes in the cluster
     * 
     * Retrieve the list of node IDs for the nodes in this Rubrik CDM cluster.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetClusterNodeIdsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetClusterNodeIdsResponse
     */
	public function getClusterNodeIds(
        \OpenAPI\OpenAPI\Models\Operations\GetClusterNodeIdsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetClusterNodeIdsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/cluster/{id}/node_id', \OpenAPI\OpenAPI\Models\Operations\GetClusterNodeIdsRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetClusterNodeIdsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->nodeIds = $serializer->deserialize((string)$httpResponse->getBody(), 'array<OpenAPI\OpenAPI\Models\Shared\NodeId>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get cluster software version
     * 
     * Retrieves software version of the Rubrik cluster.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetClusterVersionRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetClusterVersionResponse
     */
	public function getClusterVersion(
        \OpenAPI\OpenAPI\Models\Operations\GetClusterVersionRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetClusterVersionResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/cluster/{id}/version', \OpenAPI\OpenAPI\Models\Operations\GetClusterVersionRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetClusterVersionResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->clusterVersion = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ClusterVersion', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get CORS configuration
     * 
     * Get the current CORS support configuration for a web server.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetCorsConfigurationRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetCorsConfigurationResponse
     */
	public function getCorsConfiguration(
        \OpenAPI\OpenAPI\Models\Operations\GetCorsConfigurationRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetCorsConfigurationResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/cluster/{id}/security/cors', \OpenAPI\OpenAPI\Models\Operations\GetCorsConfigurationRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetCorsConfigurationResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->corsConfiguration = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CorsConfiguration', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get encryption at rest status
     * 
     * Get the current encryption at rest status of the cluster.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetEncryptionStatusRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetEncryptionStatusResponse
     */
	public function getEncryptionStatus(
        \OpenAPI\OpenAPI\Models\Operations\GetEncryptionStatusRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetEncryptionStatusResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/cluster/{id}/security/encryption', \OpenAPI\OpenAPI\Models\Operations\GetEncryptionStatusRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetEncryptionStatusResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->encryptionStatus = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\EncryptionStatus', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get FIPS enablement status
     * 
     * Returns the current status of FIPS on the specified cluster. When the status is true, FIPS is enabled.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetFipsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetFipsResponse
     */
	public function getFips(
        \OpenAPI\OpenAPI\Models\Operations\GetFipsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetFipsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/cluster/{id}/security/fips', \OpenAPI\OpenAPI\Models\Operations\GetFipsRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetFipsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->fipsStatus = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\FipsStatus', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get the KMIP client configuration
     * 
     * Return the currently configured KMIP client information. The response object contains empty fields when KMIP is not configured.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetKmipClientRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetKmipClientResponse
     */
	public function getKmipClient(
        \OpenAPI\OpenAPI\Models\Operations\GetKmipClientRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetKmipClientResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/cluster/{id}/security/kmip/client', \OpenAPI\OpenAPI\Models\Operations\GetKmipClientRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetKmipClientResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->kmipClientDetail = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\KmipClientDetail', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get KMIP server information
     * 
     * Returns the KMIP server information for the specified server address. When no server address is specified, this call returns information on all active KMIP servers. The response array is empty when KMIP is not configured or when the server address cannot be found.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetKmipServerRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetKmipServerResponse
     */
	public function getKmipServer(
        \OpenAPI\OpenAPI\Models\Operations\GetKmipServerRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetKmipServerResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/cluster/{id}/security/kmip/server', \OpenAPI\OpenAPI\Models\Operations\GetKmipServerRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetKmipServerRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetKmipServerResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->kmipServerDetails = $serializer->deserialize((string)$httpResponse->getBody(), 'array<OpenAPI\OpenAPI\Models\Shared\KmipServerConfiguration>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get the result of the latest run of the upgrade prechecks
     * 
     * Get the result of the latest run of the upgrade prechecks.
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetPeriodicUpgradePrechecksStatusRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetPeriodicUpgradePrechecksStatusResponse
     */
	public function getPeriodicUpgradePrechecksStatus(
        \OpenAPI\OpenAPI\Models\Operations\GetPeriodicUpgradePrechecksStatusRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetPeriodicUpgradePrechecksStatusResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/cluster/{id}/upgrade/precheck_status', \OpenAPI\OpenAPI\Models\Operations\GetPeriodicUpgradePrechecksStatusRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetPeriodicUpgradePrechecksStatusRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetPeriodicUpgradePrechecksStatusResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->precheckStatusResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\PrecheckStatusResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get cluster details
     * 
     * Retrieve public information about the Rubrik cluster.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetPublicClusterInfoRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetPublicClusterInfoResponse
     */
	public function getPublicClusterInfo(
        \OpenAPI\OpenAPI\Models\Operations\GetPublicClusterInfoRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetPublicClusterInfoResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/cluster/{id}', \OpenAPI\OpenAPI\Models\Operations\GetPublicClusterInfoRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetPublicClusterInfoResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->clusterInfo = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ClusterInfo', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get the link for Rubrik SNMP MIB file
     * 
     * Retrieve the download link for the Rubrik SNMP MIB file. The retrieval is a synchronous operation.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRubrikSnmpMibDownloadLinkRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRubrikSnmpMibDownloadLinkResponse
     */
	public function getRubrikSnmpMibDownloadLink(
        \OpenAPI\OpenAPI\Models\Operations\GetRubrikSnmpMibDownloadLinkRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRubrikSnmpMibDownloadLinkResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/cluster/{id}/snmp_mib_link', \OpenAPI\OpenAPI\Models\Operations\GetRubrikSnmpMibDownloadLinkRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRubrikSnmpMibDownloadLinkResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->rubrikMibFileDownloadLink = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\RubrikMibFileDownloadLink', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get the specified syslog export rule
     * 
     * Get the summary of the syslog export rule specified by the given id.
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetSyslogExportRuleRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetSyslogExportRuleResponse
     */
	public function getSyslogExportRule(
        \OpenAPI\OpenAPI\Models\Operations\GetSyslogExportRuleRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetSyslogExportRuleResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/syslog/export/{id}', \OpenAPI\OpenAPI\Models\Operations\GetSyslogExportRuleRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetSyslogExportRuleResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->syslogExportRuleSummary = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\SyslogExportRuleSummary', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get the configured syslog export rules
     * 
     * Return the list of all configured syslog export rules.
     * 
     * @return \OpenAPI\OpenAPI\Models\Operations\GetSyslogExportRulesResponse
     */
	public function getSyslogExportRules(
    ): \OpenAPI\OpenAPI\Models\Operations\GetSyslogExportRulesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/syslog/export');
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetSyslogExportRulesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->syslogExportRuleSummaryListResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\SyslogExportRuleSummaryListResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get the link for SYSLOG-MSG-MIB file
     * 
     * Retrieve the download link for the SYSLOG-MSG-MIB file. The retrieval is a synchronous operation.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetSyslogMsgSnmpMibDownloadLinkRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetSyslogMsgSnmpMibDownloadLinkResponse
     */
	public function getSyslogMsgSnmpMibDownloadLink(
        \OpenAPI\OpenAPI\Models\Operations\GetSyslogMsgSnmpMibDownloadLinkRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetSyslogMsgSnmpMibDownloadLinkResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/cluster/{id}/syslog_msg_mib_link', \OpenAPI\OpenAPI\Models\Operations\GetSyslogMsgSnmpMibDownloadLinkRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetSyslogMsgSnmpMibDownloadLinkResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->syslogMsgMibFileDownloadLink = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\SyslogMsgMibFileDownloadLink', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get the link for SYSLOG-TC-MIB file
     * 
     * Retrieve the download link for the SYSLOG-TC-MIB file. The retrieval is a synchronous operation.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetSyslogTcSnmpMibDownloadLinkRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetSyslogTcSnmpMibDownloadLinkResponse
     */
	public function getSyslogTcSnmpMibDownloadLink(
        \OpenAPI\OpenAPI\Models\Operations\GetSyslogTcSnmpMibDownloadLinkRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetSyslogTcSnmpMibDownloadLinkResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/cluster/{id}/syslog_tc_mib_link', \OpenAPI\OpenAPI\Models\Operations\GetSyslogTcSnmpMibDownloadLinkRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetSyslogTcSnmpMibDownloadLinkResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->syslogTcMibFileDownloadLink = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\SyslogTcMibFileDownloadLink', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get global TOTP setting
     * 
     * Returns TOTP global setting, including whether TOTP is enforced or not.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetTotpGlobalSettingRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetTotpGlobalSettingResponse
     */
	public function getTotpGlobalSetting(
        \OpenAPI\OpenAPI\Models\Operations\GetTotpGlobalSettingRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetTotpGlobalSettingResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/cluster/{id}/security/totp/setting', \OpenAPI\OpenAPI\Models\Operations\GetTotpGlobalSettingRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetTotpGlobalSettingResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->totpGlobalSetting = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\TotpGlobalSetting', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get summary of all truststores
     * 
     * Get summary of all truststores.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetTruststoresRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetTruststoresResponse
     */
	public function getTruststores(
        \OpenAPI\OpenAPI\Models\Operations\GetTruststoresRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetTruststoresResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/cluster/{id}/security/truststore', \OpenAPI\OpenAPI\Models\Operations\GetTruststoresRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetTruststoresResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->truststoreSummaryListResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\TruststoreSummaryListResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get the signed certificate for Web server
     * 
     * If the web server uses a signed certificate, fetch it.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetWebSignedCertificateRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetWebSignedCertificateResponse
     */
	public function getWebSignedCertificate(
        \OpenAPI\OpenAPI\Models\Operations\GetWebSignedCertificateRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetWebSignedCertificateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/cluster/{id}/security/web_signed_cert', \OpenAPI\OpenAPI\Models\Operations\GetWebSignedCertificateRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetWebSignedCertificateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->webServerCertificateSummary = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\WebServerCertificateSummary', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Check credentials to the Rubrik support portal
     * 
     * Check whether the specified Rubrik cluster has an existing set of credentials for the Rubrik support portal.
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\HasRubrikSupportPortalCredentialsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\HasRubrikSupportPortalCredentialsResponse
     */
	public function hasRubrikSupportPortalCredentials(
        \OpenAPI\OpenAPI\Models\Operations\HasRubrikSupportPortalCredentialsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\HasRubrikSupportPortalCredentialsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/cluster/{id}/rubrik_support_portal_credentials', \OpenAPI\OpenAPI\Models\Operations\HasRubrikSupportPortalCredentialsRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\HasRubrikSupportPortalCredentialsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->booleanResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\BooleanResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Manually discover nodes
     * 
     * Manually specifies mDNS discovery data. Output for this endpoint is identical to the output of the 'discover' endpoint.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ManualDiscoverRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ManualDiscoverResponse
     */
	public function manualDiscover(
        \OpenAPI\OpenAPI\Models\Operations\ManualDiscoverRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ManualDiscoverResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/cluster/{id}/manual_discover', \OpenAPI\OpenAPI\Models\Operations\ManualDiscoverRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "manualDiscoveryNodeInfo", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ManualDiscoverResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->manualDiscoveryNodeInfo = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ManualDiscoveryNodeInfo', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Manually discover nodes over IPv4 address
     * 
     * Manually specifies discovery data. This endpoint output is identical to the output of the 'discover' endpoint.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ManualDiscoverIpv4Request $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ManualDiscoverIpv4Response
     */
	public function manualDiscoverIpv4(
        \OpenAPI\OpenAPI\Models\Operations\ManualDiscoverIpv4Request $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ManualDiscoverIpv4Response
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/cluster/{id}/manual_discover_ipv4', \OpenAPI\OpenAPI\Models\Operations\ManualDiscoverIpv4Request::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "manualDiscoveryNodeIpv4Info", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ManualDiscoverIpv4Response();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->manualDiscoveryNodeIpv4Info = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ManualDiscoveryNodeIpv4Info', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get event notifications
     * 
     * Gets notifications about events from a specified set of possible events.
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\MonitorEventsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\MonitorEventsResponse
     */
	public function monitorEvents(
        \OpenAPI\OpenAPI\Models\Operations\MonitorEventsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\MonitorEventsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/cluster/me/upgrade/monitor_events');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\MonitorEventsRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\MonitorEventsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->eventNotifications = $serializer->deserialize((string)$httpResponse->getBody(), 'array<OpenAPI\OpenAPI\Models\Shared\EventNotification>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Set password requirements
     * 
     * Update user password requirements for a cluster.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PatchPasswordRequirementsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PatchPasswordRequirementsResponse
     */
	public function patchPasswordRequirements(
        \OpenAPI\OpenAPI\Models\Operations\PatchPasswordRequirementsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PatchPasswordRequirementsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/cluster/{id}/security/password_requirements', \OpenAPI\OpenAPI\Models\Operations\PatchPasswordRequirementsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "passwordRequirementsPatchRequest", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PatchPasswordRequirementsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->passwordRequirementsSummary = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\PasswordRequirementsSummary', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get password requirements
     * 
     * Query user password requirements for a cluster.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\QueryPasswordRequirementsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\QueryPasswordRequirementsResponse
     */
	public function queryPasswordRequirements(
        \OpenAPI\OpenAPI\Models\Operations\QueryPasswordRequirementsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\QueryPasswordRequirementsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/cluster/{id}/security/password_requirements', \OpenAPI\OpenAPI\Models\Operations\QueryPasswordRequirementsRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\QueryPasswordRequirementsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->passwordRequirementsSummary = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\PasswordRequirementsSummary', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Reset the signed certificate for Web server
     * 
     * Resetting the customer-given certificate for each node's web server.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ResetWebSignedCertificateRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ResetWebSignedCertificateResponse
     */
	public function resetWebSignedCertificate(
        \OpenAPI\OpenAPI\Models\Operations\ResetWebSignedCertificateRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ResetWebSignedCertificateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/cluster/{id}/security/web_signed_cert', \OpenAPI\OpenAPI\Models\Operations\ResetWebSignedCertificateRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ResetWebSignedCertificateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->asyncRequestStatus = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AsyncRequestStatus', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Start an on demand run of the prechecks
     * 
     * Start an on demand run of the prechecks.
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RunPeriodicUpgradePrechecksRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RunPeriodicUpgradePrechecksResponse
     */
	public function runPeriodicUpgradePrechecks(
        \OpenAPI\OpenAPI\Models\Operations\RunPeriodicUpgradePrechecksRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RunPeriodicUpgradePrechecksResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/cluster/{id}/upgrade/precheck_status', \OpenAPI\OpenAPI\Models\Operations\RunPeriodicUpgradePrechecksRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RunPeriodicUpgradePrechecksResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 202) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->asyncRequestStatus = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AsyncRequestStatus', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Specify KMIP client credentials for nodes
     * 
     * Specify KMIP client credentials for each of the Rubrik cluster nodes.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\SetKmipClientRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\SetKmipClientResponse
     */
	public function setKmipClient(
        \OpenAPI\OpenAPI\Models\Operations\SetKmipClientRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\SetKmipClientResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/cluster/{id}/security/kmip/client', \OpenAPI\OpenAPI\Models\Operations\SetKmipClientRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "kmipClientConfiguration", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SetKmipClientResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 202) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->asyncRequestStatus = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AsyncRequestStatus', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Set certificates for one or more truststores
     * 
     * Setting the given certificate for each node's truststores.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\SetTruststoreCertificateRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\SetTruststoreCertificateResponse
     */
	public function setTruststoreCertificate(
        \OpenAPI\OpenAPI\Models\Operations\SetTruststoreCertificateRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\SetTruststoreCertificateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/cluster/{id}/security/truststore', \OpenAPI\OpenAPI\Models\Operations\SetTruststoreCertificateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SetTruststoreCertificateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
	
    /**
     * Set a signed certificate for Web server
     * 
     * Setting the given certificate for each node's web server to use.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\SetWebSignedCertificateRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\SetWebSignedCertificateResponse
     */
	public function setWebSignedCertificate(
        \OpenAPI\OpenAPI\Models\Operations\SetWebSignedCertificateRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\SetWebSignedCertificateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/cluster/{id}/security/web_signed_cert', \OpenAPI\OpenAPI\Models\Operations\SetWebSignedCertificateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "webServerCertificatePayload", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SetWebSignedCertificateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 202) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->asyncRequestStatus = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AsyncRequestStatus', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Stage software on CDM for upgrade
     * 
     * Stage software corresponding to a given CDM version on the cluster, in preparation for an upgrade.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\StageCdmSoftwareRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\StageCdmSoftwareResponse
     */
	public function stageCdmSoftware(
        \OpenAPI\OpenAPI\Models\Operations\StageCdmSoftwareRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\StageCdmSoftwareResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/cluster/{id}/upgrade/stage_cdm_software', \OpenAPI\OpenAPI\Models\Operations\StageCdmSoftwareRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "stageCdmSoftwareInfo", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\StageCdmSoftwareResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 202) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->asyncRequestStatus = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AsyncRequestStatus', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Test the specified syslog export rule
     * 
     * Send a test message using the syslog export rule specified by the given id.
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\SyslogExportRuleFull $request
     * @return \OpenAPI\OpenAPI\Models\Operations\TestSyslogExportRuleResponse
     */
	public function testSyslogExportRule(
        \OpenAPI\OpenAPI\Models\Shared\SyslogExportRuleFull $request,
    ): \OpenAPI\OpenAPI\Models\Operations\TestSyslogExportRuleResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/syslog/export/test');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\TestSyslogExportRuleResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->syslogServerTestResult = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\SyslogServerTestResult', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Remove certificate associated with specified truststore
     * 
     * Remove certificate associated with specified truststore.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UnsetTruststoreCertificateRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UnsetTruststoreCertificateResponse
     */
	public function unsetTruststoreCertificate(
        \OpenAPI\OpenAPI\Models\Operations\UnsetTruststoreCertificateRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UnsetTruststoreCertificateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/cluster/{id}/security/truststore', \OpenAPI\OpenAPI\Models\Operations\UnsetTruststoreCertificateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\UnsetTruststoreCertificateRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UnsetTruststoreCertificateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
	
    /**
     * Change Rubrik cluster properties
     * 
     * Change the properties of a specified Rubrik cluster. Changes to cluster name could take upto 10 minutes to be propagated to all nodes.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateClusterRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateClusterResponse
     */
	public function updateCluster(
        \OpenAPI\OpenAPI\Models\Operations\UpdateClusterRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateClusterResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/cluster/{id}', \OpenAPI\OpenAPI\Models\Operations\UpdateClusterRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "clusterUpdate", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateClusterResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->clusterInfo = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ClusterInfo', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update CORS configuration
     * 
     * Update the CORS support configuration for a web server.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateCorsConfigurationRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateCorsConfigurationResponse
     */
	public function updateCorsConfiguration(
        \OpenAPI\OpenAPI\Models\Operations\UpdateCorsConfigurationRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateCorsConfigurationResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/cluster/{id}/security/cors', \OpenAPI\OpenAPI\Models\Operations\UpdateCorsConfigurationRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "corsConfigurationPatch", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateCorsConfigurationResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->corsConfiguration = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CorsConfiguration', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update FIPS enablement status
     * 
     * Update the current FIPS enablement status for a cluster.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateFipsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateFipsResponse
     */
	public function updateFips(
        \OpenAPI\OpenAPI\Models\Operations\UpdateFipsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateFipsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/cluster/{id}/security/fips', \OpenAPI\OpenAPI\Models\Operations\UpdateFipsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "fipsStatusPatch", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateFipsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->fipsStatus = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\FipsStatus', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update credentials to the Rubrik support portal
     * 
     * Update credentials for the specified Rubrik cluster to connect to the Rubrik support portal.
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateRubrikSupportPortalCredentialsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateRubrikSupportPortalCredentialsResponse
     */
	public function updateRubrikSupportPortalCredentials(
        \OpenAPI\OpenAPI\Models\Operations\UpdateRubrikSupportPortalCredentialsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateRubrikSupportPortalCredentialsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/cluster/{id}/rubrik_support_portal_credentials', \OpenAPI\OpenAPI\Models\Operations\UpdateRubrikSupportPortalCredentialsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "communityUserCredentials", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateRubrikSupportPortalCredentialsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
	
    /**
     * Update the specified syslog export rule
     * 
     * Update the syslog export rule specified by the given id.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateSyslogExportRuleRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateSyslogExportRuleResponse
     */
	public function updateSyslogExportRule(
        \OpenAPI\OpenAPI\Models\Operations\UpdateSyslogExportRuleRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateSyslogExportRuleResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/syslog/export/{id}', \OpenAPI\OpenAPI\Models\Operations\UpdateSyslogExportRuleRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "syslogExportRulePartial", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateSyslogExportRuleResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->syslogExportRuleSummary = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\SyslogExportRuleSummary', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update TOTP global setting
     * 
     * Update TOTP global setting, including whether TOTP is enforced or not.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateTotpGlobalSettingRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateTotpGlobalSettingResponse
     */
	public function updateTotpGlobalSetting(
        \OpenAPI\OpenAPI\Models\Operations\UpdateTotpGlobalSettingRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateTotpGlobalSettingResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/cluster/{id}/security/totp/setting', \OpenAPI\OpenAPI\Models\Operations\UpdateTotpGlobalSettingRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "totpGlobalSettingUpdate", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateTotpGlobalSettingResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->totpGlobalSetting = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\TotpGlobalSetting', 'json');
            }
        }

        return $response;
    }
}