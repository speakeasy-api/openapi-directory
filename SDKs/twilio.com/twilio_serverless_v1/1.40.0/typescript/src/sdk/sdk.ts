/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import axios from "axios";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * Contains the list of servers available to the SDK
 */
export const ServerList = ["https://serverless.twilio.com"] as const;

/**
 * The available configuration options for the SDK
 */
export type SDKProps = {
  /**
   * Allows overriding the default axios client used by the SDK
   */
  defaultClient?: AxiosInstance;
  /**
   * Allows overriding the default server URL used by the SDK
   */
  serverURL?: string;
};

/**
 * This is the public Twilio REST API.
 */
export class SDK {
  public _defaultClient: AxiosInstance;
  public _securityClient: AxiosInstance;
  public _serverURL: string;
  private _language = "typescript";
  private _sdkVersion = "0.0.1";
  private _genVersion = "internal";
  private _globals: any;

  constructor(props?: SDKProps) {
    this._serverURL = props?.serverURL ?? ServerList[0];

    this._defaultClient =
      props?.defaultClient ?? axios.create({ baseURL: this._serverURL });
    this._securityClient = this._defaultClient;
  }

  /**
   * Create a new Asset resource.
   */
  createAsset(
    req: operations.CreateAssetRequest,
    security: operations.CreateAssetSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateAssetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateAssetRequest(req);
    }

    let baseURL: string = operations.CreateAssetServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ServiceSid}/Assets",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateAssetSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateAssetResponse =
        new operations.CreateAssetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serverlessV1ServiceAsset = utils.objectToClass(
              httpRes?.data,
              shared.ServerlessV1ServiceAsset
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new Build resource. At least one function version or asset version is required.
   */
  createBuild(
    req: operations.CreateBuildRequest,
    security: operations.CreateBuildSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateBuildResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateBuildRequest(req);
    }

    let baseURL: string = operations.CreateBuildServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ServiceSid}/Builds",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateBuildSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateBuildResponse =
        new operations.CreateBuildResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serverlessV1ServiceBuild = utils.objectToClass(
              httpRes?.data,
              shared.ServerlessV1ServiceBuild
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new Deployment.
   */
  createDeployment(
    req: operations.CreateDeploymentRequest,
    security: operations.CreateDeploymentSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateDeploymentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateDeploymentRequest(req);
    }

    let baseURL: string = operations.CreateDeploymentServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ServiceSid}/Environments/{EnvironmentSid}/Deployments",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateDeploymentSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateDeploymentResponse =
        new operations.CreateDeploymentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serverlessV1ServiceEnvironmentDeployment = utils.objectToClass(
              httpRes?.data,
              shared.ServerlessV1ServiceEnvironmentDeployment
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new environment.
   */
  createEnvironment(
    req: operations.CreateEnvironmentRequest,
    security: operations.CreateEnvironmentSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateEnvironmentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateEnvironmentRequest(req);
    }

    let baseURL: string = operations.CreateEnvironmentServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ServiceSid}/Environments",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateEnvironmentSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateEnvironmentResponse =
        new operations.CreateEnvironmentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serverlessV1ServiceEnvironment = utils.objectToClass(
              httpRes?.data,
              shared.ServerlessV1ServiceEnvironment
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new Function resource.
   */
  createFunction(
    req: operations.CreateFunctionRequest,
    security: operations.CreateFunctionSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateFunctionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateFunctionRequest(req);
    }

    let baseURL: string = operations.CreateFunctionServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ServiceSid}/Functions",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateFunctionSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateFunctionResponse =
        new operations.CreateFunctionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serverlessV1ServiceFunction = utils.objectToClass(
              httpRes?.data,
              shared.ServerlessV1ServiceFunction
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new Service resource.
   */
  createService(
    req: operations.CreateServiceCreateServiceRequest,
    security: operations.CreateServiceSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateServiceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateServiceCreateServiceRequest(req);
    }

    let baseURL: string = operations.CreateServiceServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/Services";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateServiceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateServiceResponse =
        new operations.CreateServiceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serverlessV1Service = utils.objectToClass(
              httpRes?.data,
              shared.ServerlessV1Service
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new Variable.
   */
  createVariable(
    req: operations.CreateVariableRequest,
    security: operations.CreateVariableSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateVariableResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateVariableRequest(req);
    }

    let baseURL: string = operations.CreateVariableServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ServiceSid}/Environments/{EnvironmentSid}/Variables",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateVariableSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateVariableResponse =
        new operations.CreateVariableResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serverlessV1ServiceEnvironmentVariable = utils.objectToClass(
              httpRes?.data,
              shared.ServerlessV1ServiceEnvironmentVariable
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete an Asset resource.
   */
  deleteAsset(
    req: operations.DeleteAssetRequest,
    security: operations.DeleteAssetSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteAssetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteAssetRequest(req);
    }

    let baseURL: string = operations.DeleteAssetServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ServiceSid}/Assets/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteAssetSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteAssetResponse =
        new operations.DeleteAssetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a Build resource.
   */
  deleteBuild(
    req: operations.DeleteBuildRequest,
    security: operations.DeleteBuildSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteBuildResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteBuildRequest(req);
    }

    let baseURL: string = operations.DeleteBuildServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ServiceSid}/Builds/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteBuildSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteBuildResponse =
        new operations.DeleteBuildResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a specific environment.
   */
  deleteEnvironment(
    req: operations.DeleteEnvironmentRequest,
    security: operations.DeleteEnvironmentSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteEnvironmentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteEnvironmentRequest(req);
    }

    let baseURL: string = operations.DeleteEnvironmentServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ServiceSid}/Environments/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteEnvironmentSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteEnvironmentResponse =
        new operations.DeleteEnvironmentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a Function resource.
   */
  deleteFunction(
    req: operations.DeleteFunctionRequest,
    security: operations.DeleteFunctionSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteFunctionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteFunctionRequest(req);
    }

    let baseURL: string = operations.DeleteFunctionServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ServiceSid}/Functions/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteFunctionSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteFunctionResponse =
        new operations.DeleteFunctionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a Service resource.
   */
  deleteService(
    req: operations.DeleteServiceRequest,
    security: operations.DeleteServiceSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteServiceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteServiceRequest(req);
    }

    let baseURL: string = operations.DeleteServiceServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v1/Services/{Sid}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteServiceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteServiceResponse =
        new operations.DeleteServiceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a specific Variable.
   */
  deleteVariable(
    req: operations.DeleteVariableRequest,
    security: operations.DeleteVariableSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteVariableResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteVariableRequest(req);
    }

    let baseURL: string = operations.DeleteVariableServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ServiceSid}/Environments/{EnvironmentSid}/Variables/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteVariableSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteVariableResponse =
        new operations.DeleteVariableResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a specific Asset resource.
   */
  fetchAsset(
    req: operations.FetchAssetRequest,
    security: operations.FetchAssetSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchAssetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchAssetRequest(req);
    }

    let baseURL: string = operations.FetchAssetServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ServiceSid}/Assets/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchAssetSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchAssetResponse =
        new operations.FetchAssetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serverlessV1ServiceAsset = utils.objectToClass(
              httpRes?.data,
              shared.ServerlessV1ServiceAsset
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a specific Asset Version.
   */
  fetchAssetVersion(
    req: operations.FetchAssetVersionRequest,
    security: operations.FetchAssetVersionSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchAssetVersionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchAssetVersionRequest(req);
    }

    let baseURL: string = operations.FetchAssetVersionServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ServiceSid}/Assets/{AssetSid}/Versions/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchAssetVersionSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchAssetVersionResponse =
        new operations.FetchAssetVersionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serverlessV1ServiceAssetAssetVersion = utils.objectToClass(
              httpRes?.data,
              shared.ServerlessV1ServiceAssetAssetVersion
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a specific Build resource.
   */
  fetchBuild(
    req: operations.FetchBuildRequest,
    security: operations.FetchBuildSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchBuildResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchBuildRequest(req);
    }

    let baseURL: string = operations.FetchBuildServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ServiceSid}/Builds/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchBuildSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchBuildResponse =
        new operations.FetchBuildResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serverlessV1ServiceBuild = utils.objectToClass(
              httpRes?.data,
              shared.ServerlessV1ServiceBuild
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a specific Build resource.
   */
  fetchBuildStatus(
    req: operations.FetchBuildStatusRequest,
    security: operations.FetchBuildStatusSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchBuildStatusResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchBuildStatusRequest(req);
    }

    let baseURL: string = operations.FetchBuildStatusServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ServiceSid}/Builds/{Sid}/Status",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchBuildStatusSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchBuildStatusResponse =
        new operations.FetchBuildStatusResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serverlessV1ServiceBuildBuildStatus = utils.objectToClass(
              httpRes?.data,
              shared.ServerlessV1ServiceBuildBuildStatus
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a specific Deployment.
   */
  fetchDeployment(
    req: operations.FetchDeploymentRequest,
    security: operations.FetchDeploymentSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchDeploymentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchDeploymentRequest(req);
    }

    let baseURL: string = operations.FetchDeploymentServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ServiceSid}/Environments/{EnvironmentSid}/Deployments/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchDeploymentSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchDeploymentResponse =
        new operations.FetchDeploymentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serverlessV1ServiceEnvironmentDeployment = utils.objectToClass(
              httpRes?.data,
              shared.ServerlessV1ServiceEnvironmentDeployment
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a specific environment.
   */
  fetchEnvironment(
    req: operations.FetchEnvironmentRequest,
    security: operations.FetchEnvironmentSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchEnvironmentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchEnvironmentRequest(req);
    }

    let baseURL: string = operations.FetchEnvironmentServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ServiceSid}/Environments/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchEnvironmentSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchEnvironmentResponse =
        new operations.FetchEnvironmentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serverlessV1ServiceEnvironment = utils.objectToClass(
              httpRes?.data,
              shared.ServerlessV1ServiceEnvironment
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a specific Function resource.
   */
  fetchFunction(
    req: operations.FetchFunctionRequest,
    security: operations.FetchFunctionSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchFunctionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchFunctionRequest(req);
    }

    let baseURL: string = operations.FetchFunctionServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ServiceSid}/Functions/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchFunctionSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchFunctionResponse =
        new operations.FetchFunctionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serverlessV1ServiceFunction = utils.objectToClass(
              httpRes?.data,
              shared.ServerlessV1ServiceFunction
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a specific Function Version resource.
   */
  fetchFunctionVersion(
    req: operations.FetchFunctionVersionRequest,
    security: operations.FetchFunctionVersionSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchFunctionVersionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchFunctionVersionRequest(req);
    }

    let baseURL: string = operations.FetchFunctionVersionServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ServiceSid}/Functions/{FunctionSid}/Versions/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchFunctionVersionSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchFunctionVersionResponse =
        new operations.FetchFunctionVersionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serverlessV1ServiceFunctionFunctionVersion =
              utils.objectToClass(
                httpRes?.data,
                shared.ServerlessV1ServiceFunctionFunctionVersion
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a the content of a specific Function Version resource.
   */
  fetchFunctionVersionContent(
    req: operations.FetchFunctionVersionContentRequest,
    security: operations.FetchFunctionVersionContentSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchFunctionVersionContentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchFunctionVersionContentRequest(req);
    }

    let baseURL: string = operations.FetchFunctionVersionContentServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ServiceSid}/Functions/{FunctionSid}/Versions/{Sid}/Content",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchFunctionVersionContentSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchFunctionVersionContentResponse =
        new operations.FetchFunctionVersionContentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serverlessV1ServiceFunctionFunctionVersionFunctionVersionContent =
              utils.objectToClass(
                httpRes?.data,
                shared.ServerlessV1ServiceFunctionFunctionVersionFunctionVersionContent
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a specific log.
   */
  fetchLog(
    req: operations.FetchLogRequest,
    security: operations.FetchLogSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchLogResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchLogRequest(req);
    }

    let baseURL: string = operations.FetchLogServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ServiceSid}/Environments/{EnvironmentSid}/Logs/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchLogSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchLogResponse = new operations.FetchLogResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serverlessV1ServiceEnvironmentLog = utils.objectToClass(
              httpRes?.data,
              shared.ServerlessV1ServiceEnvironmentLog
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a specific Service resource.
   */
  fetchService(
    req: operations.FetchServiceRequest,
    security: operations.FetchServiceSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchServiceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchServiceRequest(req);
    }

    let baseURL: string = operations.FetchServiceServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v1/Services/{Sid}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchServiceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchServiceResponse =
        new operations.FetchServiceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serverlessV1Service = utils.objectToClass(
              httpRes?.data,
              shared.ServerlessV1Service
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a specific Variable.
   */
  fetchVariable(
    req: operations.FetchVariableRequest,
    security: operations.FetchVariableSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchVariableResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchVariableRequest(req);
    }

    let baseURL: string = operations.FetchVariableServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ServiceSid}/Environments/{EnvironmentSid}/Variables/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchVariableSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchVariableResponse =
        new operations.FetchVariableResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serverlessV1ServiceEnvironmentVariable = utils.objectToClass(
              httpRes?.data,
              shared.ServerlessV1ServiceEnvironmentVariable
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all Assets.
   */
  listAsset(
    req: operations.ListAssetRequest,
    security: operations.ListAssetSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListAssetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListAssetRequest(req);
    }

    let baseURL: string = operations.ListAssetServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ServiceSid}/Assets",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListAssetSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListAssetResponse =
        new operations.ListAssetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listAssetResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListAssetListAssetResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all Asset Versions.
   */
  listAssetVersion(
    req: operations.ListAssetVersionRequest,
    security: operations.ListAssetVersionSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListAssetVersionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListAssetVersionRequest(req);
    }

    let baseURL: string = operations.ListAssetVersionServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ServiceSid}/Assets/{AssetSid}/Versions",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListAssetVersionSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListAssetVersionResponse =
        new operations.ListAssetVersionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listAssetVersionResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListAssetVersionListAssetVersionResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all Builds.
   */
  listBuild(
    req: operations.ListBuildRequest,
    security: operations.ListBuildSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListBuildResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListBuildRequest(req);
    }

    let baseURL: string = operations.ListBuildServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ServiceSid}/Builds",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListBuildSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListBuildResponse =
        new operations.ListBuildResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listBuildResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListBuildListBuildResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all Deployments.
   */
  listDeployment(
    req: operations.ListDeploymentRequest,
    security: operations.ListDeploymentSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListDeploymentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListDeploymentRequest(req);
    }

    let baseURL: string = operations.ListDeploymentServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ServiceSid}/Environments/{EnvironmentSid}/Deployments",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListDeploymentSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListDeploymentResponse =
        new operations.ListDeploymentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listDeploymentResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListDeploymentListDeploymentResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all environments.
   */
  listEnvironment(
    req: operations.ListEnvironmentRequest,
    security: operations.ListEnvironmentSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListEnvironmentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListEnvironmentRequest(req);
    }

    let baseURL: string = operations.ListEnvironmentServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ServiceSid}/Environments",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListEnvironmentSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListEnvironmentResponse =
        new operations.ListEnvironmentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listEnvironmentResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListEnvironmentListEnvironmentResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all Functions.
   */
  listFunction(
    req: operations.ListFunctionRequest,
    security: operations.ListFunctionSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListFunctionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListFunctionRequest(req);
    }

    let baseURL: string = operations.ListFunctionServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ServiceSid}/Functions",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListFunctionSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListFunctionResponse =
        new operations.ListFunctionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listFunctionResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListFunctionListFunctionResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all Function Version resources.
   */
  listFunctionVersion(
    req: operations.ListFunctionVersionRequest,
    security: operations.ListFunctionVersionSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListFunctionVersionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListFunctionVersionRequest(req);
    }

    let baseURL: string = operations.ListFunctionVersionServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ServiceSid}/Functions/{FunctionSid}/Versions",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListFunctionVersionSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListFunctionVersionResponse =
        new operations.ListFunctionVersionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listFunctionVersionResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListFunctionVersionListFunctionVersionResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all logs.
   */
  listLog(
    req: operations.ListLogRequest,
    security: operations.ListLogSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListLogResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListLogRequest(req);
    }

    let baseURL: string = operations.ListLogServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ServiceSid}/Environments/{EnvironmentSid}/Logs",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListLogSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListLogResponse = new operations.ListLogResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listLogResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListLogListLogResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all Services.
   */
  listService(
    req: operations.ListServiceRequest,
    security: operations.ListServiceSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListServiceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListServiceRequest(req);
    }

    let baseURL: string = operations.ListServiceServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/Services";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListServiceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListServiceResponse =
        new operations.ListServiceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listServiceResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListServiceListServiceResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all Variables.
   */
  listVariable(
    req: operations.ListVariableRequest,
    security: operations.ListVariableSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListVariableResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListVariableRequest(req);
    }

    let baseURL: string = operations.ListVariableServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ServiceSid}/Environments/{EnvironmentSid}/Variables",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListVariableSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListVariableResponse =
        new operations.ListVariableResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listVariableResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListVariableListVariableResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update a specific Asset resource.
   */
  updateAsset(
    req: operations.UpdateAssetRequest,
    security: operations.UpdateAssetSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateAssetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateAssetRequest(req);
    }

    let baseURL: string = operations.UpdateAssetServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ServiceSid}/Assets/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateAssetSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateAssetResponse =
        new operations.UpdateAssetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serverlessV1ServiceAsset = utils.objectToClass(
              httpRes?.data,
              shared.ServerlessV1ServiceAsset
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update a specific Function resource.
   */
  updateFunction(
    req: operations.UpdateFunctionRequest,
    security: operations.UpdateFunctionSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateFunctionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateFunctionRequest(req);
    }

    let baseURL: string = operations.UpdateFunctionServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ServiceSid}/Functions/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateFunctionSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateFunctionResponse =
        new operations.UpdateFunctionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serverlessV1ServiceFunction = utils.objectToClass(
              httpRes?.data,
              shared.ServerlessV1ServiceFunction
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update a specific Service resource.
   */
  updateService(
    req: operations.UpdateServiceRequest,
    security: operations.UpdateServiceSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateServiceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateServiceRequest(req);
    }

    let baseURL: string = operations.UpdateServiceServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v1/Services/{Sid}", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateServiceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateServiceResponse =
        new operations.UpdateServiceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serverlessV1Service = utils.objectToClass(
              httpRes?.data,
              shared.ServerlessV1Service
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update a specific Variable.
   */
  updateVariable(
    req: operations.UpdateVariableRequest,
    security: operations.UpdateVariableSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateVariableResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateVariableRequest(req);
    }

    let baseURL: string = operations.UpdateVariableServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Services/{ServiceSid}/Environments/{EnvironmentSid}/Variables/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateVariableSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateVariableResponse =
        new operations.UpdateVariableResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serverlessV1ServiceEnvironmentVariable = utils.objectToClass(
              httpRes?.data,
              shared.ServerlessV1ServiceEnvironmentVariable
            );
          }
          break;
      }

      return res;
    });
  }
}
