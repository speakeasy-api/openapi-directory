/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * To change the description use /examples/TagsDescriptions.json
 */
export class Browser {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Searches for data (ie. customer, task, etc) and returns it in a CSV form.
   *
   * @remarks
   * Searches for data (ie. customer, task, etc) and returns it in a CSV form.
   */
  browseCSV(
    req: operations.BrowseCSVRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.BrowseCSVResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.BrowseCSVRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/browser/csv";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BrowseCSVResponse =
        new operations.BrowseCSVResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.browseCSVDefaultApplicationVndXtrfV1PlusJsonObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Searches for data (ie. customer, task, etc) and returns it in a tabular form.
   *
   * @remarks
   * Searches for data (ie. customer, task, etc) and returns it in a tabular form.
   */
  browseJSON(
    req: operations.BrowseJSONRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.BrowseJSONResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.BrowseJSONRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/browser";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BrowseJSONResponse =
        new operations.BrowseJSONResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.browseJSONDefaultApplicationVndXtrfV1PlusJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates view for given class.
   *
   * @remarks
   * Creates view for given class.
   */
  create(
    req: operations.CreateRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/browser/views/for/{className}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "viewDTO",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateResponse = new operations.CreateResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.viewWithIdDTO = utils.objectToClass(
              httpRes?.data,
              shared.ViewWithIdDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Removes a view.
   *
   * @remarks
   * Removes a view. No content is returned upon success (204).
   */
  delete(
    req: operations.DeleteRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/browser/views/{viewId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteResponse = new operations.DeleteResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Deletes a single column from view.
   *
   * @remarks
   * Deletes a single column from view.
   */
  deleteColumn(
    req: operations.DeleteColumnRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteColumnResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteColumnRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/browser/views/{viewId}/columns/{columnName}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteColumnResponse =
        new operations.DeleteColumnResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.columnDTOS = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.columnDTOS = utils.objectToClass(
              httpRes?.data,
              shared.ColumnDTO,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns all view's information.
   *
   * @remarks
   * Returns all view's information (ie. name, columns, filters, etc).
   */
  get(
    req: operations.GetRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/browser/views/{viewId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetResponse = new operations.GetResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.viewDTO = utils.objectToClass(httpRes?.data, shared.ViewDTO);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns column's specific settings.
   *
   * @remarks
   * Returns column's specific settings. For example when column describes money amount we can decide whether it should display currency or not.
   */
  getColumnSettings(
    req: operations.GetColumnSettingsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetColumnSettingsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetColumnSettingsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/browser/views/{viewId}/columns/{columnName}/settings",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetColumnSettingsResponse =
        new operations.GetColumnSettingsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.getColumnSettingsDefaultApplicationVndXtrfV1PlusJsonObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns columns defined in view.
   *
   * @remarks
   * Returns columns defined in view.
   */
  getColumns(
    req: operations.GetColumnsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetColumnsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetColumnsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/browser/views/{viewId}/columns",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetColumnsResponse =
        new operations.GetColumnsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.columnDTOS = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.columnDTOS = utils.objectToClass(
              httpRes?.data,
              shared.ColumnDTO,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns current view's detailed information, suitable for browser.
   *
   * @remarks
   * Returns current view's detailed information, suitable for browser.
   */
  getCurrentViewDetails(
    req: operations.GetCurrentViewDetailsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetCurrentViewDetailsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetCurrentViewDetailsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/browser/views/details/for/{className}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetCurrentViewDetailsResponse =
        new operations.GetCurrentViewDetailsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.viewDetailsDTO = utils.objectToClass(
              httpRes?.data,
              shared.ViewDetailsDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns view's filter.
   *
   * @remarks
   * Returns view's filter.
   */
  getFilter(
    req: operations.GetFilterRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetFilterResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetFilterRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/browser/views/{viewId}/filter",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetFilterResponse =
        new operations.GetFilterResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.filterDTO = utils.objectToClass(
              httpRes?.data,
              shared.FilterDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns view's local settings (for current user).
   *
   * @remarks
   * Returns view's local settings (for current user).
   */
  getLocalSettings(
    req: operations.GetLocalSettingsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetLocalSettingsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetLocalSettingsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/browser/views/{viewId}/settings/local",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetLocalSettingsResponse =
        new operations.GetLocalSettingsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.localSettingsDTO = utils.objectToClass(
              httpRes?.data,
              shared.LocalSettingsDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns view's order settings.
   *
   * @remarks
   * Returns view's order settings.
   */
  getOrder(
    req: operations.GetOrderRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetOrderResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetOrderRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/browser/views/{viewId}/order",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetOrderResponse = new operations.GetOrderResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.orderDTO = utils.objectToClass(httpRes?.data, shared.OrderDTO);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns view's permissions.
   *
   * @remarks
   * Returns view's permissions.
   */
  getPermissions(
    req: operations.GetPermissionsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetPermissionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetPermissionsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/browser/views/{viewId}/permissions",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetPermissionsResponse =
        new operations.GetPermissionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.permissionsDTO = utils.objectToClass(
              httpRes?.data,
              shared.PermissionsDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns view's settings.
   *
   * @remarks
   * Returns view's settings (ie. name).
   */
  getSettings(
    req: operations.GetSettingsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSettingsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSettingsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/browser/views/{viewId}/settings",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSettingsResponse =
        new operations.GetSettingsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.settingsDTO = utils.objectToClass(
              httpRes?.data,
              shared.SettingsDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns view's detailed information, suitable for browser.
   *
   * @remarks
   * Returns view's detailed information, suitable for browser.
   */
  getViewDetails(
    req: operations.GetViewDetailsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetViewDetailsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetViewDetailsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/browser/views/details/for/{className}/{viewId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetViewDetailsResponse =
        new operations.GetViewDetailsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.viewDetailsDTO = utils.objectToClass(
              httpRes?.data,
              shared.ViewDetailsDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns views' brief.
   *
   * @remarks
   * Returns views' brief.
   */
  getViewsBrief(
    req: operations.GetViewsBriefRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetViewsBriefResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetViewsBriefRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/browser/views/for/{className}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetViewsBriefResponse =
        new operations.GetViewsBriefResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.viewsBriefDTO = utils.objectToClass(
              httpRes?.data,
              shared.ViewsBriefDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Selects given view as current and returns its detailed information, suitable for browser.
   *
   * @remarks
   * Selects given view as current and returns its detailed information, suitable for browser.
   */
  selectViewAndGetItsDetails(
    req: operations.SelectViewAndGetItsDetailsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.SelectViewAndGetItsDetailsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.SelectViewAndGetItsDetailsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/browser/views/details/for/{className}/{viewId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SelectViewAndGetItsDetailsResponse =
        new operations.SelectViewAndGetItsDetailsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.viewDetailsDTO = utils.objectToClass(
              httpRes?.data,
              shared.ViewDetailsDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates all view's information.
   *
   * @remarks
   * Updates all view's information (ie. name, columns, filters, etc).
   */
  update(
    req: operations.UpdateRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/browser/views/{viewId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "viewDTO",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateResponse = new operations.UpdateResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.viewDTO = utils.objectToClass(httpRes?.data, shared.ViewDTO);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates column's specific settings.
   *
   * @remarks
   * Updates column's specific settings. For example when column describes money amount we can decide whether it should display currency or not.
   */
  updateColumnSettings(
    req: operations.UpdateColumnSettingsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateColumnSettingsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateColumnSettingsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/browser/views/{viewId}/columns/{columnName}/settings",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateColumnSettingsResponse =
        new operations.UpdateColumnSettingsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.updateColumnSettingsDefaultApplicationVndXtrfV1PlusJsonObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates columns in view.
   *
   * @remarks
   * Updates columns in view.
   */
  updateColumns(
    req: operations.UpdateColumnsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateColumnsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateColumnsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/browser/views/{viewId}/columns",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateColumnsResponse =
        new operations.UpdateColumnsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.columnDTOS = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.columnDTOS = utils.objectToClass(
              httpRes?.data,
              shared.ColumnDTO,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates view's filter.
   *
   * @remarks
   * Updates view's filter.
   */
  updateFilter(
    req: operations.UpdateFilterRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateFilterResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateFilterRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/browser/views/{viewId}/filter",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateFilterResponse =
        new operations.UpdateFilterResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.filterDTO = utils.objectToClass(
              httpRes?.data,
              shared.FilterDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates view's filter property.
   *
   * @remarks
   * Updates view's filter property.
   */
  updateFilterProperty(
    req: operations.UpdateFilterPropertyRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateFilterPropertyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateFilterPropertyRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/browser/views/{viewId}/filter/{filterProperty}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "filterPropertyDTO",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateFilterPropertyResponse =
        new operations.UpdateFilterPropertyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.updateFilterPropertyDefaultApplicationVndXtrfV1PlusJsonObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates view's local settings (for current user).
   *
   * @remarks
   * Updates view's local settings (for current user).
   */
  updateLocalSettings(
    req: operations.UpdateLocalSettingsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateLocalSettingsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateLocalSettingsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/browser/views/{viewId}/settings/local",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "localSettingsDTO",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateLocalSettingsResponse =
        new operations.UpdateLocalSettingsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.localSettingsDTO = utils.objectToClass(
              httpRes?.data,
              shared.LocalSettingsDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates view's order settings.
   *
   * @remarks
   * Updates view's order settings.
   */
  updateOrder(
    req: operations.UpdateOrderRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateOrderResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateOrderRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/browser/views/{viewId}/order",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "orderDTO",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateOrderResponse =
        new operations.UpdateOrderResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.orderDTO = utils.objectToClass(httpRes?.data, shared.OrderDTO);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates view's permissions.
   *
   * @remarks
   * Updates view's permissions.
   */
  updatePermissions(
    req: operations.UpdatePermissionsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdatePermissionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdatePermissionsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/browser/views/{viewId}/permissions",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "permissionsDTO",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdatePermissionsResponse =
        new operations.UpdatePermissionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.permissionsDTO = utils.objectToClass(
              httpRes?.data,
              shared.PermissionsDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates view's settings.
   *
   * @remarks
   * Updates view's settings.
   */
  updateSettings(
    req: operations.UpdateSettingsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateSettingsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateSettingsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/browser/views/{viewId}/settings",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "settingsDTO",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateSettingsResponse =
        new operations.UpdateSettingsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.settingsDTO = utils.objectToClass(
              httpRes?.data,
              shared.SettingsDTO
            );
          }
          break;
      }

      return res;
    });
  }
}
