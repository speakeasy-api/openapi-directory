"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
from ..shared import additionalsettings as shared_additionalsettings
from dataclasses_json import Undefined, dataclass_json
from enum import Enum
from sdk import utils
from typing import Optional

class UpdateCompanyWebhookRequestCommunicationFormatEnum(str, Enum):
    r"""Format or protocol for receiving webhooks. Possible values:
    * **soap**
    * **http**
    * **json**
    """
    HTTP = 'http'
    JSON = 'json'
    SOAP = 'soap'

class UpdateCompanyWebhookRequestFilterMerchantAccountTypeEnum(str, Enum):
    r"""Shows how merchant accounts are filtered when configuring the webhook. Possible values:
    * **includeAccounts**: The webhook is configured for the merchant accounts listed in `filterMerchantAccounts`.
    * **excludeAccounts**: The webhook is not configured for the merchant accounts listed in `filterMerchantAccounts`.
    * **allAccounts**: Includes all merchant accounts, and does not require specifying `filterMerchantAccounts`.
    """
    ALL_ACCOUNTS = 'allAccounts'
    EXCLUDE_ACCOUNTS = 'excludeAccounts'
    INCLUDE_ACCOUNTS = 'includeAccounts'

class UpdateCompanyWebhookRequestNetworkTypeEnum(str, Enum):
    r"""Network type for Terminal API notification webhooks. Possible values:
    * **public**
    * **local**
    
    Default Value: **public**.
    """
    LOCAL = 'LOCAL'
    PUBLIC = 'PUBLIC'

class UpdateCompanyWebhookRequestSslVersionEnum(str, Enum):
    r"""SSL version to access the public webhook URL specified in the `url` field. Possible values:
    * **TLSv1.3**
    * **TLSv1.2**
    * **HTTP** - Only allowed on Test environment.
    
    If not specified, the webhook will use `sslVersion`: **TLSv1.2**.
    """
    HTTP = 'HTTP'
    SSL = 'SSL'
    SS_LV3 = 'SSLv3'
    TLS = 'TLS'
    TL_SV1 = 'TLSv1'
    TL_SV1_1 = 'TLSv1.1'
    TL_SV1_2 = 'TLSv1.2'
    TL_SV1_3 = 'TLSv1.3'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateCompanyWebhookRequest:
    
    accepts_expired_certificate: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('acceptsExpiredCertificate'), 'exclude': lambda f: f is None }})
    r"""Indicates if expired SSL certificates are accepted. Default value: **false**."""  
    accepts_self_signed_certificate: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('acceptsSelfSignedCertificate'), 'exclude': lambda f: f is None }})
    r"""Indicates if self-signed SSL certificates are accepted. Default value: **false**."""  
    accepts_untrusted_root_certificate: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('acceptsUntrustedRootCertificate'), 'exclude': lambda f: f is None }})
    r"""Indicates if untrusted SSL certificates are accepted. Default value: **false**."""  
    active: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('active'), 'exclude': lambda f: f is None }})
    r"""Indicates if the webhook configuration is active. The field must be **true** for us to send webhooks about events related an account."""  
    additional_settings: Optional[shared_additionalsettings.AdditionalSettings] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('additionalSettings'), 'exclude': lambda f: f is None }})  
    communication_format: Optional[UpdateCompanyWebhookRequestCommunicationFormatEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('communicationFormat'), 'exclude': lambda f: f is None }})
    r"""Format or protocol for receiving webhooks. Possible values:
    * **soap**
    * **http**
    * **json**
    """  
    description: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('description'), 'exclude': lambda f: f is None }})
    r"""Your description for this webhook configuration."""  
    filter_merchant_accounts: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('filterMerchantAccounts'), 'exclude': lambda f: f is None }})
    r"""A list of merchant account names that are included or excluded from receiving the webhook. Inclusion or exclusion is based on the value defined for `filterMerchantAccountType`.
    
    Required if `filterMerchantAccountType` is either:
    * **includeAccounts**
    * **excludeAccounts**
    
    Not needed for `filterMerchantAccountType`: **allAccounts**.
    """  
    filter_merchant_account_type: Optional[UpdateCompanyWebhookRequestFilterMerchantAccountTypeEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('filterMerchantAccountType'), 'exclude': lambda f: f is None }})
    r"""Shows how merchant accounts are filtered when configuring the webhook. Possible values:
    * **includeAccounts**: The webhook is configured for the merchant accounts listed in `filterMerchantAccounts`.
    * **excludeAccounts**: The webhook is not configured for the merchant accounts listed in `filterMerchantAccounts`.
    * **allAccounts**: Includes all merchant accounts, and does not require specifying `filterMerchantAccounts`.
    """  
    network_type: Optional[UpdateCompanyWebhookRequestNetworkTypeEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('networkType'), 'exclude': lambda f: f is None }})
    r"""Network type for Terminal API notification webhooks. Possible values:
    * **public**
    * **local**
    
    Default Value: **public**.
    """  
    password: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('password'), 'exclude': lambda f: f is None }})
    r"""Password to access the webhook URL."""  
    populate_soap_action_header: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('populateSoapActionHeader'), 'exclude': lambda f: f is None }})
    r"""Indicates if the SOAP action header needs to be populated. Default value: **false**.
    
    Only applies if `communicationFormat`: **soap**.
    """  
    ssl_version: Optional[UpdateCompanyWebhookRequestSslVersionEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('sslVersion'), 'exclude': lambda f: f is None }})
    r"""SSL version to access the public webhook URL specified in the `url` field. Possible values:
    * **TLSv1.3**
    * **TLSv1.2**
    * **HTTP** - Only allowed on Test environment.
    
    If not specified, the webhook will use `sslVersion`: **TLSv1.2**.
    """  
    url: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('url'), 'exclude': lambda f: f is None }})
    r"""Public URL where webhooks will be sent, for example **https://www.domain.com/webhook-endpoint**."""  
    username: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('username'), 'exclude': lambda f: f is None }})
    r"""Username to access the webhook URL."""  
    