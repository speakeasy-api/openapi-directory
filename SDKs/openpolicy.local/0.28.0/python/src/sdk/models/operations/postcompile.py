"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
import requests as requests_http
from ..shared import four_hundred as shared_four_hundred
from dataclasses_json import Undefined, dataclass_json
from enum import Enum
from sdk import utils
from typing import Any, Optional


@dataclasses.dataclass
class PostCompileRequest:
    
    explain: Optional[str] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'explain', 'style': 'form', 'explode': True }})
    r"""If set to *full*, response will include query explanations in addition to the result."""  
    instrument: Optional[bool] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'instrument', 'style': 'form', 'explode': True }})
    r"""If true, response will return additional performance metrics in addition to the result and the standard metrics.
    
    **Caution:** This can add significant overhead to query evaluation. The recommendation is to only use this parameter if you are debugging a performance problem.
    """  
    metrics: Optional[bool] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'metrics', 'style': 'form', 'explode': True }})
    r"""If true, compiler performance metrics will be returned in the response."""  
    pretty: Optional[bool] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'pretty', 'style': 'form', 'explode': True }})
    r"""If true, response will be in a human-readable format."""  
    request_body: Optional[dict[str, Any]] = dataclasses.field(default=None, metadata={'request': { 'media_type': 'application/json' }})
    r"""The query (in JSON format)"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostCompile200ApplicationJSONExplanationLocalsKey:
    
    type: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type'), 'exclude': lambda f: f is None }})  
    value: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('value'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostCompile200ApplicationJSONExplanationLocalsValue:
    
    type: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type'), 'exclude': lambda f: f is None }})  
    value: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('value'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostCompile200ApplicationJSONExplanationLocals:
    
    key: Optional[PostCompile200ApplicationJSONExplanationLocalsKey] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('key'), 'exclude': lambda f: f is None }})  
    value: Optional[PostCompile200ApplicationJSONExplanationLocalsValue] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('value'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostCompile200ApplicationJSONExplanationNodeTerms:
    
    type: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type'), 'exclude': lambda f: f is None }})  
    value: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('value'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostCompile200ApplicationJSONExplanationNode:
    r"""The AST element associated with the evaluation step.
    https://godoc.org/github.com/open-policy-agent/opa/ast - AST
    """
    
    index: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('index'), 'exclude': lambda f: f is None }})
    r"""Node number"""  
    terms: Optional[list[PostCompile200ApplicationJSONExplanationNodeTerms]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('terms'), 'exclude': lambda f: f is None }})  
    
class PostCompile200ApplicationJSONExplanationOpEnum(str, Enum):
    r"""The kind of *trace event*
    
    Each trace event represents a step in the query evaluation process. Trace events are emitted at the following points:
    - enter - before a body or rule is evaluated
    - exit - after a body or rule has evaluated successfully
    - eval - before an expression is evaluated
    - fail - after an expression has evaluated to false.
    - redo - before evaluation restarts from a body, rule, or expression.
    
    By default, OPA searches for all sets of term bindings that make all expressions in the query evaluate to true. Because there may be multiple answers, the search can restart when OPA determines the query is true or false. When the search restarts, a *redo trace event* is emitted.
    """
    ENTER = 'enter'
    EXIT = 'exit'
    EVAL = 'eval'
    FAIL = 'fail'
    REDO = 'redo'

class PostCompile200ApplicationJSONExplanationTypeEnum(str, Enum):
    r"""The type of the **node** field"""
    EXPR = 'expr'
    RULE = 'rule'
    BODY = 'body'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostCompile200ApplicationJSONExplanation:
    
    locals: Optional[list[PostCompile200ApplicationJSONExplanationLocals]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('locals'), 'exclude': lambda f: f is None }})
    r"""The query's term bindings at the point when the trace event was emitted."""  
    node: Optional[PostCompile200ApplicationJSONExplanationNode] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('node'), 'exclude': lambda f: f is None }})
    r"""The AST element associated with the evaluation step.
    https://godoc.org/github.com/open-policy-agent/opa/ast - AST
    """  
    op: Optional[PostCompile200ApplicationJSONExplanationOpEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('op'), 'exclude': lambda f: f is None }})
    r"""The kind of *trace event*
    
    Each trace event represents a step in the query evaluation process. Trace events are emitted at the following points:
    - enter - before a body or rule is evaluated
    - exit - after a body or rule has evaluated successfully
    - eval - before an expression is evaluated
    - fail - after an expression has evaluated to false.
    - redo - before evaluation restarts from a body, rule, or expression.
    
    By default, OPA searches for all sets of term bindings that make all expressions in the query evaluate to true. Because there may be multiple answers, the search can restart when OPA determines the query is true or false. When the search restarts, a *redo trace event* is emitted.
    """  
    parent_id: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('parent_id'), 'exclude': lambda f: f is None }})
    r"""The parent query. Use this field to identify trace events from related queries.
    
    For example, if query A references rule R, trace events emitted when evaluating rule R will have the *parent_id* field set to query Aâ€™s *query_id*.
    """  
    query_id: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('query_id'), 'exclude': lambda f: f is None }})
    r"""The query that the trace event was emitted for. Use this field to distinguish trace events emitted by from different queries."""  
    type: Optional[PostCompile200ApplicationJSONExplanationTypeEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type'), 'exclude': lambda f: f is None }})
    r"""The type of the **node** field"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostCompile200ApplicationJSONMetrics:
    
    counter_server_query_cache_hit: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('counter_server_query_cache_hit'), 'exclude': lambda f: f is None }})
    r"""*Description is forthcoming*"""  
    timer_query_compile_stage_build_comprehension_index_ns: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('timer_query_compile_stage_build_comprehension_index_ns'), 'exclude': lambda f: f is None }})
    r"""(Only returned if `instrument` is true.) *Description is forthcoming*"""  
    timer_query_compile_stage_check_safety_ns: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('timer_query_compile_stage_check_safety_ns'), 'exclude': lambda f: f is None }})
    r"""(Only returned if `instrument` is true.) *Description is forthcoming*"""  
    timer_query_compile_stage_check_types_ns: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('timer_query_compile_stage_check_types_ns'), 'exclude': lambda f: f is None }})
    r"""(Only returned if `instrument` is true.) *Description is forthcoming*"""  
    timer_query_compile_stage_check_undefined_funcs_ns: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('timer_query_compile_stage_check_undefined_funcs_ns'), 'exclude': lambda f: f is None }})
    r"""(Only returned if `instrument` is true.) *Description is forthcoming*"""  
    timer_query_compile_stage_check_unsafe_builtins_ns: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('timer_query_compile_stage_check_unsafe_builtins_ns'), 'exclude': lambda f: f is None }})
    r"""(Only returned if `instrument` is true.) *Description is forthcoming*"""  
    timer_query_compile_stage_resolve_refs_ns: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('timer_query_compile_stage_resolve_refs_ns'), 'exclude': lambda f: f is None }})
    r"""(Only returned if `instrument` is true.) *Description is forthcoming*"""  
    timer_query_compile_stage_rewrite_comprehension_terms_ns: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('timer_query_compile_stage_rewrite_comprehension_terms_ns'), 'exclude': lambda f: f is None }})
    r"""(Only returned if `instrument` is true.) *Description is forthcoming*"""  
    timer_query_compile_stage_rewrite_dynamic_terms_ns: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('timer_query_compile_stage_rewrite_dynamic_terms_ns'), 'exclude': lambda f: f is None }})
    r"""(Only returned if `instrument` is true.) *Description is forthcoming*"""  
    timer_query_compile_stage_rewrite_expr_terms_ns: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('timer_query_compile_stage_rewrite_expr_terms_ns'), 'exclude': lambda f: f is None }})
    r"""(Only returned if `instrument` is true.) *Description is forthcoming*"""  
    timer_query_compile_stage_rewrite_local_vars_ns: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('timer_query_compile_stage_rewrite_local_vars_ns'), 'exclude': lambda f: f is None }})
    r"""(Only returned if `instrument` is true.) *Description is forthcoming*"""  
    timer_query_compile_stage_rewrite_to_capture_value_ns: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('timer_query_compile_stage_rewrite_to_capture_value_ns'), 'exclude': lambda f: f is None }})
    r"""(Only returned if `instrument` is true.) *Description is forthcoming*"""  
    timer_query_compile_stage_rewrite_with_values_ns: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('timer_query_compile_stage_rewrite_with_values_ns'), 'exclude': lambda f: f is None }})
    r"""(Only returned if `instrument` is true.) *Description is forthcoming*"""  
    timer_rego_input_parse_ns: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('timer_rego_input_parse_ns'), 'exclude': lambda f: f is None }})
    r"""Time taken (in nanonseconds) to parse the input"""  
    timer_rego_module_compile_ns: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('timer_rego_module_compile_ns'), 'exclude': lambda f: f is None }})
    r"""Time taken (in nanonseconds) to compile the loaded policy modules"""  
    timer_rego_module_parse_ns: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('timer_rego_module_parse_ns'), 'exclude': lambda f: f is None }})
    r"""Time taken (in nanoseconds) to parse the input policy module"""  
    timer_rego_query_compile_ns: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('timer_rego_query_compile_ns'), 'exclude': lambda f: f is None }})
    r"""Time taken (in nanoseconds) to compile the query"""  
    timer_rego_query_eval_ns: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('timer_rego_query_eval_ns'), 'exclude': lambda f: f is None }})
    r"""Time taken (in nanonseconds) to evaluate the query"""  
    timer_rego_query_parse_ns: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('timer_rego_query_parse_ns'), 'exclude': lambda f: f is None }})
    r"""Time taken (in nanoseconds) to parse the query"""  
    timer_server_handler_ns: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('timer_server_handler_ns'), 'exclude': lambda f: f is None }})
    r"""Time taken (in nanoseconds) to handle the API request"""  
    timer_server_read_bytes_ns: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('timer_server_read_bytes_ns'), 'exclude': lambda f: f is None }})
    r"""*Description is forthcoming*"""  
    
class PostCompile200ApplicationJSONResultAstPackagePathTypeEnum(str, Enum):
    r"""The type of the path operation"""
    IMPORT = 'import'
    PACKAGE = 'package'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostCompile200ApplicationJSONResultAstPackagePath:
    
    type: Optional[PostCompile200ApplicationJSONResultAstPackagePathTypeEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type'), 'exclude': lambda f: f is None }})
    r"""The type of the path operation"""  
    value: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('value'), 'exclude': lambda f: f is None }})
    r"""The path variable"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostCompile200ApplicationJSONResultAstPackage:
    
    path: Optional[list[PostCompile200ApplicationJSONResultAstPackagePath]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('path'), 'exclude': lambda f: f is None }})
    r"""The path to the package"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostCompile200ApplicationJSONResultAstRulesBodyTermsValue:
    
    type: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type'), 'exclude': lambda f: f is None }})  
    value: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('value'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostCompile200ApplicationJSONResultAstRulesBodyTerms:
    
    type: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type'), 'exclude': lambda f: f is None }})
    r"""The type of the term variable"""  
    value: Optional[list[PostCompile200ApplicationJSONResultAstRulesBodyTermsValue]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('value'), 'exclude': lambda f: f is None }})
    r"""The list of types and values for the term variable"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostCompile200ApplicationJSONResultAstRulesBody:
    
    index: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('index'), 'exclude': lambda f: f is None }})
    r"""The location of this term in the list (starts at 0)"""  
    terms: Optional[list[PostCompile200ApplicationJSONResultAstRulesBodyTerms]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('terms'), 'exclude': lambda f: f is None }})
    r"""The type/value pairing for this term"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostCompile200ApplicationJSONResultAstRulesHeadKey:
    r"""The type/value pairing for this rule's head"""
    
    type: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type'), 'exclude': lambda f: f is None }})
    r"""The type of the head"""  
    value: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('value'), 'exclude': lambda f: f is None }})
    r"""The value of the head"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostCompile200ApplicationJSONResultAstRulesHead:
    
    key: Optional[PostCompile200ApplicationJSONResultAstRulesHeadKey] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('key'), 'exclude': lambda f: f is None }})
    r"""The type/value pairing for this rule's head"""  
    name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name'), 'exclude': lambda f: f is None }})
    r"""The head of the rule"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostCompile200ApplicationJSONResultAstRules:
    
    body: Optional[list[PostCompile200ApplicationJSONResultAstRulesBody]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('body'), 'exclude': lambda f: f is None }})
    r"""A list of the terms in this rule"""  
    head: Optional[PostCompile200ApplicationJSONResultAstRulesHead] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('head'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostCompile200ApplicationJSONResultAst:
    r"""The types for declarations and runtime objects passed to your implementation. This consists of an abstract syntax tree (AST) of policy modules, package and import declarations, rules, expressions, and terms.
    https://godoc.org/github.com/open-policy-agent/opa/ast - AST
    """
    
    package: Optional[PostCompile200ApplicationJSONResultAstPackage] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('package'), 'exclude': lambda f: f is None }})  
    rules: Optional[list[PostCompile200ApplicationJSONResultAstRules]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('rules'), 'exclude': lambda f: f is None }})
    r"""When OPA evaluates a rule, it generates the content of a [virtual documents](https://www.openpolicyagent.org/docs/latest/philosophy/#the-opa-document-model)
    https://www.openpolicyagent.org/docs/latest/policy-language/#rules - Rules
    """  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostCompile200ApplicationJSONResult:
    
    ast: Optional[PostCompile200ApplicationJSONResultAst] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ast'), 'exclude': lambda f: f is None }})
    r"""The types for declarations and runtime objects passed to your implementation. This consists of an abstract syntax tree (AST) of policy modules, package and import declarations, rules, expressions, and terms.
    https://godoc.org/github.com/open-policy-agent/opa/ast - AST
    """  
    id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id'), 'exclude': lambda f: f is None }})
    r"""The name of a policy module"""  
    raw: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('raw'), 'exclude': lambda f: f is None }})
    r"""A string representation of the full Rego policy"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PostCompile200ApplicationJSON:
    r"""Success"""
    
    explanation: Optional[list[PostCompile200ApplicationJSONExplanation]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('explanation'), 'exclude': lambda f: f is None }})  
    metrics: Optional[PostCompile200ApplicationJSONMetrics] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('metrics'), 'exclude': lambda f: f is None }})  
    result: Optional[list[PostCompile200ApplicationJSONResult]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('result'), 'exclude': lambda f: f is None }})  
    

@dataclasses.dataclass
class PostCompileResponse:
    
    content_type: str = dataclasses.field()  
    status_code: int = dataclasses.field()  
    four_hundred: Optional[shared_four_hundred.FourHundred] = dataclasses.field(default=None)
    r"""Bad request"""  
    post_compile_200_application_json_object: Optional[PostCompile200ApplicationJSON] = dataclasses.field(default=None)
    r"""Success"""  
    raw_response: Optional[requests_http.Response] = dataclasses.field(default=None)  
    