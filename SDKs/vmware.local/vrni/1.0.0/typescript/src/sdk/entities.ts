/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * Entities APIs
 */
export class Entities {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Show cluster details
   *
   * @remarks
   * Show cluster details
   */
  getCluster(
    req: operations.GetClusterRequest,
    security: operations.GetClusterSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetClusterResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetClusterRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/entities/clusters/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetClusterSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetClusterResponse =
        new operations.GetClusterResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.cluster = utils.objectToClass(httpRes?.data, shared.Cluster);
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Show vCenter datacenter details
   *
   * @remarks
   * Show vCenter datacenter details
   */
  getDatacenter(
    req: operations.GetDatacenterRequest,
    security: operations.GetDatacenterSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetDatacenterResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetDatacenterRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/entities/vc-datacenters/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetDatacenterSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetDatacenterResponse =
        new operations.GetDatacenterResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.vcDatacenter = utils.objectToClass(
              httpRes?.data,
              shared.VCDatacenter
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Show datastore details
   *
   * @remarks
   * Show datastore details
   */
  getDatastore(
    req: operations.GetDatastoreRequest,
    security: operations.GetDatastoreSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetDatastoreResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetDatastoreRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/entities/datastores/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetDatastoreSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetDatastoreResponse =
        new operations.GetDatastoreResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.datastore = utils.objectToClass(
              httpRes?.data,
              shared.Datastore
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Show distributed virtual portgroup details
   *
   * @remarks
   * Show distributed virtual portgroup details
   */
  getDistributedVirtualPortgroup(
    req: operations.GetDistributedVirtualPortgroupRequest,
    security: operations.GetDistributedVirtualPortgroupSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetDistributedVirtualPortgroupResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetDistributedVirtualPortgroupRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/entities/distributed-virtual-portgroups/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetDistributedVirtualPortgroupSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetDistributedVirtualPortgroupResponse =
        new operations.GetDistributedVirtualPortgroupResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.distributedVirtualPortgroup = utils.objectToClass(
              httpRes?.data,
              shared.DistributedVirtualPortgroup
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Show distributed virtual switch details
   *
   * @remarks
   * Show distributed virtual switch details
   */
  getDistributedVirtualSwitch(
    req: operations.GetDistributedVirtualSwitchRequest,
    security: operations.GetDistributedVirtualSwitchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetDistributedVirtualSwitchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetDistributedVirtualSwitchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/entities/distributed-virtual-switches/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetDistributedVirtualSwitchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetDistributedVirtualSwitchResponse =
        new operations.GetDistributedVirtualSwitchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.distributedVirtualSwitch = utils.objectToClass(
              httpRes?.data,
              shared.DistributedVirtualSwitch
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Show firewall details
   *
   * @remarks
   * Show firewall details
   */
  getFirewall(
    req: operations.GetFirewallRequest,
    security: operations.GetFirewallSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetFirewallResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetFirewallRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/entities/firewalls/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetFirewallSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetFirewallResponse =
        new operations.GetFirewallResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.baseFirewallRule = utils.objectToClass(
              httpRes?.data,
              shared.BaseFirewallRule
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Show firewall rule details
   *
   * @remarks
   * Show firewall rule details
   */
  getFirewallRule(
    req: operations.GetFirewallRuleRequest,
    security: operations.GetFirewallRuleSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetFirewallRuleResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetFirewallRuleRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/entities/firewall-rules/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetFirewallRuleSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetFirewallRuleResponse =
        new operations.GetFirewallRuleResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.baseFirewallRule = utils.objectToClass(
              httpRes?.data,
              shared.BaseFirewallRule
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Show flow details
   *
   * @remarks
   * Show flow details
   */
  getFlow(
    req: operations.GetFlowRequest,
    security: operations.GetFlowSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetFlowResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetFlowRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/entities/flows/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetFlowSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetFlowResponse = new operations.GetFlowResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.flow = utils.objectToClass(httpRes?.data, shared.Flow);
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * List flows
   *
   * @remarks
   * List flows
   */
  getFlows(
    req: operations.GetFlowsRequest,
    security: operations.GetFlowsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetFlowsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetFlowsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/entities/flows";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetFlowsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetFlowsResponse = new operations.GetFlowsResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pagedListResponseWithTime = utils.objectToClass(
              httpRes?.data,
              shared.PagedListResponseWithTime
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Show folder details
   *
   * @remarks
   * Show folder details
   */
  getFolder(
    req: operations.GetFolderRequest,
    security: operations.GetFolderSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetFolderResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetFolderRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/entities/folders/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetFolderSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetFolderResponse =
        new operations.GetFolderResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.folder = utils.objectToClass(httpRes?.data, shared.Folder);
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Show host details
   *
   * @remarks
   * Show host details
   */
  getHost(
    req: operations.GetHostRequest,
    security: operations.GetHostSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetHostResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetHostRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/entities/hosts/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetHostSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetHostResponse = new operations.GetHostResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.host = utils.objectToClass(httpRes?.data, shared.Host);
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Show ip set details
   *
   * @remarks
   * Show ip set details
   */
  getIPSet(
    req: operations.GetIPSetRequest,
    security: operations.GetIPSetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetIPSetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetIPSetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/entities/ip-sets/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetIPSetSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetIPSetResponse = new operations.GetIPSetResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.baseIPSet = utils.objectToClass(
              httpRes?.data,
              shared.BaseIPSet
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Show layer2 network details
   *
   * @remarks
   * Show layer2 network details
   */
  getLayer2Network(
    req: operations.GetLayer2NetworkRequest,
    security: operations.GetLayer2NetworkSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetLayer2NetworkResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetLayer2NetworkRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/entities/layer2-networks/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetLayer2NetworkSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetLayer2NetworkResponse =
        new operations.GetLayer2NetworkResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.baseL2Network = utils.objectToClass(
              httpRes?.data,
              shared.BaseL2Network
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Show nsx manager details
   *
   * @remarks
   * Show nsx manager details
   */
  getNSXManager(
    req: operations.GetNSXManagerRequest,
    security: operations.GetNSXManagerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNSXManagerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNSXManagerRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/entities/nsx-managers/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetNSXManagerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNSXManagerResponse =
        new operations.GetNSXManagerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.baseEntity = utils.objectToClass(
              httpRes?.data,
              shared.BaseEntity
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Get name of an entity
   *
   * @remarks
   * Get name of an entity
   */
  getName(
    req: operations.GetNameRequest,
    security: operations.GetNameSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNameResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNameRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/entities/names/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetNameSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNameResponse = new operations.GetNameResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityName = utils.objectToClass(
              httpRes?.data,
              shared.EntityName
            );
          }
          break;
        case [401, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Get names for entities
   *
   * @remarks
   * Get names for entities.Limit of 1000 entities in a single request.
   */
  getNames(
    req: shared.NamesRequest,
    security: operations.GetNamesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNamesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.NamesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/entities/names";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetNamesSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNamesResponse = new operations.GetNamesResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.namesResponse = utils.objectToClass(
              httpRes?.data,
              shared.NamesResponse
            );
          }
          break;
        case [401, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Show problem details
   *
   * @remarks
   * Show problem event details.
   */
  getProblemEvent(
    req: operations.GetProblemEventRequest,
    security: operations.GetProblemEventSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetProblemEventResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetProblemEventRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/entities/problems/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetProblemEventSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetProblemEventResponse =
        new operations.GetProblemEventResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.problemEvent = utils.objectToClass(
              httpRes?.data,
              shared.ProblemEvent
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Show security group details
   *
   * @remarks
   * Show security group details
   */
  getSecurityGroup(
    req: operations.GetSecurityGroupRequest,
    security: operations.GetSecurityGroupSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSecurityGroupResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSecurityGroupRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/entities/security-groups/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetSecurityGroupSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSecurityGroupResponse =
        new operations.GetSecurityGroupResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.baseSecurityGroup = utils.objectToClass(
              httpRes?.data,
              shared.BaseSecurityGroup
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Show security tag details
   *
   * @remarks
   * Show security tag details
   */
  getSecurityTag(
    req: operations.GetSecurityTagRequest,
    security: operations.GetSecurityTagSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSecurityTagResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSecurityTagRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/entities/security-tags/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetSecurityTagSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSecurityTagResponse =
        new operations.GetSecurityTagResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.securityTag = utils.objectToClass(
              httpRes?.data,
              shared.SecurityTag
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Show service details
   *
   * @remarks
   * Show service details
   */
  getService(
    req: operations.GetServiceRequest,
    security: operations.GetServiceSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetServiceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetServiceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/entities/services/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetServiceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetServiceResponse =
        new operations.GetServiceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.baseService = utils.objectToClass(
              httpRes?.data,
              shared.BaseService
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Show service group details
   *
   * @remarks
   * Show service group details
   */
  getServiceGroup(
    req: operations.GetServiceGroupRequest,
    security: operations.GetServiceGroupSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetServiceGroupResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetServiceGroupRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/entities/service-groups/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetServiceGroupSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetServiceGroupResponse =
        new operations.GetServiceGroupResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.group = utils.objectToClass(httpRes?.data, shared.Group);
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Show vCenter manager details
   *
   * @remarks
   * Show vCenter manager details
   */
  getVcenterManager(
    req: operations.GetVcenterManagerRequest,
    security: operations.GetVcenterManagerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetVcenterManagerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetVcenterManagerRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/entities/vcenter-managers/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetVcenterManagerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetVcenterManagerResponse =
        new operations.GetVcenterManagerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.vCenterManager = utils.objectToClass(
              httpRes?.data,
              shared.VCenterManager
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Show vm details
   *
   * @remarks
   * Show vm details
   */
  getVm(
    req: operations.GetVmRequest,
    security: operations.GetVmSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetVmResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetVmRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/entities/vms/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetVmSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetVmResponse = new operations.GetVmResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.baseVirtualMachine = utils.objectToClass(
              httpRes?.data,
              shared.BaseVirtualMachine
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Show vmknic details
   *
   * @remarks
   * Show vmknic details
   */
  getVmknic(
    req: operations.GetVmknicRequest,
    security: operations.GetVmknicSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetVmknicResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetVmknicRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/entities/vmknics/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetVmknicSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetVmknicResponse =
        new operations.GetVmknicResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.vmknic = utils.objectToClass(httpRes?.data, shared.Vmknic);
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Show vnic details
   *
   * @remarks
   * Show vnic details
   */
  getVnic(
    req: operations.GetVnicRequest,
    security: operations.GetVnicSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetVnicResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetVnicRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/entities/vnics/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetVnicSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetVnicResponse = new operations.GetVnicResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.baseVnic = utils.objectToClass(httpRes?.data, shared.BaseVnic);
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 404, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * List clusters
   *
   * @remarks
   * List clusters
   */
  listClusters(
    req: operations.ListClustersRequest,
    security: operations.ListClustersSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ListClustersResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListClustersRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/entities/clusters";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListClustersSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListClustersResponse =
        new operations.ListClustersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pagedListResponseWithTime = utils.objectToClass(
              httpRes?.data,
              shared.PagedListResponseWithTime
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * List vCenter datacenters
   *
   * @remarks
   * List vCenter datacenters
   */
  listDatacenters(
    req: operations.ListDatacentersRequest,
    security: operations.ListDatacentersSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ListDatacentersResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListDatacentersRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/entities/vc-datacenters";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListDatacentersSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListDatacentersResponse =
        new operations.ListDatacentersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pagedListResponseWithTime = utils.objectToClass(
              httpRes?.data,
              shared.PagedListResponseWithTime
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * List datastores
   *
   * @remarks
   * List datastores
   */
  listDatastores(
    req: operations.ListDatastoresRequest,
    security: operations.ListDatastoresSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ListDatastoresResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListDatastoresRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/entities/datastores";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListDatastoresSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListDatastoresResponse =
        new operations.ListDatastoresResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pagedListResponseWithTime = utils.objectToClass(
              httpRes?.data,
              shared.PagedListResponseWithTime
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * List distributed virtual portgroups
   *
   * @remarks
   * List distributed virtual portgroups
   */
  listDistributedVirtualPortgroups(
    req: operations.ListDistributedVirtualPortgroupsRequest,
    security: operations.ListDistributedVirtualPortgroupsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ListDistributedVirtualPortgroupsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListDistributedVirtualPortgroupsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/entities/distributed-virtual-portgroups";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListDistributedVirtualPortgroupsSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListDistributedVirtualPortgroupsResponse =
        new operations.ListDistributedVirtualPortgroupsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pagedListResponseWithTime = utils.objectToClass(
              httpRes?.data,
              shared.PagedListResponseWithTime
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * List distributed virtual switches
   *
   * @remarks
   * List distributed virtual switches
   */
  listDistributedVirtualSwitches(
    req: operations.ListDistributedVirtualSwitchesRequest,
    security: operations.ListDistributedVirtualSwitchesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ListDistributedVirtualSwitchesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListDistributedVirtualSwitchesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/entities/distributed-virtual-switches";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListDistributedVirtualSwitchesSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListDistributedVirtualSwitchesResponse =
        new operations.ListDistributedVirtualSwitchesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pagedListResponseWithTime = utils.objectToClass(
              httpRes?.data,
              shared.PagedListResponseWithTime
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * List firewall rules
   *
   * @remarks
   * List firewall rules
   */
  listFirewallRules(
    req: operations.ListFirewallRulesRequest,
    security: operations.ListFirewallRulesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ListFirewallRulesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListFirewallRulesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/entities/firewall-rules";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListFirewallRulesSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListFirewallRulesResponse =
        new operations.ListFirewallRulesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pagedListResponseWithTime = utils.objectToClass(
              httpRes?.data,
              shared.PagedListResponseWithTime
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * List firewalls
   *
   * @remarks
   * List firewalls
   */
  listFirewalls(
    req: operations.ListFirewallsRequest,
    security: operations.ListFirewallsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ListFirewallsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListFirewallsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/entities/firewalls";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListFirewallsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListFirewallsResponse =
        new operations.ListFirewallsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pagedListResponseWithTime = utils.objectToClass(
              httpRes?.data,
              shared.PagedListResponseWithTime
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * List folders
   *
   * @remarks
   * List folders
   */
  listFolders(
    req: operations.ListFoldersRequest,
    security: operations.ListFoldersSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ListFoldersResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListFoldersRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/entities/folders";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListFoldersSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListFoldersResponse =
        new operations.ListFoldersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pagedListResponseWithTime = utils.objectToClass(
              httpRes?.data,
              shared.PagedListResponseWithTime
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * List hosts
   *
   * @remarks
   * List hosts
   */
  listHosts(
    req: operations.ListHostsRequest,
    security: operations.ListHostsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ListHostsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListHostsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/entities/hosts";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListHostsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListHostsResponse =
        new operations.ListHostsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pagedListResponseWithTime = utils.objectToClass(
              httpRes?.data,
              shared.PagedListResponseWithTime
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * List ip sets
   *
   * @remarks
   * List ip sets
   */
  listIPSets(
    req: operations.ListIPSetsRequest,
    security: operations.ListIPSetsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ListIPSetsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListIPSetsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/entities/ip-sets";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListIPSetsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListIPSetsResponse =
        new operations.ListIPSetsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pagedListResponseWithTime = utils.objectToClass(
              httpRes?.data,
              shared.PagedListResponseWithTime
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * List layer2 networks
   *
   * @remarks
   * List layer2 networks
   */
  listLayer2Networks(
    req: operations.ListLayer2NetworksRequest,
    security: operations.ListLayer2NetworksSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ListLayer2NetworksResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListLayer2NetworksRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/entities/layer2-networks";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListLayer2NetworksSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListLayer2NetworksResponse =
        new operations.ListLayer2NetworksResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pagedListResponseWithTime = utils.objectToClass(
              httpRes?.data,
              shared.PagedListResponseWithTime
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * List nsx managers
   *
   * @remarks
   * List nsx managers
   */
  listNSXManagers(
    req: operations.ListNSXManagersRequest,
    security: operations.ListNSXManagersSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ListNSXManagersResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListNSXManagersRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/entities/nsx-managers";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListNSXManagersSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListNSXManagersResponse =
        new operations.ListNSXManagersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pagedListResponseWithTime = utils.objectToClass(
              httpRes?.data,
              shared.PagedListResponseWithTime
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * List problems
   *
   * @remarks
   * List problem events.
   */
  listProblemEvents(
    req: operations.ListProblemEventsRequest,
    security: operations.ListProblemEventsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ListProblemEventsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListProblemEventsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/entities/problems";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListProblemEventsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListProblemEventsResponse =
        new operations.ListProblemEventsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pagedListResponseWithTime = utils.objectToClass(
              httpRes?.data,
              shared.PagedListResponseWithTime
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * List security groups
   *
   * @remarks
   * List security groups
   */
  listSecurityGroups(
    req: operations.ListSecurityGroupsRequest,
    security: operations.ListSecurityGroupsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ListSecurityGroupsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListSecurityGroupsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/entities/security-groups";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListSecurityGroupsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListSecurityGroupsResponse =
        new operations.ListSecurityGroupsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pagedListResponseWithTime = utils.objectToClass(
              httpRes?.data,
              shared.PagedListResponseWithTime
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * List security tags
   *
   * @remarks
   * List security tags
   */
  listSecurityTags(
    req: operations.ListSecurityTagsRequest,
    security: operations.ListSecurityTagsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ListSecurityTagsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListSecurityTagsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/entities/security-tags";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListSecurityTagsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListSecurityTagsResponse =
        new operations.ListSecurityTagsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pagedListResponseWithTime = utils.objectToClass(
              httpRes?.data,
              shared.PagedListResponseWithTime
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * List service groups
   *
   * @remarks
   * List service groups
   */
  listServiceGroups(
    req: operations.ListServiceGroupsRequest,
    security: operations.ListServiceGroupsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ListServiceGroupsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListServiceGroupsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/entities/service-groups";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListServiceGroupsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListServiceGroupsResponse =
        new operations.ListServiceGroupsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pagedListResponseWithTime = utils.objectToClass(
              httpRes?.data,
              shared.PagedListResponseWithTime
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * List services
   *
   * @remarks
   * List services
   */
  listServices(
    req: operations.ListServicesRequest,
    security: operations.ListServicesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ListServicesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListServicesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/entities/services";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListServicesSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListServicesResponse =
        new operations.ListServicesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pagedListResponseWithTime = utils.objectToClass(
              httpRes?.data,
              shared.PagedListResponseWithTime
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * List vCenter managers
   *
   * @remarks
   * List vCenter managers
   */
  listVcenterManagers(
    req: operations.ListVcenterManagersRequest,
    security: operations.ListVcenterManagersSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ListVcenterManagersResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListVcenterManagersRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/entities/vcenter-managers";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListVcenterManagersSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListVcenterManagersResponse =
        new operations.ListVcenterManagersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pagedListResponseWithTime = utils.objectToClass(
              httpRes?.data,
              shared.PagedListResponseWithTime
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * List vmknics
   *
   * @remarks
   * List vmknics
   */
  listVmknics(
    req: operations.ListVmknicsRequest,
    security: operations.ListVmknicsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ListVmknicsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListVmknicsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/entities/vmknics";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListVmknicsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListVmknicsResponse =
        new operations.ListVmknicsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pagedListResponseWithTime = utils.objectToClass(
              httpRes?.data,
              shared.PagedListResponseWithTime
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * List vms
   *
   * @remarks
   * List vms
   */
  listVms(
    req: operations.ListVmsRequest,
    security: operations.ListVmsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ListVmsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListVmsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/entities/vms";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListVmsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListVmsResponse = new operations.ListVmsResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pagedListResponseWithTime = utils.objectToClass(
              httpRes?.data,
              shared.PagedListResponseWithTime
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * List vnics
   *
   * @remarks
   * List vnics
   */
  listVnics(
    req: operations.ListVnicsRequest,
    security: operations.ListVnicsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ListVnicsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListVnicsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/entities/vnics";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListVnicsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListVnicsResponse =
        new operations.ListVnicsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pagedListResponseWithTime = utils.objectToClass(
              httpRes?.data,
              shared.PagedListResponseWithTime
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiError = utils.objectToClass(httpRes?.data, shared.ApiError);
          }
          break;
        case [401, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }
}
