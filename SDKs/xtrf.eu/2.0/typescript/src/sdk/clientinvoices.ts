/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * To change the description use /examples/TagsDescriptions.json
 */
export class ClientInvoices {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Adds a new payment to the client invoice. The invoice payment status (Not Paid, Partially Paid, Fully Paid) is automatically recalculated.
   *
   * @remarks
   * Adds a new payment to the client invoice. The invoice payment status (Not Paid, Partially Paid, Fully Paid) is automatically recalculated.
   */
  createPayment(
    req: operations.CreatePaymentRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreatePaymentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreatePaymentRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/accounting/customers/invoices/{invoiceId}/payments",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "paymentDTO",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreatePaymentResponse =
        new operations.CreatePaymentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Creates a new invoice.
   *
   * @remarks
   * Creates a new invoice from tasks. Tasks are grouped by client and currency, therefore multiple invoices can be created.If any of the tasks cannot be invoiced (ie. it is already invoiced, not invoiceable, not associated with a project) then an error is reported.
   */
  create1(
    req: shared.CustomerInvoiceCreateDTO,
    config?: AxiosRequestConfig
  ): Promise<operations.Create1Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.CustomerInvoiceCreateDTO(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/accounting/customers/invoices";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.Create1Response = new operations.Create1Response({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.customerInvoiceCreateResultDTO = utils.objectToClass(
              httpRes?.data,
              shared.CustomerInvoiceCreateResultDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Removes a client invoice.
   *
   * @remarks
   * Removes a client invoice.
   */
  delete1(
    req: operations.Delete1Request,
    config?: AxiosRequestConfig
  ): Promise<operations.Delete1Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.Delete1Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/accounting/customers/invoices/{invoiceId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.Delete1Response = new operations.Delete1Response({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Removes a customer payment.
   *
   * @remarks
   * Removes a customer payment.
   */
  delete2(
    req: operations.Delete2Request,
    config?: AxiosRequestConfig
  ): Promise<operations.Delete2Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.Delete2Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/accounting/customers/payments/{paymentId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.Delete2Response = new operations.Delete2Response({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Generates client invoices' documents.
   *
   * @remarks
   * Generates client invoices' documents.
   */
  downloadDocuments(
    req: shared.DownloadDocumentsRequestDTO,
    config?: AxiosRequestConfig
  ): Promise<operations.DownloadDocumentsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.DownloadDocumentsRequestDTO(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/accounting/customers/invoices/documents";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DownloadDocumentsResponse =
        new operations.DownloadDocumentsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.urlResultDTO = utils.objectToClass(
              httpRes?.data,
              shared.UrlResultDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Duplicate client invoice.
   *
   * @remarks
   * Duplicate client invoice.
   */
  duplicate(
    req: operations.DuplicateRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DuplicateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DuplicateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/accounting/customers/invoices/{invoiceId}/duplicate",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DuplicateResponse =
        new operations.DuplicateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.customerInvoiceDTO = utils.objectToClass(
              httpRes?.data,
              shared.CustomerInvoiceDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Duplicate client invoice as pro forma.
   *
   * @remarks
   * Duplicate client invoice as pro forma.
   */
  duplicateAsProForma(
    req: operations.DuplicateAsProFormaRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DuplicateAsProFormaResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DuplicateAsProFormaRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/accounting/customers/invoices/{invoiceId}/duplicate/proForma",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DuplicateAsProFormaResponse =
        new operations.DuplicateAsProFormaResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.customerInvoiceDTO = utils.objectToClass(
              httpRes?.data,
              shared.CustomerInvoiceDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists all client invoices in all statuses (including not ready and drafts) that have been updated since a specific date.
   *
   * @remarks
   * Lists all client invoices in all statuses (including not ready and drafts) that have been updated since a specific date.
   */
  getAll(
    req: operations.GetAllRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetAllResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetAllRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/accounting/customers/invoices";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetAllResponse = new operations.GetAllResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.customerInvoiceDTOS = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.customerInvoiceDTOS = utils.objectToClass(
              httpRes?.data,
              shared.CustomerInvoiceDTO,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns client invoices' internal identifiers.
   *
   * @remarks
   * Returns client invoices' internal identifiers.
   */
  getAllIds(
    req: operations.GetAllIdsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetAllIdsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetAllIdsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/accounting/customers/invoices/ids";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetAllIdsResponse =
        new operations.GetAllIdsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.getAllIdsDefaultApplicationVndXtrfV1PlusJsonInt32Integers =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns client invoice details.
   *
   * @remarks
   * Returns client invoice details.
   */
  getById(
    req: operations.GetByIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetByIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetByIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/accounting/customers/invoices/{invoiceId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetByIdResponse = new operations.GetByIdResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.customerInvoiceDTO = utils.objectToClass(
              httpRes?.data,
              shared.CustomerInvoiceDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns dates of a given client invoice.
   *
   * @remarks
   * Returns dates of a given client invoice.
   */
  getDates(
    req: operations.GetDatesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetDatesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetDatesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/accounting/customers/invoices/{invoiceId}/dates",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetDatesResponse = new operations.GetDatesResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.customerInvoiceDatesDTO = utils.objectToClass(
              httpRes?.data,
              shared.CustomerInvoiceDatesDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Generates client invoice document (PDF).
   *
   * @remarks
   * Generates client invoice document (PDF).
   */
  getDocument(
    req: operations.GetDocumentRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetDocumentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetDocumentRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/accounting/customers/invoices/{invoiceId}/document",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetDocumentResponse =
        new operations.GetDocumentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.urlResultDTO = utils.objectToClass(
              httpRes?.data,
              shared.UrlResultDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns payment terms of a given client invoice.
   *
   * @remarks
   * Returns payment terms of a given client invoice.
   */
  getPaymentTerms(
    req: operations.GetPaymentTermsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetPaymentTermsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetPaymentTermsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/accounting/customers/invoices/{invoiceId}/paymentTerms",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetPaymentTermsResponse =
        new operations.GetPaymentTermsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.paymentTermsDTO = utils.objectToClass(
              httpRes?.data,
              shared.PaymentTermsDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns all payments for the client invoice.
   *
   * @remarks
   * Returns all payments for the client invoice.
   */
  getPayments(
    req: operations.GetPaymentsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetPaymentsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetPaymentsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/accounting/customers/invoices/{invoiceId}/payments",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetPaymentsResponse =
        new operations.GetPaymentsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.paymentDTOS = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.paymentDTOS = utils.objectToClass(
              httpRes?.data,
              shared.PaymentDTO,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Sends reminder.
   *
   * @remarks
   * Sends reminder.
   */
  sendReminder(
    req: operations.SendReminderRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.SendReminderResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.SendReminderRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/accounting/customers/invoices/{invoiceId}/sendReminder",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SendReminderResponse =
        new operations.SendReminderResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Sends reminders. Returns number of sent e-mails.
   *
   * @remarks
   * Sends reminders. Returns number of sent e-mails.
   */
  sendReminders(
    req: shared.SendRemindersRequestDTO,
    config?: AxiosRequestConfig
  ): Promise<operations.SendRemindersResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.SendRemindersRequestDTO(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/accounting/customers/invoices/sendReminders";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SendRemindersResponse =
        new operations.SendRemindersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.sendRemindersResponseDTO = utils.objectToClass(
              httpRes?.data,
              shared.SendRemindersResponseDTO
            );
          }
          break;
      }

      return res;
    });
  }
}
