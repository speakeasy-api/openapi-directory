"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
from ..shared import chargemodelconfigurationtype as shared_chargemodelconfigurationtype
from ..shared import getdiscountapplydetailstype as shared_getdiscountapplydetailstype
from ..shared import gettiertype as shared_gettiertype
from dataclasses_json import Undefined, dataclass_json
from datetime import date
from marshmallow import fields
from sdk import utils
from typing import Optional


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GETSubscriptionRatePlanChargesType:
    r"""Container for custom fields of a Rate Plan Charge object."""
    
    apply_discount_to: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('applyDiscountTo'), 'exclude': lambda f: f is None }})
    r"""Specifies the type of charges a specific discount applies to.
    
    This field is only used when applied to a discount charge model. If you are not using a discount charge model, the value is null.
    
    Possible values:
    
    * `RECURRING`
    * `USAGE`
    * `ONETIMERECURRING`
    * `ONETIMEUSAGE`
    * `RECURRINGUSAGE`
    * `ONETIMERECURRINGUSAGE`
    """  
    billing_day: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('billingDay'), 'exclude': lambda f: f is None }})
    r"""Billing cycle day (BCD), which is when bill runs generate invoices
    for charges associated with the product rate plan charge or the account.  
    
    Values:
    
    * `DefaultFromCustomer`
    * `SpecificDayofMonth(#)`
    * `SubscriptionStartDay`
    * `ChargeTriggerDay`
    * `SpecificDayofWeek/dayofweek`: in which dayofweek is the day in the week you define your billing periods to start.
    
    In the response data, a day-of-the-month value (`1`-`31`) appears in place of the hash sign above (\"#\"). If this value exceeds the number of days in a particular month, the last day of the month is used as the BCD.
    """  
    billing_period: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('billingPeriod'), 'exclude': lambda f: f is None }})
    r"""Allows billing period to be overridden on the rate plan charge."""  
    billing_period_alignment: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('billingPeriodAlignment'), 'exclude': lambda f: f is None }})
    r"""Possible values:
    
    * `AlignToCharge`
    * `AlignToSubscriptionStart`
    * `AlignToTermStart`
    """  
    billing_timing: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('billingTiming'), 'exclude': lambda f: f is None }})
    r"""The billing timing for the charge. This field is only used if the `ratePlanChargeType` value is `Recurring`.
    
    Possible values are:
    
    * `In Advance`
    * `In Arrears`
    
    **Note:** This feature is in **Limited Availability**. If you wish to have access to the feature, submit a request at [Zuora Global Support](http://support.zuora.com/).
    """  
    charged_through_date: Optional[date] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('chargedThroughDate'), 'encoder': utils.dateisoformat(True), 'decoder': utils.datefromisoformat, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""The date through which a customer has been billed for the charge."""  
    charge_model_configuration: Optional[shared_chargemodelconfigurationtype.ChargeModelConfigurationType] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('chargeModelConfiguration'), 'exclude': lambda f: f is None }})
    r"""Container for charge model configuration data.
    
    **Note**: This field is only available if you have the High Water Mark, Pre-Rated Pricing, or Multi-Attribute Pricing charge models enabled. These charge models are available for customers with Enterprise and Nine editions by default. If you are a Growth customer, see [Zuora Editions](https://knowledgecenter.zuora.com/BB_Introducing_Z_Business/C_Zuora_Editions) for pricing information.
    """  
    currency: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('currency'), 'exclude': lambda f: f is None }})
    r"""Currency used by the account. For example, `USD` or `EUR`."""  
    description: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('description'), 'exclude': lambda f: f is None }})
    r"""Description of the rate plan charge."""  
    discount_amount: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('discountAmount'), 'exclude': lambda f: f is None }})
    r"""The amount of the discount."""  
    discount_apply_details: Optional[list[shared_getdiscountapplydetailstype.GETDiscountApplyDetailsType]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('discountApplyDetails'), 'exclude': lambda f: f is None }})
    r"""Container for the application details about a discount rate plan charge.
    
    Only discount rate plan charges have values in this field.
    """  
    discount_class: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('discountClass'), 'exclude': lambda f: f is None }})
    r"""The class that the discount belongs to. The discount class defines the order in which discount rate plan charges are applied.
    
    For more information, see [Manage Discount Classes](https://knowledgecenter.zuora.com/BC_Subscription_Management/Product_Catalog/B_Charge_Models/Manage_Discount_Classes).
    """  
    discount_level: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('discountLevel'), 'exclude': lambda f: f is None }})
    r"""The level of the discount. Values: `RatePlan`, `Subscription`, `Account`."""  
    discount_percentage: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('discountPercentage'), 'exclude': lambda f: f is None }})
    r"""The amount of the discount as a percentage."""  
    dmrc: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('dmrc'), 'exclude': lambda f: f is None }})
    r"""The change (delta) of monthly recurring charge exists when the change in monthly recurring revenue caused by an amendment or a new subscription."""  
    done: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('done'), 'exclude': lambda f: f is None }})
    r"""A value of `true` indicates that an invoice for a charge segment has been completed. A value of `false` indicates that an invoice has not been completed for the charge segment."""  
    dtcv: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('dtcv'), 'exclude': lambda f: f is None }})
    r"""After an amendment or an AutomatedPriceChange event, `dtcv` displays the change (delta) for the total contract value (TCV) amount for this charge, compared with its previous value with recurring charge types."""  
    effective_end_date: Optional[date] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('effectiveEndDate'), 'encoder': utils.dateisoformat(True), 'decoder': utils.datefromisoformat, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""The effective end date of the rate plan charge."""  
    effective_start_date: Optional[date] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('effectiveStartDate'), 'encoder': utils.dateisoformat(True), 'decoder': utils.datefromisoformat, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""The effective start date of the rate plan charge."""  
    end_date_condition: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('endDateCondition'), 'exclude': lambda f: f is None }})
    r"""Defines when the charge ends after the charge trigger date.
    
    If the subscription ends before the charge end date, the charge ends when the subscription ends. But if the subscription end date is subsequently changed through a Renewal, or Terms and Conditions amendment, the charge will end on the charge end date.
    
    Values:
    
    * `Subscription_End`
    * `Fixed_Period`
    * `Specific_End_Date`
    """  
    id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id'), 'exclude': lambda f: f is None }})
    r"""Rate plan charge ID."""  
    included_units: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('includedUnits'), 'exclude': lambda f: f is None }})
    r"""Specifies the number of units in the base set of units."""  
    list_price_base: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('listPriceBase'), 'exclude': lambda f: f is None }})
    r"""List price base; possible values are:
    
    * `Per_Billing_Period`
    * `Per_Month`
    * `Per_Week`
    """  
    model: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('model'), 'exclude': lambda f: f is None }})
    r"""Charge model; possible values are:
    
    * `FlatFee`
    * `PerUnit`
    * `Overage`
    * `Volume`
    * `Tiered`
    * `TieredWithOverage`
    * `DiscountFixedAmount`
    * `DiscountPercentage`
    * `MultiAttributePricing`
    * `PreratedPerUnit`
    * `PreratedPricing`
    * `HighWatermarkVolumePricing`
    * `HighWatermarkTieredPricing`
    """  
    mrr: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('mrr'), 'exclude': lambda f: f is None }})
    r"""Monthly recurring revenue of the rate plan charge."""  
    name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name'), 'exclude': lambda f: f is None }})
    r"""Charge name."""  
    number: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('number'), 'exclude': lambda f: f is None }})
    r"""Charge number."""  
    number_of_periods: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('numberOfPeriods'), 'exclude': lambda f: f is None }})
    r"""Specifies the number of periods to use when calculating charges in an overage smoothing charge model."""  
    original_charge_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('originalChargeId'), 'exclude': lambda f: f is None }})
    r"""The original ID of the rate plan charge."""  
    overage_calculation_option: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('overageCalculationOption'), 'exclude': lambda f: f is None }})
    r"""Determines when to calculate overage charges."""  
    overage_price: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('overagePrice'), 'exclude': lambda f: f is None }})
    r"""The price for units over the allowed amount."""  
    overage_unused_units_credit_option: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('overageUnusedUnitsCreditOption'), 'exclude': lambda f: f is None }})
    r"""Determines whether to credit the customer with unused units of usage."""  
    price: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('price'), 'exclude': lambda f: f is None }})
    r"""The price associated with the rate plan charge expressed as a decimal."""  
    price_change_option: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('priceChangeOption'), 'exclude': lambda f: f is None }})
    r"""When the following is true:
    
    1. AutomatedPriceChange setting is on
    
    2. Charge type is not one-time
    
    3. Charge model is not discount percentage
    
    Then an automatic price change can have a value for when a termed subscription is renewed. 
    
    Values (one of the following):
    
    * `NoChange` (default)
    * `SpecificPercentageValue`
    * `UseLatestProductCatalogPricing`
    """  
    price_increase_percentage: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('priceIncreasePercentage'), 'exclude': lambda f: f is None }})
    r"""A planned future price increase amount as a percentage."""  
    pricing_summary: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('pricingSummary'), 'exclude': lambda f: f is None }})
    r"""Concise description of rate plan charge model."""  
    processed_through_date: Optional[date] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('processedThroughDate'), 'encoder': utils.dateisoformat(True), 'decoder': utils.datefromisoformat, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""The date until when charges have been processed. When billing in arrears, such as usage, this field value is the the same as the `ChargedThroughDate` value. This date is the earliest date when a charge can be amended."""  
    product_rate_plan_charge_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('productRatePlanChargeId'), 'exclude': lambda f: f is None }})  
    quantity: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('quantity'), 'exclude': lambda f: f is None }})
    r"""The quantity of units, such as the number of authors in a hosted wiki service. Valid for all charge models except for Flat Fee pricing."""  
    rating_group: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ratingGroup'), 'exclude': lambda f: f is None }})
    r"""Specifies a rating group based on which usage records are rated.
    
    Possible values:
    
    - `ByBillingPeriod` (default): The rating is based on all the usages in a billing period.
    - `ByUsageStartDate`: The rating is based on all the usages on the same usage start date. 
    - `ByUsageRecord`: The rating is based on each usage record.
    - `ByUsageUpload`: The rating is based on all the  usages in a uploaded usage file (`.xls` or `.csv`).
    - `ByGroupId`: The rating is based on all the usages in a custom group.
    
    **Note:** 
    - The `ByBillingPeriod` value can be applied for all charge models. 
    - The `ByUsageStartDate`, `ByUsageRecord`, and `ByUsageUpload` values can only be applied for per unit, volume pricing, and tiered pricing charge models. 
    - The `ByGroupId` value is only available if you have the Active Rating feature enabled.
    - Use this field only for Usage charges. One-Time Charges and Recurring Charges return `NULL`.
    """  
    segment: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('segment'), 'exclude': lambda f: f is None }})
    r"""The identifying number of the subscription rate plan segment. Segments are numbered sequentially, starting with 1."""  
    smoothing_model: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('smoothingModel'), 'exclude': lambda f: f is None }})
    r"""Specifies when revenue recognition begins. When charge model is `Overage` or `TieredWithOverage`, `smoothingModel` will be one of the following values:
    
    * `ContractEffectiveDate`
    * `ServiceActivationDate`
    * `CustomerAcceptanceDate`
    """  
    specific_billing_period: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('specificBillingPeriod'), 'exclude': lambda f: f is None }})
    r"""Customizes the number of month or week for the charges billing period. This field is required if you set the value of the `BillingPeriod` field to `Specific_Months` or `Specific_Weeks`."""  
    specific_end_date: Optional[date] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('specificEndDate'), 'encoder': utils.dateisoformat(True), 'decoder': utils.datefromisoformat, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""The specific date on which the charge ends. If the subscription ends before the specific end date, the charge ends when the subscription ends. But if the subscription end date is subsequently changed through a Renewal, or Terms and Conditions amendment, the charge will end on the specific end date."""  
    tcv: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('tcv'), 'exclude': lambda f: f is None }})
    r"""The total contract value."""  
    tiers: Optional[list[shared_gettiertype.GETTierType]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('tiers'), 'exclude': lambda f: f is None }})
    r"""One or many defined ranges with distinct pricing."""  
    trigger_date: Optional[date] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('triggerDate'), 'encoder': utils.dateisoformat(True), 'decoder': utils.datefromisoformat, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""The date that the rate plan charge will be triggered."""  
    trigger_event: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('triggerEvent'), 'exclude': lambda f: f is None }})
    r"""The event that will cause the rate plan charge to be triggered.
    
    Possible values: 
    
    * `ContractEffective`
    * `ServiceActivation`
    * `CustomerAcceptance`
    * `SpecificDate`
    """  
    type: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type'), 'exclude': lambda f: f is None }})
    r"""Charge type. Possible values are: `OneTime`, `Recurring`, `Usage`."""  
    unused_units_credit_rates: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('unusedUnitsCreditRates'), 'exclude': lambda f: f is None }})
    r"""Specifies the rate to credit a customer for unused units of usage. This field is applicable only for overage charge models when the
    `OverageUnusedUnitsCreditOption` field value is `CreditBySpecificRate`.
    """  
    uom: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('uom'), 'exclude': lambda f: f is None }})
    r"""Specifies the units to measure usage."""  
    up_to_periods: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('upToPeriods'), 'exclude': lambda f: f is None }})
    r"""Specifies the length of the period during which the charge is active. If this period ends before the subscription ends, the charge ends when this period ends.
    
    If the subscription end date is subsequently changed through a Renewal, or Terms and Conditions amendment, the charge end date will change accordingly up to the original period end.
    """  
    up_to_periods_type: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('upToPeriodsType'), 'exclude': lambda f: f is None }})
    r"""The period type used to define when the charge ends.
    
    Values:
    
    * `Billing_Periods`
    * `Days`
    * `Weeks`
    * `Months`
    * `Years`
    """  
    usage_record_rating_option: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('usageRecordRatingOption'), 'exclude': lambda f: f is None }})
    r"""Determines how Zuora processes usage records for per-unit usage charges."""  
    version: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('version'), 'exclude': lambda f: f is None }})
    r"""Rate plan charge revision number."""  
    