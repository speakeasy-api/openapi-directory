<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class FastestAndNextDepartures 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * getFastestDeparturesByCRS is used to get the fastest next service running between two stations. Multiple destinations can be specified. This will typically return a single train service, but will also return a replacement bus or ferry service if in place.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetFastestDeparturesByCRSRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetFastestDeparturesByCRSResponse
     */
	public function getFastestDeparturesByCRS(
        \OpenAPI\OpenAPI\Models\Operations\GetFastestDeparturesByCRSRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetFastestDeparturesByCRSResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/getFastestDeparturesByCRS/{CRS}', \OpenAPI\OpenAPI\Models\Operations\GetFastestDeparturesByCRSRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetFastestDeparturesByCRSRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetFastestDeparturesByCRSResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 429 or $httpResponse->getStatusCode() === 500 or $httpResponse->getStatusCode() === 503) {
        }

        return $response;
    }
	
    /**
     * getNextDeparturesByCRS is used to get the next service running between two stations. Multiple destinations can be specified. This will typically return a single train service, but will also return a replacement bus or ferry service if in place. This will return the next departures for each of the filterList stations specified. It may not return the fastest next service. To get the fastest next service use the getFastestDeparturesByCRS endpoint.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetNextDeparturesByCRSRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNextDeparturesByCRSResponse
     */
	public function getNextDeparturesByCRS(
        \OpenAPI\OpenAPI\Models\Operations\GetNextDeparturesByCRSRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetNextDeparturesByCRSResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/getNextDeparturesByCRS/{CRS}', \OpenAPI\OpenAPI\Models\Operations\GetNextDeparturesByCRSRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetNextDeparturesByCRSRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNextDeparturesByCRSResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 429 or $httpResponse->getStatusCode() === 500 or $httpResponse->getStatusCode() === 503) {
        }

        return $response;
    }
}