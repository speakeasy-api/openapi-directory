// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"fmt"
	"net/http"
)

type GetServersIDRequest struct {
	// ID of the Server
	ID int64 `pathParam:"style=simple,explode=false,name=id"`
}

type GetServersID200ApplicationJSONServerDatacenterLocation struct {
	// City the Location is closest to
	City string `json:"city"`
	// ISO 3166-1 alpha-2 code of the country the Location resides in
	Country string `json:"country"`
	// Description of the Location
	Description string `json:"description"`
	// ID of the Location
	ID float64 `json:"id"`
	// Latitude of the city closest to the Location
	Latitude float64 `json:"latitude"`
	// Longitude of the city closest to the Location
	Longitude float64 `json:"longitude"`
	// Unique identifier of the Location
	Name string `json:"name"`
	// Name of network zone this Location resides in
	NetworkZone string `json:"network_zone"`
}

// GetServersID200ApplicationJSONServerDatacenterServerTypes - The Server types the Datacenter can handle
type GetServersID200ApplicationJSONServerDatacenterServerTypes struct {
	// IDs of Server types that are supported and for which the Datacenter has enough resources left
	Available []float64 `json:"available"`
	// IDs of Server types that are supported and for which the Datacenter has enough resources left
	AvailableForMigration []float64 `json:"available_for_migration"`
	// IDs of Server types that are supported in the Datacenter
	Supported []float64 `json:"supported"`
}

// GetServersID200ApplicationJSONServerDatacenter - Datacenter this Resource is located at
type GetServersID200ApplicationJSONServerDatacenter struct {
	// Description of the Datacenter
	Description string `json:"description"`
	// ID of the Resource
	ID       int64                                                  `json:"id"`
	Location GetServersID200ApplicationJSONServerDatacenterLocation `json:"location"`
	// Unique identifier of the Datacenter
	Name string `json:"name"`
	// The Server types the Datacenter can handle
	ServerTypes GetServersID200ApplicationJSONServerDatacenterServerTypes `json:"server_types"`
}

// GetServersID200ApplicationJSONServerImageCreatedFrom - Information about the Server the Image was created from
type GetServersID200ApplicationJSONServerImageCreatedFrom struct {
	// ID of the Server the Image was created from
	ID int64 `json:"id"`
	// Server name at the time the Image was created
	Name string `json:"name"`
}

// GetServersID200ApplicationJSONServerImageOsFlavorEnum - Flavor of operating system contained in the Image
type GetServersID200ApplicationJSONServerImageOsFlavorEnum string

const (
	GetServersID200ApplicationJSONServerImageOsFlavorEnumUbuntu  GetServersID200ApplicationJSONServerImageOsFlavorEnum = "ubuntu"
	GetServersID200ApplicationJSONServerImageOsFlavorEnumCentos  GetServersID200ApplicationJSONServerImageOsFlavorEnum = "centos"
	GetServersID200ApplicationJSONServerImageOsFlavorEnumDebian  GetServersID200ApplicationJSONServerImageOsFlavorEnum = "debian"
	GetServersID200ApplicationJSONServerImageOsFlavorEnumFedora  GetServersID200ApplicationJSONServerImageOsFlavorEnum = "fedora"
	GetServersID200ApplicationJSONServerImageOsFlavorEnumUnknown GetServersID200ApplicationJSONServerImageOsFlavorEnum = "unknown"
)

func (e GetServersID200ApplicationJSONServerImageOsFlavorEnum) ToPointer() *GetServersID200ApplicationJSONServerImageOsFlavorEnum {
	return &e
}

func (e *GetServersID200ApplicationJSONServerImageOsFlavorEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "ubuntu":
		fallthrough
	case "centos":
		fallthrough
	case "debian":
		fallthrough
	case "fedora":
		fallthrough
	case "unknown":
		*e = GetServersID200ApplicationJSONServerImageOsFlavorEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetServersID200ApplicationJSONServerImageOsFlavorEnum: %v", v)
	}
}

// GetServersID200ApplicationJSONServerImageProtection - Protection configuration for the Resource
type GetServersID200ApplicationJSONServerImageProtection struct {
	// If true, prevents the Resource from being deleted
	Delete bool `json:"delete"`
}

// GetServersID200ApplicationJSONServerImageStatusEnum - Whether the Image can be used or if it's still being created or unavailable
type GetServersID200ApplicationJSONServerImageStatusEnum string

const (
	GetServersID200ApplicationJSONServerImageStatusEnumAvailable   GetServersID200ApplicationJSONServerImageStatusEnum = "available"
	GetServersID200ApplicationJSONServerImageStatusEnumCreating    GetServersID200ApplicationJSONServerImageStatusEnum = "creating"
	GetServersID200ApplicationJSONServerImageStatusEnumUnavailable GetServersID200ApplicationJSONServerImageStatusEnum = "unavailable"
)

func (e GetServersID200ApplicationJSONServerImageStatusEnum) ToPointer() *GetServersID200ApplicationJSONServerImageStatusEnum {
	return &e
}

func (e *GetServersID200ApplicationJSONServerImageStatusEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "available":
		fallthrough
	case "creating":
		fallthrough
	case "unavailable":
		*e = GetServersID200ApplicationJSONServerImageStatusEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetServersID200ApplicationJSONServerImageStatusEnum: %v", v)
	}
}

// GetServersID200ApplicationJSONServerImageTypeEnum - Type of the Image
type GetServersID200ApplicationJSONServerImageTypeEnum string

const (
	GetServersID200ApplicationJSONServerImageTypeEnumSystem    GetServersID200ApplicationJSONServerImageTypeEnum = "system"
	GetServersID200ApplicationJSONServerImageTypeEnumApp       GetServersID200ApplicationJSONServerImageTypeEnum = "app"
	GetServersID200ApplicationJSONServerImageTypeEnumSnapshot  GetServersID200ApplicationJSONServerImageTypeEnum = "snapshot"
	GetServersID200ApplicationJSONServerImageTypeEnumBackup    GetServersID200ApplicationJSONServerImageTypeEnum = "backup"
	GetServersID200ApplicationJSONServerImageTypeEnumTemporary GetServersID200ApplicationJSONServerImageTypeEnum = "temporary"
)

func (e GetServersID200ApplicationJSONServerImageTypeEnum) ToPointer() *GetServersID200ApplicationJSONServerImageTypeEnum {
	return &e
}

func (e *GetServersID200ApplicationJSONServerImageTypeEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "system":
		fallthrough
	case "app":
		fallthrough
	case "snapshot":
		fallthrough
	case "backup":
		fallthrough
	case "temporary":
		*e = GetServersID200ApplicationJSONServerImageTypeEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetServersID200ApplicationJSONServerImageTypeEnum: %v", v)
	}
}

type GetServersID200ApplicationJSONServerImage struct {
	// ID of Server the Image is bound to. Only set for Images of type `backup`.
	BoundTo int64 `json:"bound_to"`
	// Point in time when the Resource was created (in ISO-8601 format)
	Created string `json:"created"`
	// Information about the Server the Image was created from
	CreatedFrom GetServersID200ApplicationJSONServerImageCreatedFrom `json:"created_from"`
	// Point in time where the Image was deleted (in ISO-8601 format)
	Deleted string `json:"deleted"`
	// Point in time when the Image is considered to be deprecated (in ISO-8601 format)
	Deprecated string `json:"deprecated"`
	// Description of the Image
	Description string `json:"description"`
	// Size of the disk contained in the Image in GB
	DiskSize float64 `json:"disk_size"`
	// ID of the Resource
	ID int64 `json:"id"`
	// Size of the Image file in our storage in GB. For snapshot Images this is the value relevant for calculating costs for the Image.
	ImageSize float64 `json:"image_size"`
	// User-defined labels (key-value pairs)
	Labels map[string]string `json:"labels"`
	// Unique identifier of the Image. This value is only set for system Images.
	Name string `json:"name"`
	// Flavor of operating system contained in the Image
	OsFlavor GetServersID200ApplicationJSONServerImageOsFlavorEnum `json:"os_flavor"`
	// Operating system version
	OsVersion string `json:"os_version"`
	// Protection configuration for the Resource
	Protection GetServersID200ApplicationJSONServerImageProtection `json:"protection"`
	// Indicates that rapid deploy of the Image is available
	RapidDeploy *bool `json:"rapid_deploy,omitempty"`
	// Whether the Image can be used or if it's still being created or unavailable
	Status GetServersID200ApplicationJSONServerImageStatusEnum `json:"status"`
	// Type of the Image
	Type GetServersID200ApplicationJSONServerImageTypeEnum `json:"type"`
}

// GetServersID200ApplicationJSONServerIsoArchitectureEnum - Type of cpu architecture this iso is compatible with. Null indicates no restriction on the architecture (wildcard).
type GetServersID200ApplicationJSONServerIsoArchitectureEnum string

const (
	GetServersID200ApplicationJSONServerIsoArchitectureEnumX86 GetServersID200ApplicationJSONServerIsoArchitectureEnum = "x86"
	GetServersID200ApplicationJSONServerIsoArchitectureEnumArm GetServersID200ApplicationJSONServerIsoArchitectureEnum = "arm"
)

func (e GetServersID200ApplicationJSONServerIsoArchitectureEnum) ToPointer() *GetServersID200ApplicationJSONServerIsoArchitectureEnum {
	return &e
}

func (e *GetServersID200ApplicationJSONServerIsoArchitectureEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "x86":
		fallthrough
	case "arm":
		*e = GetServersID200ApplicationJSONServerIsoArchitectureEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetServersID200ApplicationJSONServerIsoArchitectureEnum: %v", v)
	}
}

// GetServersID200ApplicationJSONServerIsoTypeEnum - Type of the ISO
type GetServersID200ApplicationJSONServerIsoTypeEnum string

const (
	GetServersID200ApplicationJSONServerIsoTypeEnumPublic  GetServersID200ApplicationJSONServerIsoTypeEnum = "public"
	GetServersID200ApplicationJSONServerIsoTypeEnumPrivate GetServersID200ApplicationJSONServerIsoTypeEnum = "private"
)

func (e GetServersID200ApplicationJSONServerIsoTypeEnum) ToPointer() *GetServersID200ApplicationJSONServerIsoTypeEnum {
	return &e
}

func (e *GetServersID200ApplicationJSONServerIsoTypeEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "public":
		fallthrough
	case "private":
		*e = GetServersID200ApplicationJSONServerIsoTypeEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetServersID200ApplicationJSONServerIsoTypeEnum: %v", v)
	}
}

// GetServersID200ApplicationJSONServerIso - ISO Image that is attached to this Server. Null if no ISO is attached.
type GetServersID200ApplicationJSONServerIso struct {
	// Type of cpu architecture this iso is compatible with. Null indicates no restriction on the architecture (wildcard).
	Architecture GetServersID200ApplicationJSONServerIsoArchitectureEnum `json:"architecture"`
	// ISO 8601 timestamp of deprecation, null if ISO is still available. After the deprecation time it will no longer be possible to attach the ISO to Servers.
	Deprecated string `json:"deprecated"`
	// Description of the ISO
	Description string `json:"description"`
	// ID of the Resource
	ID int64 `json:"id"`
	// Unique identifier of the ISO. Only set for public ISOs
	Name string `json:"name"`
	// Type of the ISO
	Type GetServersID200ApplicationJSONServerIsoTypeEnum `json:"type"`
}

// GetServersID200ApplicationJSONServerPlacementGroupNullableTypeEnum - Type of the Placement Group
type GetServersID200ApplicationJSONServerPlacementGroupNullableTypeEnum string

const (
	GetServersID200ApplicationJSONServerPlacementGroupNullableTypeEnumSpread GetServersID200ApplicationJSONServerPlacementGroupNullableTypeEnum = "spread"
)

func (e GetServersID200ApplicationJSONServerPlacementGroupNullableTypeEnum) ToPointer() *GetServersID200ApplicationJSONServerPlacementGroupNullableTypeEnum {
	return &e
}

func (e *GetServersID200ApplicationJSONServerPlacementGroupNullableTypeEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "spread":
		*e = GetServersID200ApplicationJSONServerPlacementGroupNullableTypeEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetServersID200ApplicationJSONServerPlacementGroupNullableTypeEnum: %v", v)
	}
}

type GetServersID200ApplicationJSONServerPlacementGroupNullable struct {
	// Point in time when the Resource was created (in ISO-8601 format)
	Created string `json:"created"`
	// ID of the Resource
	ID int64 `json:"id"`
	// User-defined labels (key-value pairs)
	Labels map[string]string `json:"labels"`
	// Name of the Resource. Must be unique per Project.
	Name string `json:"name"`
	// Array of IDs of Servers that are part of this Placement Group
	Servers []int64 `json:"servers"`
	// Type of the Placement Group
	Type GetServersID200ApplicationJSONServerPlacementGroupNullableTypeEnum `json:"type"`
}

type GetServersID200ApplicationJSONServerPrivateNet struct {
	AliasIps   []string `json:"alias_ips,omitempty"`
	IP         *string  `json:"ip,omitempty"`
	MacAddress *string  `json:"mac_address,omitempty"`
	Network    *int64   `json:"network,omitempty"`
}

// GetServersID200ApplicationJSONServerProtection - Protection configuration for the Server
type GetServersID200ApplicationJSONServerProtection struct {
	// If true, prevents the Server from being deleted
	Delete bool `json:"delete"`
	// If true, prevents the Server from being rebuilt
	Rebuild bool `json:"rebuild"`
}

// GetServersID200ApplicationJSONServerPublicNetServerPublicNetFirewallStatusEnum - Status of the Firewall on the Server
type GetServersID200ApplicationJSONServerPublicNetServerPublicNetFirewallStatusEnum string

const (
	GetServersID200ApplicationJSONServerPublicNetServerPublicNetFirewallStatusEnumApplied GetServersID200ApplicationJSONServerPublicNetServerPublicNetFirewallStatusEnum = "applied"
	GetServersID200ApplicationJSONServerPublicNetServerPublicNetFirewallStatusEnumPending GetServersID200ApplicationJSONServerPublicNetServerPublicNetFirewallStatusEnum = "pending"
)

func (e GetServersID200ApplicationJSONServerPublicNetServerPublicNetFirewallStatusEnum) ToPointer() *GetServersID200ApplicationJSONServerPublicNetServerPublicNetFirewallStatusEnum {
	return &e
}

func (e *GetServersID200ApplicationJSONServerPublicNetServerPublicNetFirewallStatusEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "applied":
		fallthrough
	case "pending":
		*e = GetServersID200ApplicationJSONServerPublicNetServerPublicNetFirewallStatusEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetServersID200ApplicationJSONServerPublicNetServerPublicNetFirewallStatusEnum: %v", v)
	}
}

type GetServersID200ApplicationJSONServerPublicNetServerPublicNetFirewall struct {
	// ID of the Resource
	ID *int64 `json:"id,omitempty"`
	// Status of the Firewall on the Server
	Status *GetServersID200ApplicationJSONServerPublicNetServerPublicNetFirewallStatusEnum `json:"status,omitempty"`
}

// GetServersID200ApplicationJSONServerPublicNetIpv4 - IP address (v4) and its reverse DNS entry of this Server
type GetServersID200ApplicationJSONServerPublicNetIpv4 struct {
	// If the IP is blocked by our anti abuse dept
	Blocked bool `json:"blocked"`
	// Reverse DNS PTR entry for the IPv4 addresses of this Server
	DNSPtr string `json:"dns_ptr"`
	// ID of the Resource
	ID *int64 `json:"id,omitempty"`
	// IP address (v4) of this Server
	IP string `json:"ip"`
}

type GetServersID200ApplicationJSONServerPublicNetIpv6DNSPtr struct {
	// DNS pointer for the specific IP address
	DNSPtr string `json:"dns_ptr"`
	// Single IPv6 address of this Server for which the reverse DNS entry has been set up
	IP string `json:"ip"`
}

// GetServersID200ApplicationJSONServerPublicNetIpv6 - IPv6 network assigned to this Server and its reverse DNS entry
type GetServersID200ApplicationJSONServerPublicNetIpv6 struct {
	// If the IP is blocked by our anti abuse dept
	Blocked bool `json:"blocked"`
	// Reverse DNS PTR entries for the IPv6 addresses of this Server, `null` by default
	DNSPtr []GetServersID200ApplicationJSONServerPublicNetIpv6DNSPtr `json:"dns_ptr"`
	// ID of the Resource
	ID *int64 `json:"id,omitempty"`
	// IP address (v6) of this Server
	IP string `json:"ip"`
}

// GetServersID200ApplicationJSONServerPublicNet - Public network information. The Server's IPv4 address can be found in `public_net->ipv4->ip`
type GetServersID200ApplicationJSONServerPublicNet struct {
	// Firewalls applied to the public network interface of this Server
	Firewalls []GetServersID200ApplicationJSONServerPublicNetServerPublicNetFirewall `json:"firewalls,omitempty"`
	// IDs of Floating IPs assigned to this Server
	FloatingIps []int64 `json:"floating_ips"`
	// IP address (v4) and its reverse DNS entry of this Server
	Ipv4 GetServersID200ApplicationJSONServerPublicNetIpv4 `json:"ipv4"`
	// IPv6 network assigned to this Server and its reverse DNS entry
	Ipv6 GetServersID200ApplicationJSONServerPublicNetIpv6 `json:"ipv6"`
}

// GetServersID200ApplicationJSONServerServerTypeCPUTypeEnum - Type of cpu
type GetServersID200ApplicationJSONServerServerTypeCPUTypeEnum string

const (
	GetServersID200ApplicationJSONServerServerTypeCPUTypeEnumShared    GetServersID200ApplicationJSONServerServerTypeCPUTypeEnum = "shared"
	GetServersID200ApplicationJSONServerServerTypeCPUTypeEnumDedicated GetServersID200ApplicationJSONServerServerTypeCPUTypeEnum = "dedicated"
)

func (e GetServersID200ApplicationJSONServerServerTypeCPUTypeEnum) ToPointer() *GetServersID200ApplicationJSONServerServerTypeCPUTypeEnum {
	return &e
}

func (e *GetServersID200ApplicationJSONServerServerTypeCPUTypeEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "shared":
		fallthrough
	case "dedicated":
		*e = GetServersID200ApplicationJSONServerServerTypeCPUTypeEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetServersID200ApplicationJSONServerServerTypeCPUTypeEnum: %v", v)
	}
}

// GetServersID200ApplicationJSONServerServerTypePricesPriceHourly - Hourly costs for a Server type in this Location
type GetServersID200ApplicationJSONServerServerTypePricesPriceHourly struct {
	// Price with VAT added
	Gross string `json:"gross"`
	// Price without VAT
	Net string `json:"net"`
}

// GetServersID200ApplicationJSONServerServerTypePricesPriceMonthly - Monthly costs for a Server type in this Location
type GetServersID200ApplicationJSONServerServerTypePricesPriceMonthly struct {
	// Price with VAT added
	Gross string `json:"gross"`
	// Price without VAT
	Net string `json:"net"`
}

type GetServersID200ApplicationJSONServerServerTypePrices struct {
	// Name of the Location the price is for
	Location string `json:"location"`
	// Hourly costs for a Server type in this Location
	PriceHourly GetServersID200ApplicationJSONServerServerTypePricesPriceHourly `json:"price_hourly"`
	// Monthly costs for a Server type in this Location
	PriceMonthly GetServersID200ApplicationJSONServerServerTypePricesPriceMonthly `json:"price_monthly"`
}

// GetServersID200ApplicationJSONServerServerTypeStorageTypeEnum - Type of Server boot drive. Local has higher speed. Network has better availability.
type GetServersID200ApplicationJSONServerServerTypeStorageTypeEnum string

const (
	GetServersID200ApplicationJSONServerServerTypeStorageTypeEnumLocal   GetServersID200ApplicationJSONServerServerTypeStorageTypeEnum = "local"
	GetServersID200ApplicationJSONServerServerTypeStorageTypeEnumNetwork GetServersID200ApplicationJSONServerServerTypeStorageTypeEnum = "network"
)

func (e GetServersID200ApplicationJSONServerServerTypeStorageTypeEnum) ToPointer() *GetServersID200ApplicationJSONServerServerTypeStorageTypeEnum {
	return &e
}

func (e *GetServersID200ApplicationJSONServerServerTypeStorageTypeEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "local":
		fallthrough
	case "network":
		*e = GetServersID200ApplicationJSONServerServerTypeStorageTypeEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetServersID200ApplicationJSONServerServerTypeStorageTypeEnum: %v", v)
	}
}

// GetServersID200ApplicationJSONServerServerType - Type of Server - determines how much ram, disk and cpu a Server has
type GetServersID200ApplicationJSONServerServerType struct {
	// Number of cpu cores a Server of this type will have
	Cores float64 `json:"cores"`
	// Type of cpu
	CPUType GetServersID200ApplicationJSONServerServerTypeCPUTypeEnum `json:"cpu_type"`
	// True if Server type is deprecated
	Deprecated bool `json:"deprecated"`
	// Description of the Server type
	Description string `json:"description"`
	// Disk size a Server of this type will have in GB
	Disk float64 `json:"disk"`
	// ID of the Server type
	ID int64 `json:"id"`
	// Memory a Server of this type will have in GB
	Memory float64 `json:"memory"`
	// Unique identifier of the Server type
	Name string `json:"name"`
	// Prices in different Locations
	Prices []GetServersID200ApplicationJSONServerServerTypePrices `json:"prices"`
	// Type of Server boot drive. Local has higher speed. Network has better availability.
	StorageType GetServersID200ApplicationJSONServerServerTypeStorageTypeEnum `json:"storage_type"`
}

// GetServersID200ApplicationJSONServerStatusEnum - Status of the Server
type GetServersID200ApplicationJSONServerStatusEnum string

const (
	GetServersID200ApplicationJSONServerStatusEnumRunning      GetServersID200ApplicationJSONServerStatusEnum = "running"
	GetServersID200ApplicationJSONServerStatusEnumInitializing GetServersID200ApplicationJSONServerStatusEnum = "initializing"
	GetServersID200ApplicationJSONServerStatusEnumStarting     GetServersID200ApplicationJSONServerStatusEnum = "starting"
	GetServersID200ApplicationJSONServerStatusEnumStopping     GetServersID200ApplicationJSONServerStatusEnum = "stopping"
	GetServersID200ApplicationJSONServerStatusEnumOff          GetServersID200ApplicationJSONServerStatusEnum = "off"
	GetServersID200ApplicationJSONServerStatusEnumDeleting     GetServersID200ApplicationJSONServerStatusEnum = "deleting"
	GetServersID200ApplicationJSONServerStatusEnumMigrating    GetServersID200ApplicationJSONServerStatusEnum = "migrating"
	GetServersID200ApplicationJSONServerStatusEnumRebuilding   GetServersID200ApplicationJSONServerStatusEnum = "rebuilding"
	GetServersID200ApplicationJSONServerStatusEnumUnknown      GetServersID200ApplicationJSONServerStatusEnum = "unknown"
)

func (e GetServersID200ApplicationJSONServerStatusEnum) ToPointer() *GetServersID200ApplicationJSONServerStatusEnum {
	return &e
}

func (e *GetServersID200ApplicationJSONServerStatusEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "running":
		fallthrough
	case "initializing":
		fallthrough
	case "starting":
		fallthrough
	case "stopping":
		fallthrough
	case "off":
		fallthrough
	case "deleting":
		fallthrough
	case "migrating":
		fallthrough
	case "rebuilding":
		fallthrough
	case "unknown":
		*e = GetServersID200ApplicationJSONServerStatusEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetServersID200ApplicationJSONServerStatusEnum: %v", v)
	}
}

type GetServersID200ApplicationJSONServer struct {
	// Time window (UTC) in which the backup will run, or null if the backups are not enabled
	BackupWindow string `json:"backup_window"`
	// Point in time when the Resource was created (in ISO-8601 format)
	Created string `json:"created"`
	// Datacenter this Resource is located at
	Datacenter GetServersID200ApplicationJSONServerDatacenter `json:"datacenter"`
	// ID of the Resource
	ID    int64                                     `json:"id"`
	Image GetServersID200ApplicationJSONServerImage `json:"image"`
	// Free Traffic for the current billing period in bytes
	IncludedTraffic float64 `json:"included_traffic"`
	// Inbound Traffic for the current billing period in bytes
	IngoingTraffic float64 `json:"ingoing_traffic"`
	// ISO Image that is attached to this Server. Null if no ISO is attached.
	Iso GetServersID200ApplicationJSONServerIso `json:"iso"`
	// User-defined labels (key-value pairs)
	Labels        map[string]string `json:"labels"`
	LoadBalancers []int64           `json:"load_balancers,omitempty"`
	// True if Server has been locked and is not available to user
	Locked bool `json:"locked"`
	// Name of the Server (must be unique per Project and a valid hostname as per RFC 1123)
	Name string `json:"name"`
	// Outbound Traffic for the current billing period in bytes
	OutgoingTraffic float64                                                     `json:"outgoing_traffic"`
	PlacementGroup  *GetServersID200ApplicationJSONServerPlacementGroupNullable `json:"placement_group,omitempty"`
	// Size of the primary Disk
	PrimaryDiskSize float64 `json:"primary_disk_size"`
	// Private networks information
	PrivateNet []GetServersID200ApplicationJSONServerPrivateNet `json:"private_net"`
	// Protection configuration for the Server
	Protection GetServersID200ApplicationJSONServerProtection `json:"protection"`
	// Public network information. The Server's IPv4 address can be found in `public_net->ipv4->ip`
	PublicNet GetServersID200ApplicationJSONServerPublicNet `json:"public_net"`
	// True if rescue mode is enabled. Server will then boot into rescue system on next reboot
	RescueEnabled bool `json:"rescue_enabled"`
	// Type of Server - determines how much ram, disk and cpu a Server has
	ServerType GetServersID200ApplicationJSONServerServerType `json:"server_type"`
	// Status of the Server
	Status GetServersID200ApplicationJSONServerStatusEnum `json:"status"`
	// IDs of Volumes assigned to this Server
	Volumes []int64 `json:"volumes,omitempty"`
}

// GetServersID200ApplicationJSON - The `server` key in the reply contains a Server object with this structure
type GetServersID200ApplicationJSON struct {
	Server *GetServersID200ApplicationJSONServer `json:"server,omitempty"`
}

type GetServersIDResponse struct {
	ContentType string
	StatusCode  int
	RawResponse *http.Response
	// The `server` key in the reply contains a Server object with this structure
	GetServersID200ApplicationJSONObject *GetServersID200ApplicationJSON
}
