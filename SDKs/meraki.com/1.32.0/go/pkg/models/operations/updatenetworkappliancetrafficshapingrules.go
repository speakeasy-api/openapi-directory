// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"fmt"
	"net/http"
)

// UpdateNetworkApplianceTrafficShapingRulesRequestBodyRulesDefinitionsTypeEnum - The type of definition. Can be one of 'application', 'applicationCategory', 'host', 'port', 'ipRange' or 'localNet'.
type UpdateNetworkApplianceTrafficShapingRulesRequestBodyRulesDefinitionsTypeEnum string

const (
	UpdateNetworkApplianceTrafficShapingRulesRequestBodyRulesDefinitionsTypeEnumApplication         UpdateNetworkApplianceTrafficShapingRulesRequestBodyRulesDefinitionsTypeEnum = "application"
	UpdateNetworkApplianceTrafficShapingRulesRequestBodyRulesDefinitionsTypeEnumApplicationCategory UpdateNetworkApplianceTrafficShapingRulesRequestBodyRulesDefinitionsTypeEnum = "applicationCategory"
	UpdateNetworkApplianceTrafficShapingRulesRequestBodyRulesDefinitionsTypeEnumHost                UpdateNetworkApplianceTrafficShapingRulesRequestBodyRulesDefinitionsTypeEnum = "host"
	UpdateNetworkApplianceTrafficShapingRulesRequestBodyRulesDefinitionsTypeEnumIPRange             UpdateNetworkApplianceTrafficShapingRulesRequestBodyRulesDefinitionsTypeEnum = "ipRange"
	UpdateNetworkApplianceTrafficShapingRulesRequestBodyRulesDefinitionsTypeEnumLocalNet            UpdateNetworkApplianceTrafficShapingRulesRequestBodyRulesDefinitionsTypeEnum = "localNet"
	UpdateNetworkApplianceTrafficShapingRulesRequestBodyRulesDefinitionsTypeEnumPort                UpdateNetworkApplianceTrafficShapingRulesRequestBodyRulesDefinitionsTypeEnum = "port"
)

func (e UpdateNetworkApplianceTrafficShapingRulesRequestBodyRulesDefinitionsTypeEnum) ToPointer() *UpdateNetworkApplianceTrafficShapingRulesRequestBodyRulesDefinitionsTypeEnum {
	return &e
}

func (e *UpdateNetworkApplianceTrafficShapingRulesRequestBodyRulesDefinitionsTypeEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "application":
		fallthrough
	case "applicationCategory":
		fallthrough
	case "host":
		fallthrough
	case "ipRange":
		fallthrough
	case "localNet":
		fallthrough
	case "port":
		*e = UpdateNetworkApplianceTrafficShapingRulesRequestBodyRulesDefinitionsTypeEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for UpdateNetworkApplianceTrafficShapingRulesRequestBodyRulesDefinitionsTypeEnum: %v", v)
	}
}

type UpdateNetworkApplianceTrafficShapingRulesRequestBodyRulesDefinitions struct {
	// The type of definition. Can be one of 'application', 'applicationCategory', 'host', 'port', 'ipRange' or 'localNet'.
	Type UpdateNetworkApplianceTrafficShapingRulesRequestBodyRulesDefinitionsTypeEnum `json:"type"`
	//     If "type" is 'host', 'port', 'ipRange' or 'localNet', then "value" must be a string, matching either
	//     a hostname (e.g. "somesite.com"), a port (e.g. 8080), or an IP range ("192.1.0.0",
	//     "192.1.0.0/16", or "10.1.0.0/16:80"). 'localNet' also supports CIDR notation, excluding
	//     custom ports.
	//      If "type" is 'application' or 'applicationCategory', then "value" must be an object
	//     with the structure { "id": "meraki:layer7/..." }, where "id" is the application category or
	//     application ID (for a list of IDs for your network, use the trafficShaping/applicationCategories
	//     endpoint).
	//
	Value string `json:"value"`
}

// UpdateNetworkApplianceTrafficShapingRulesRequestBodyRulesPerClientBandwidthLimitsBandwidthLimits - The bandwidth limits object, specifying the upload ('limitUp') and download ('limitDown') speed in Kbps. These are only enforced if 'settings' is set to 'custom'.
type UpdateNetworkApplianceTrafficShapingRulesRequestBodyRulesPerClientBandwidthLimitsBandwidthLimits struct {
	// The maximum download limit (integer, in Kbps).
	LimitDown *int64 `json:"limitDown,omitempty"`
	// The maximum upload limit (integer, in Kbps).
	LimitUp *int64 `json:"limitUp,omitempty"`
}

// UpdateNetworkApplianceTrafficShapingRulesRequestBodyRulesPerClientBandwidthLimits -     An object describing the bandwidth settings for your rule.
type UpdateNetworkApplianceTrafficShapingRulesRequestBodyRulesPerClientBandwidthLimits struct {
	// The bandwidth limits object, specifying the upload ('limitUp') and download ('limitDown') speed in Kbps. These are only enforced if 'settings' is set to 'custom'.
	BandwidthLimits *UpdateNetworkApplianceTrafficShapingRulesRequestBodyRulesPerClientBandwidthLimitsBandwidthLimits `json:"bandwidthLimits,omitempty"`
	// How bandwidth limits are applied by your rule. Can be one of 'network default', 'ignore' or 'custom'.
	Settings *string `json:"settings,omitempty"`
}

type UpdateNetworkApplianceTrafficShapingRulesRequestBodyRules struct {
	//     A list of objects describing the definitions of your traffic shaping rule. At least one definition is required.
	//
	Definitions []UpdateNetworkApplianceTrafficShapingRulesRequestBodyRulesDefinitions `json:"definitions"`
	//     The DSCP tag applied by your rule. null means 'Do not change DSCP tag'.
	//     For a list of possible tag values, use the trafficShaping/dscpTaggingOptions endpoint.
	//
	DscpTagValue *int64 `json:"dscpTagValue,omitempty"`
	//     An object describing the bandwidth settings for your rule.
	//
	PerClientBandwidthLimits *UpdateNetworkApplianceTrafficShapingRulesRequestBodyRulesPerClientBandwidthLimits `json:"perClientBandwidthLimits,omitempty"`
	//     A string, indicating the priority level for packets bound to your rule.
	//     Can be 'low', 'normal' or 'high'.
	//
	Priority *string `json:"priority,omitempty"`
}

type UpdateNetworkApplianceTrafficShapingRulesRequestBody struct {
	// Whether default traffic shaping rules are enabled (true) or disabled (false). There are 4 default rules, which can be seen on your network's traffic shaping page. Note that default rules count against the rule limit of 8.
	DefaultRulesEnabled *bool `json:"defaultRulesEnabled,omitempty"`
	//     An array of traffic shaping rules. Rules are applied in the order that
	//     they are specified in. An empty list (or null) means no rules. Note that
	//     you are allowed a maximum of 8 rules.
	//
	Rules []UpdateNetworkApplianceTrafficShapingRulesRequestBodyRules `json:"rules,omitempty"`
}

type UpdateNetworkApplianceTrafficShapingRulesRequest struct {
	RequestBody *UpdateNetworkApplianceTrafficShapingRulesRequestBody `request:"mediaType=application/json"`
	NetworkID   string                                                `pathParam:"style=simple,explode=false,name=networkId"`
}

type UpdateNetworkApplianceTrafficShapingRulesResponse struct {
	ContentType string
	StatusCode  int
	RawResponse *http.Response
	// Successful operation
	UpdateNetworkApplianceTrafficShapingRules200ApplicationJSONObject map[string]interface{}
}
