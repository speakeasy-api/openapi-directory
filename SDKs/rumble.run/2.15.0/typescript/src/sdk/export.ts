/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * Requires Export Token or Organization Key
 */
export class Export {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Top asset hardware products as CSV
   */
  exportAssetTopHWCSV(
    config?: AxiosRequestConfig
  ): Promise<operations.ExportAssetTopHWCSVResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/org/assets/top.hw.csv";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExportAssetTopHWCSVResponse =
        new operations.ExportAssetTopHWCSVResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `text/csv`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.exportAssetTopHWCSV200TextCsvBinaryString = out;
          }
          break;
        case httpRes?.status == 401:
          break;
      }

      return res;
    });
  }

  /**
   * Top asset operating systems as CSV
   */
  exportAssetTopOSCSV(
    config?: AxiosRequestConfig
  ): Promise<operations.ExportAssetTopOSCSVResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/org/assets/top.os.csv";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExportAssetTopOSCSVResponse =
        new operations.ExportAssetTopOSCSVResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `text/csv`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.exportAssetTopOSCSV200TextCsvBinaryString = out;
          }
          break;
        case httpRes?.status == 401:
          break;
      }

      return res;
    });
  }

  /**
   * Top asset tags as CSV
   */
  exportAssetTopTagsCSV(
    config?: AxiosRequestConfig
  ): Promise<operations.ExportAssetTopTagsCSVResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/org/assets/top.tags.csv";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExportAssetTopTagsCSVResponse =
        new operations.ExportAssetTopTagsCSVResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `text/csv`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.exportAssetTopTagsCSV200TextCSVBinaryString = out;
          }
          break;
        case httpRes?.status == 401:
          break;
      }

      return res;
    });
  }

  /**
   * Top asset types as CSV
   */
  exportAssetTopTypesCSV(
    config?: AxiosRequestConfig
  ): Promise<operations.ExportAssetTopTypesCSVResponse> {
    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/org/assets/top.types.csv";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExportAssetTopTypesCSVResponse =
        new operations.ExportAssetTopTypesCSVResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `text/csv`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.exportAssetTopTypesCSV200TextCSVBinaryString = out;
          }
          break;
        case httpRes?.status == 401:
          break;
      }

      return res;
    });
  }

  /**
   * Asset inventory as CSV
   */
  exportAssetsCSV(
    req: operations.ExportAssetsCSVRequest,
    security: operations.ExportAssetsCSVSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ExportAssetsCSVResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ExportAssetsCSVRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/export/org/assets.csv";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ExportAssetsCSVSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExportAssetsCSVResponse =
        new operations.ExportAssetsCSVResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `text/csv`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.exportAssetsCSV200TextCSVBinaryString = out;
          }
          break;
        case httpRes?.status == 401:
          break;
      }

      return res;
    });
  }

  /**
   * Exports the asset inventory
   */
  exportAssetsJSON(
    req: operations.ExportAssetsJSONRequest,
    security: operations.ExportAssetsJSONSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ExportAssetsJSONResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ExportAssetsJSONRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/export/org/assets.json";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ExportAssetsJSONSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExportAssetsJSONResponse =
        new operations.ExportAssetsJSONResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.assets = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.assets = utils.objectToClass(
              httpRes?.data,
              shared.Asset,
              resFieldDepth
            );
          }
          break;
        case httpRes?.status == 401:
          break;
      }

      return res;
    });
  }

  /**
   * Asset inventory as JSON line-delimited
   */
  exportAssetsJSONL(
    req: operations.ExportAssetsJSONLRequest,
    security: operations.ExportAssetsJSONLSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ExportAssetsJSONLResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ExportAssetsJSONLRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/export/org/assets.jsonl";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ExportAssetsJSONLSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExportAssetsJSONLResponse =
        new operations.ExportAssetsJSONLResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.exportAssetsJSONL200ApplicationJSONBinaryString = out;
          }
          break;
        case httpRes?.status == 401:
          break;
      }

      return res;
    });
  }

  /**
   * Asset inventory as Nmap-style XML
   */
  exportAssetsNmapXML(
    req: operations.ExportAssetsNmapXMLRequest,
    security: operations.ExportAssetsNmapXMLSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ExportAssetsNmapXMLResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ExportAssetsNmapXMLRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/export/org/assets.nmap.xml";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ExportAssetsNmapXMLSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExportAssetsNmapXMLResponse =
        new operations.ExportAssetsNmapXMLResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `text/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.exportAssetsNmapXML200TextXMLBinaryString = out;
          }
          break;
        case httpRes?.status == 401:
          break;
      }

      return res;
    });
  }

  /**
   * Service inventory as CSV
   */
  exportServicesCSV(
    req: operations.ExportServicesCSVRequest,
    security: operations.ExportServicesCSVSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ExportServicesCSVResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ExportServicesCSVRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/export/org/services.csv";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ExportServicesCSVSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExportServicesCSVResponse =
        new operations.ExportServicesCSVResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `text/csv`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.exportServicesCSV200TextCSVBinaryString = out;
          }
          break;
        case httpRes?.status == 401:
          break;
      }

      return res;
    });
  }

  /**
   * Service inventory as JSON
   */
  exportServicesJSON(
    req: operations.ExportServicesJSONRequest,
    security: operations.ExportServicesJSONSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ExportServicesJSONResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ExportServicesJSONRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/export/org/services.json";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ExportServicesJSONSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExportServicesJSONResponse =
        new operations.ExportServicesJSONResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.services = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.services = utils.objectToClass(
              httpRes?.data,
              shared.Service,
              resFieldDepth
            );
          }
          break;
        case httpRes?.status == 401:
          break;
      }

      return res;
    });
  }

  /**
   * Service inventory as JSON line-delimited
   */
  exportServicesJSONL(
    req: operations.ExportServicesJSONLRequest,
    security: operations.ExportServicesJSONLSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ExportServicesJSONLResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ExportServicesJSONLRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/export/org/services.jsonl";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ExportServicesJSONLSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExportServicesJSONLResponse =
        new operations.ExportServicesJSONLResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.exportServicesJSONL200ApplicationJSONBinaryString = out;
          }
          break;
        case httpRes?.status == 401:
          break;
      }

      return res;
    });
  }

  /**
   * Top service products as CSV
   */
  exportServicesTopProductsCSV(
    config?: AxiosRequestConfig
  ): Promise<operations.ExportServicesTopProductsCSVResponse> {
    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/org/services/top.products.csv";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExportServicesTopProductsCSVResponse =
        new operations.ExportServicesTopProductsCSVResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `text/csv`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.exportServicesTopProductsCSV200TextCSVBinaryString = out;
          }
          break;
        case httpRes?.status == 401:
          break;
      }

      return res;
    });
  }

  /**
   * Top service protocols as CSV
   */
  exportServicesTopProtocolsCSV(
    config?: AxiosRequestConfig
  ): Promise<operations.ExportServicesTopProtocolsCSVResponse> {
    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/org/services/top.protocols.csv";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExportServicesTopProtocolsCSVResponse =
        new operations.ExportServicesTopProtocolsCSVResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `text/csv`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.exportServicesTopProtocolsCSV200TextCSVBinaryString = out;
          }
          break;
        case httpRes?.status == 401:
          break;
      }

      return res;
    });
  }

  /**
   * Top TCP services as CSV
   */
  exportServicesTopTCPCSV(
    config?: AxiosRequestConfig
  ): Promise<operations.ExportServicesTopTCPCSVResponse> {
    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/org/services/top.tcp.csv";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExportServicesTopTCPCSVResponse =
        new operations.ExportServicesTopTCPCSVResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `text/csv`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.exportServicesTopTCPCSV200TextCsvBinaryString = out;
          }
          break;
        case httpRes?.status == 401:
          break;
      }

      return res;
    });
  }

  /**
   * Top UDP services as CSV
   */
  exportServicesTopUDPCSV(
    config?: AxiosRequestConfig
  ): Promise<operations.ExportServicesTopUDPCSVResponse> {
    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/org/services/top.udp.csv";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExportServicesTopUDPCSVResponse =
        new operations.ExportServicesTopUDPCSVResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `text/csv`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.exportServicesTopUDPCSV200TextCsvBinaryString = out;
          }
          break;
        case httpRes?.status == 401:
          break;
      }

      return res;
    });
  }

  /**
   * Site list as CSV
   */
  exportSitesCSV(
    config?: AxiosRequestConfig
  ): Promise<operations.ExportSitesCSVResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/export/org/sites.csv";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExportSitesCSVResponse =
        new operations.ExportSitesCSVResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `text/csv`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.exportSitesCSV200TextCSVBinaryString = out;
          }
          break;
        case httpRes?.status == 401:
          break;
      }

      return res;
    });
  }

  /**
   * Export all sites
   */
  exportSitesJSON(
    req: operations.ExportSitesJSONRequest,
    security: operations.ExportSitesJSONSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ExportSitesJSONResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ExportSitesJSONRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/export/org/sites.json";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ExportSitesJSONSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExportSitesJSONResponse =
        new operations.ExportSitesJSONResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.sites = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.sites = utils.objectToClass(
              httpRes?.data,
              shared.Site,
              resFieldDepth
            );
          }
          break;
        case httpRes?.status == 401:
          break;
      }

      return res;
    });
  }

  /**
   * Site list as JSON line-delimited
   */
  exportSitesJSONL(
    req: operations.ExportSitesJSONLRequest,
    security: operations.ExportSitesJSONLSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ExportSitesJSONLResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ExportSitesJSONLRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/export/org/sites.jsonl";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ExportSitesJSONLSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExportSitesJSONLResponse =
        new operations.ExportSitesJSONLResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.exportSitesJSONL200ApplicationJSONBinaryString = out;
          }
          break;
        case httpRes?.status == 401:
          break;
      }

      return res;
    });
  }

  /**
   * Subnet utilization statistics as as CSV
   */
  exportSubnetUtilizationStatsCSV(
    req: operations.ExportSubnetUtilizationStatsCSVRequest,
    security: operations.ExportSubnetUtilizationStatsCSVSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ExportSubnetUtilizationStatsCSVResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ExportSubnetUtilizationStatsCSVRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/org/services/subnet.stats.csv";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ExportSubnetUtilizationStatsCSVSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExportSubnetUtilizationStatsCSVResponse =
        new operations.ExportSubnetUtilizationStatsCSVResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `text/csv`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.exportSubnetUtilizationStatsCSV200TextCSVBinaryString = out;
          }
          break;
        case httpRes?.status == 401:
          break;
      }

      return res;
    });
  }

  /**
   * Wireless inventory as CSV
   */
  exportWirelessCSV(
    req: operations.ExportWirelessCSVRequest,
    security: operations.ExportWirelessCSVSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ExportWirelessCSVResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ExportWirelessCSVRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/export/org/wireless.csv";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ExportWirelessCSVSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExportWirelessCSVResponse =
        new operations.ExportWirelessCSVResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `text/csv`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.exportWirelessCSV200TextCSVBinaryString = out;
          }
          break;
        case httpRes?.status == 401:
          break;
      }

      return res;
    });
  }

  /**
   * Wireless inventory as JSON
   */
  exportWirelessJSON(
    req: operations.ExportWirelessJSONRequest,
    security: operations.ExportWirelessJSONSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ExportWirelessJSONResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ExportWirelessJSONRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/export/org/wireless.json";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ExportWirelessJSONSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExportWirelessJSONResponse =
        new operations.ExportWirelessJSONResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.wirelesses = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.wirelesses = utils.objectToClass(
              httpRes?.data,
              shared.Wireless,
              resFieldDepth
            );
          }
          break;
        case httpRes?.status == 401:
          break;
      }

      return res;
    });
  }

  /**
   * Wireless inventory as JSON line-delimited
   */
  exportWirelessJSONL(
    req: operations.ExportWirelessJSONLRequest,
    security: operations.ExportWirelessJSONLSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ExportWirelessJSONLResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ExportWirelessJSONLRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/export/org/wireless.jsonl";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ExportWirelessJSONLSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExportWirelessJSONLResponse =
        new operations.ExportWirelessJSONLResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.exportWirelessJSONL200ApplicationJSONBinaryString = out;
          }
          break;
        case httpRes?.status == 401:
          break;
      }

      return res;
    });
  }
}
