"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Optional

class Collection:
    r"""Collections let you organize your content in a Flat account. They work like a regular _folder_ with some specificities:
      - Our design goal here is to create a system similar to a _book_ or a _playlist of songs_.
      - Collections can't have children collections (except the `trash` and `sharedWithMe` that are special collections).
      - Any score can be added to one or multiple collections. For example, you can have a single private score in two or more collections, or add any public or shared scores to one of your collections.
    
    All the collections don't have the same capabilities. Capabilities depend on the `type` of collection and the `rights` you have on a collection. They are available when [listing the collection](#operation/listCollections) or [retrieving the collection details](#operation/getCollection).
    
    At this time, only `private` privacy mode is widely available. Privacy modes `public`, `organizationPublic` and `privateLink`, and 1:1 sharing will be available in an upcoming update later this year.
    """
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def add_score_to_collection(self, request: operations.AddScoreToCollectionRequest, security: operations.AddScoreToCollectionSecurity) -> operations.AddScoreToCollectionResponse:
        r"""Add a score to the collection
        This operation will add a score to a collection. The default behavior will make the score available across multiple collections.
        You must have the capability `canAddScores` on the provided `collection` to perform the action.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.AddScoreToCollectionRequest, base_url, '/collections/{collection}/scores/{score}', request)
        
        query_params = utils.get_query_params(operations.AddScoreToCollectionRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PUT', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AddScoreToCollectionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ScoreDetails])
                res.score_details = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FlatErrorResponse])
                res.flat_error_response = out

        return res

    def create_collection(self, request: shared.CollectionCreation, security: operations.CreateCollectionSecurity) -> operations.CreateCollectionResponse:
        r"""Create a new collection
        This method will create a new collection and add it to your `root` collection.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/collections'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateCollectionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Collection])
                res.collection = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FlatErrorResponse])
                res.flat_error_response = out

        return res

    def delete_collection(self, request: operations.DeleteCollectionRequest, security: operations.DeleteCollectionSecurity) -> operations.DeleteCollectionResponse:
        r"""Delete the collection
        This method will schedule the deletion of the collection. Until deleted, the collection will be available in the `trash`.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteCollectionRequest, base_url, '/collections/{collection}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteCollectionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FlatErrorResponse])
                res.flat_error_response = out

        return res

    def delete_score_from_collection(self, request: operations.DeleteScoreFromCollectionRequest, security: operations.DeleteScoreFromCollectionSecurity) -> operations.DeleteScoreFromCollectionResponse:
        r"""Delete a score from the collection
        This method will delete a score from the collection. Unlike [`DELETE /scores/{score}`](#operation/deleteScore), this score will not remove the score from your account, but only from the collection.
        This can be used to *move* a score from one collection to another, or simply remove a score from one collection when this one is contained in multiple collections.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteScoreFromCollectionRequest, base_url, '/collections/{collection}/scores/{score}', request)
        
        query_params = utils.get_query_params(operations.DeleteScoreFromCollectionRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteScoreFromCollectionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FlatErrorResponse])
                res.flat_error_response = out

        return res

    def edit_collection(self, request: operations.EditCollectionRequest, security: operations.EditCollectionSecurity) -> operations.EditCollectionResponse:
        r"""Update a collection's metadata"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.EditCollectionRequest, base_url, '/collections/{collection}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "collection_modification", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.EditCollectionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Collection])
                res.collection = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FlatErrorResponse])
                res.flat_error_response = out

        return res

    def get_collection(self, request: operations.GetCollectionRequest, security: operations.GetCollectionSecurity) -> operations.GetCollectionResponse:
        r"""Get collection details"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetCollectionRequest, base_url, '/collections/{collection}', request)
        
        query_params = utils.get_query_params(operations.GetCollectionRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetCollectionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Collection])
                res.collection = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FlatErrorResponse])
                res.flat_error_response = out

        return res

    def list_collection_scores(self, request: operations.ListCollectionScoresRequest, security: operations.ListCollectionScoresSecurity) -> operations.ListCollectionScoresResponse:
        r"""List the scores contained in a collection
        Use this method to list the scores contained in a collection.
        If no sort option is provided, the scores are sorted by `modificationDate` `desc`.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.ListCollectionScoresRequest, base_url, '/collections/{collection}/scores', request)
        
        query_params = utils.get_query_params(operations.ListCollectionScoresRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListCollectionScoresResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.ScoreDetails]])
                res.score_details = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FlatErrorResponse])
                res.flat_error_response = out

        return res

    def list_collections(self, request: operations.ListCollectionsRequest, security: operations.ListCollectionsSecurity) -> operations.ListCollectionsResponse:
        r"""List the collections
        Use this method to list the user's collections contained in `parent` (by default in the `root` collection).
        If no sort option is provided, the collections are sorted by `creationDate` `desc`.
        
        Note that this method will not include the `parent` collection in the listing.
        For example, if you need the details of the `root` collection, you can use `GET /v2/collections/root`.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/collections'
        
        query_params = utils.get_query_params(operations.ListCollectionsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListCollectionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.Collection]])
                res.collections = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FlatErrorResponse])
                res.flat_error_response = out

        return res

    def untrash_collection(self, request: operations.UntrashCollectionRequest, security: operations.UntrashCollectionSecurity) -> operations.UntrashCollectionResponse:
        r"""Untrash a collection
        This method will restore the collection by removing it from the `trash` and add it back to the `root` collection.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.UntrashCollectionRequest, base_url, '/collections/{collection}/untrash', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UntrashCollectionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FlatErrorResponse])
                res.flat_error_response = out

        return res

    