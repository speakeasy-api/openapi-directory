"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Optional

SERVERS = [
    "https://api.twilio.com",
]
"""Contains the list of servers available to the SDK"""

class SDK:
    r"""This is the public Twilio REST API."""

    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str = SERVERS[0]
    _language: str = "python"
    _sdk_version: str = "0.0.1"
    _gen_version: str = "internal"

    def __init__(self,
                 server_url: str = None,
                 url_params: dict[str, str] = None,
                 client: requests_http.Session = None
                 ) -> None:
        """Instantiates the SDK configuring it with the provided parameters.
        
        :param server_url: The server URL to use for all operations
        :type server_url: str
        :param url_params: Parameters to optionally template the server URL with
        :type url_params: dict[str, str]
        :param client: The requests.Session HTTP client to use for all operations
        :type client: requests_http.Session        
        """
        self._client = requests_http.Session()
        
        
        if server_url is not None:
            if url_params is not None:
                self._server_url = utils.template_url(server_url, url_params)
            else:
                self._server_url = server_url

        if client is not None:
            self._client = client
        
        self._security_client = self._client
        

        
    
    
    def create_account(self, request: operations.CreateAccountCreateAccountRequest, security: operations.CreateAccountSecurity, server_url: Optional[str] = None) -> operations.CreateAccountResponse:
        r"""Create a new Twilio Subaccount from the account making the request"""
        base_url = operations.CREATE_ACCOUNT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/2010-04-01/Accounts.json'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateAccountResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010Account])
                res.api_v2010_account = out

        return res

    def create_address(self, request: operations.CreateAddressRequest, security: operations.CreateAddressSecurity, server_url: Optional[str] = None) -> operations.CreateAddressResponse:
        base_url = operations.CREATE_ADDRESS_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateAddressRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Addresses.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateAddressResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountAddress])
                res.api_v2010_account_address = out

        return res

    def create_application(self, request: operations.CreateApplicationRequest, security: operations.CreateApplicationSecurity, server_url: Optional[str] = None) -> operations.CreateApplicationResponse:
        r"""Create a new application within your account"""
        base_url = operations.CREATE_APPLICATION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateApplicationRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Applications.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateApplicationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountApplication])
                res.api_v2010_account_application = out

        return res

    def create_call(self, request: operations.CreateCallRequest, security: operations.CreateCallSecurity, server_url: Optional[str] = None) -> operations.CreateCallResponse:
        r"""Create a new outgoing call to phones, SIP-enabled endpoints or Twilio Client connections"""
        base_url = operations.CREATE_CALL_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateCallRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Calls.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateCallResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountCall])
                res.api_v2010_account_call = out

        return res

    def create_call_feedback_summary(self, request: operations.CreateCallFeedbackSummaryRequest, security: operations.CreateCallFeedbackSummarySecurity, server_url: Optional[str] = None) -> operations.CreateCallFeedbackSummaryResponse:
        r"""Create a FeedbackSummary resource for a call"""
        base_url = operations.CREATE_CALL_FEEDBACK_SUMMARY_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateCallFeedbackSummaryRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Calls/FeedbackSummary.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateCallFeedbackSummaryResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountCallCallFeedbackSummary])
                res.api_v2010_account_call_call_feedback_summary = out

        return res

    def create_call_recording(self, request: operations.CreateCallRecordingRequest, security: operations.CreateCallRecordingSecurity, server_url: Optional[str] = None) -> operations.CreateCallRecordingResponse:
        r"""Create a recording for the call"""
        base_url = operations.CREATE_CALL_RECORDING_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateCallRecordingRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Recordings.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateCallRecordingResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountCallCallRecording])
                res.api_v2010_account_call_call_recording = out

        return res

    def create_incoming_phone_number(self, request: operations.CreateIncomingPhoneNumberRequest, security: operations.CreateIncomingPhoneNumberSecurity, server_url: Optional[str] = None) -> operations.CreateIncomingPhoneNumberResponse:
        r"""Purchase a phone-number for the account."""
        base_url = operations.CREATE_INCOMING_PHONE_NUMBER_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateIncomingPhoneNumberRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateIncomingPhoneNumberResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountIncomingPhoneNumber])
                res.api_v2010_account_incoming_phone_number = out

        return res

    def create_incoming_phone_number_assigned_add_on(self, request: operations.CreateIncomingPhoneNumberAssignedAddOnRequest, security: operations.CreateIncomingPhoneNumberAssignedAddOnSecurity, server_url: Optional[str] = None) -> operations.CreateIncomingPhoneNumberAssignedAddOnResponse:
        r"""Assign an Add-on installation to the Number specified."""
        base_url = operations.CREATE_INCOMING_PHONE_NUMBER_ASSIGNED_ADD_ON_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateIncomingPhoneNumberAssignedAddOnRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{ResourceSid}/AssignedAddOns.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateIncomingPhoneNumberAssignedAddOnResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountIncomingPhoneNumberIncomingPhoneNumberAssignedAddOn])
                res.api_v2010_account_incoming_phone_number_incoming_phone_number_assigned_add_on = out

        return res

    def create_incoming_phone_number_local(self, request: operations.CreateIncomingPhoneNumberLocalRequest, security: operations.CreateIncomingPhoneNumberLocalSecurity, server_url: Optional[str] = None) -> operations.CreateIncomingPhoneNumberLocalResponse:
        base_url = operations.CREATE_INCOMING_PHONE_NUMBER_LOCAL_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateIncomingPhoneNumberLocalRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/Local.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateIncomingPhoneNumberLocalResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountIncomingPhoneNumberIncomingPhoneNumberLocal])
                res.api_v2010_account_incoming_phone_number_incoming_phone_number_local = out

        return res

    def create_incoming_phone_number_mobile(self, request: operations.CreateIncomingPhoneNumberMobileRequest, security: operations.CreateIncomingPhoneNumberMobileSecurity, server_url: Optional[str] = None) -> operations.CreateIncomingPhoneNumberMobileResponse:
        base_url = operations.CREATE_INCOMING_PHONE_NUMBER_MOBILE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateIncomingPhoneNumberMobileRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/Mobile.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateIncomingPhoneNumberMobileResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountIncomingPhoneNumberIncomingPhoneNumberMobile])
                res.api_v2010_account_incoming_phone_number_incoming_phone_number_mobile = out

        return res

    def create_incoming_phone_number_toll_free(self, request: operations.CreateIncomingPhoneNumberTollFreeRequest, security: operations.CreateIncomingPhoneNumberTollFreeSecurity, server_url: Optional[str] = None) -> operations.CreateIncomingPhoneNumberTollFreeResponse:
        base_url = operations.CREATE_INCOMING_PHONE_NUMBER_TOLL_FREE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateIncomingPhoneNumberTollFreeRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/TollFree.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateIncomingPhoneNumberTollFreeResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountIncomingPhoneNumberIncomingPhoneNumberTollFree])
                res.api_v2010_account_incoming_phone_number_incoming_phone_number_toll_free = out

        return res

    def create_message(self, request: operations.CreateMessageRequest, security: operations.CreateMessageSecurity, server_url: Optional[str] = None) -> operations.CreateMessageResponse:
        r"""Send a message from the account used to make the request"""
        base_url = operations.CREATE_MESSAGE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateMessageRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Messages.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateMessageResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountMessage])
                res.api_v2010_account_message = out

        return res

    def create_message_feedback(self, request: operations.CreateMessageFeedbackRequest, security: operations.CreateMessageFeedbackSecurity, server_url: Optional[str] = None) -> operations.CreateMessageFeedbackResponse:
        base_url = operations.CREATE_MESSAGE_FEEDBACK_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateMessageFeedbackRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Messages/{MessageSid}/Feedback.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateMessageFeedbackResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountMessageMessageFeedback])
                res.api_v2010_account_message_message_feedback = out

        return res

    def create_new_key(self, request: operations.CreateNewKeyRequest, security: operations.CreateNewKeySecurity, server_url: Optional[str] = None) -> operations.CreateNewKeyResponse:
        base_url = operations.CREATE_NEW_KEY_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateNewKeyRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Keys.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateNewKeyResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountNewKey])
                res.api_v2010_account_new_key = out

        return res

    def create_new_signing_key(self, request: operations.CreateNewSigningKeyRequest, security: operations.CreateNewSigningKeySecurity, server_url: Optional[str] = None) -> operations.CreateNewSigningKeyResponse:
        r"""Create a new Signing Key for the account making the request."""
        base_url = operations.CREATE_NEW_SIGNING_KEY_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateNewSigningKeyRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/SigningKeys.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateNewSigningKeyResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountNewSigningKey])
                res.api_v2010_account_new_signing_key = out

        return res

    def create_participant(self, request: operations.CreateParticipantRequest, security: operations.CreateParticipantSecurity, server_url: Optional[str] = None) -> operations.CreateParticipantResponse:
        base_url = operations.CREATE_PARTICIPANT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateParticipantRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Participants.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateParticipantResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountConferenceParticipant])
                res.api_v2010_account_conference_participant = out

        return res

    def create_payments(self, request: operations.CreatePaymentsRequest, security: operations.CreatePaymentsSecurity, server_url: Optional[str] = None) -> operations.CreatePaymentsResponse:
        r"""create an instance of payments. This will start a new payments session"""
        base_url = operations.CREATE_PAYMENTS_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreatePaymentsRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Payments.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreatePaymentsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountCallPayments])
                res.api_v2010_account_call_payments = out

        return res

    def create_queue(self, request: operations.CreateQueueRequest, security: operations.CreateQueueSecurity, server_url: Optional[str] = None) -> operations.CreateQueueResponse:
        r"""Create a queue"""
        base_url = operations.CREATE_QUEUE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateQueueRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Queues.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateQueueResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountQueue])
                res.api_v2010_account_queue = out

        return res

    def create_sip_auth_calls_credential_list_mapping(self, request: operations.CreateSipAuthCallsCredentialListMappingRequest, security: operations.CreateSipAuthCallsCredentialListMappingSecurity, server_url: Optional[str] = None) -> operations.CreateSipAuthCallsCredentialListMappingResponse:
        r"""Create a new credential list mapping resource"""
        base_url = operations.CREATE_SIP_AUTH_CALLS_CREDENTIAL_LIST_MAPPING_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateSipAuthCallsCredentialListMappingRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Calls/CredentialListMappings.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateSipAuthCallsCredentialListMappingResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsCredentialListMapping])
                res.api_v2010_account_sip_sip_domain_sip_auth_sip_auth_calls_sip_auth_calls_credential_list_mapping = out

        return res

    def create_sip_auth_calls_ip_access_control_list_mapping(self, request: operations.CreateSipAuthCallsIPAccessControlListMappingRequest, security: operations.CreateSipAuthCallsIPAccessControlListMappingSecurity, server_url: Optional[str] = None) -> operations.CreateSipAuthCallsIPAccessControlListMappingResponse:
        r"""Create a new IP Access Control List mapping"""
        base_url = operations.CREATE_SIP_AUTH_CALLS_IP_ACCESS_CONTROL_LIST_MAPPING_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateSipAuthCallsIPAccessControlListMappingRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Calls/IpAccessControlListMappings.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateSipAuthCallsIPAccessControlListMappingResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsIPAccessControlListMapping])
                res.api_v2010_account_sip_sip_domain_sip_auth_sip_auth_calls_sip_auth_calls_ip_access_control_list_mapping = out

        return res

    def create_sip_auth_registrations_credential_list_mapping(self, request: operations.CreateSipAuthRegistrationsCredentialListMappingRequest, security: operations.CreateSipAuthRegistrationsCredentialListMappingSecurity, server_url: Optional[str] = None) -> operations.CreateSipAuthRegistrationsCredentialListMappingResponse:
        r"""Create a new credential list mapping resource"""
        base_url = operations.CREATE_SIP_AUTH_REGISTRATIONS_CREDENTIAL_LIST_MAPPING_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateSipAuthRegistrationsCredentialListMappingRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Registrations/CredentialListMappings.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateSipAuthRegistrationsCredentialListMappingResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountSipSipDomainSipAuthSipAuthRegistrationsSipAuthRegistrationsCredentialListMapping])
                res.api_v2010_account_sip_sip_domain_sip_auth_sip_auth_registrations_sip_auth_registrations_credential_list_mapping = out

        return res

    def create_sip_credential(self, request: operations.CreateSipCredentialRequest, security: operations.CreateSipCredentialSecurity, server_url: Optional[str] = None) -> operations.CreateSipCredentialResponse:
        r"""Create a new credential resource."""
        base_url = operations.CREATE_SIP_CREDENTIAL_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateSipCredentialRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists/{CredentialListSid}/Credentials.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateSipCredentialResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountSipSipCredentialListSipCredential])
                res.api_v2010_account_sip_sip_credential_list_sip_credential = out

        return res

    def create_sip_credential_list(self, request: operations.CreateSipCredentialListRequest, security: operations.CreateSipCredentialListSecurity, server_url: Optional[str] = None) -> operations.CreateSipCredentialListResponse:
        r"""Create a Credential List"""
        base_url = operations.CREATE_SIP_CREDENTIAL_LIST_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateSipCredentialListRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateSipCredentialListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountSipSipCredentialList])
                res.api_v2010_account_sip_sip_credential_list = out

        return res

    def create_sip_credential_list_mapping(self, request: operations.CreateSipCredentialListMappingRequest, security: operations.CreateSipCredentialListMappingSecurity, server_url: Optional[str] = None) -> operations.CreateSipCredentialListMappingResponse:
        r"""Create a CredentialListMapping resource for an account."""
        base_url = operations.CREATE_SIP_CREDENTIAL_LIST_MAPPING_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateSipCredentialListMappingRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/CredentialListMappings.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateSipCredentialListMappingResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountSipSipDomainSipCredentialListMapping])
                res.api_v2010_account_sip_sip_domain_sip_credential_list_mapping = out

        return res

    def create_sip_domain(self, request: operations.CreateSipDomainRequest, security: operations.CreateSipDomainSecurity, server_url: Optional[str] = None) -> operations.CreateSipDomainResponse:
        r"""Create a new Domain"""
        base_url = operations.CREATE_SIP_DOMAIN_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateSipDomainRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/SIP/Domains.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateSipDomainResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountSipSipDomain])
                res.api_v2010_account_sip_sip_domain = out

        return res

    def create_sip_ip_access_control_list(self, request: operations.CreateSipIPAccessControlListRequest, security: operations.CreateSipIPAccessControlListSecurity, server_url: Optional[str] = None) -> operations.CreateSipIPAccessControlListResponse:
        r"""Create a new IpAccessControlList resource"""
        base_url = operations.CREATE_SIP_IP_ACCESS_CONTROL_LIST_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateSipIPAccessControlListRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateSipIPAccessControlListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountSipSipIPAccessControlList])
                res.api_v2010_account_sip_sip_ip_access_control_list = out

        return res

    def create_sip_ip_access_control_list_mapping(self, request: operations.CreateSipIPAccessControlListMappingRequest, security: operations.CreateSipIPAccessControlListMappingSecurity, server_url: Optional[str] = None) -> operations.CreateSipIPAccessControlListMappingResponse:
        r"""Create a new IpAccessControlListMapping resource."""
        base_url = operations.CREATE_SIP_IP_ACCESS_CONTROL_LIST_MAPPING_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateSipIPAccessControlListMappingRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/IpAccessControlListMappings.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateSipIPAccessControlListMappingResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountSipSipDomainSipIPAccessControlListMapping])
                res.api_v2010_account_sip_sip_domain_sip_ip_access_control_list_mapping = out

        return res

    def create_sip_ip_address(self, request: operations.CreateSipIPAddressRequest, security: operations.CreateSipIPAddressSecurity, server_url: Optional[str] = None) -> operations.CreateSipIPAddressResponse:
        r"""Create a new IpAddress resource."""
        base_url = operations.CREATE_SIP_IP_ADDRESS_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateSipIPAddressRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists/{IpAccessControlListSid}/IpAddresses.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateSipIPAddressResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountSipSipIPAccessControlListSipIPAddress])
                res.api_v2010_account_sip_sip_ip_access_control_list_sip_ip_address = out

        return res

    def create_siprec(self, request: operations.CreateSiprecRequest, security: operations.CreateSiprecSecurity, server_url: Optional[str] = None) -> operations.CreateSiprecResponse:
        r"""Create a Siprec"""
        base_url = operations.CREATE_SIPREC_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateSiprecRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Siprec.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateSiprecResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountCallSiprec])
                res.api_v2010_account_call_siprec = out

        return res

    def create_stream(self, request: operations.CreateStreamRequest, security: operations.CreateStreamSecurity, server_url: Optional[str] = None) -> operations.CreateStreamResponse:
        r"""Create a Stream"""
        base_url = operations.CREATE_STREAM_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateStreamRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Streams.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateStreamResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountCallStream])
                res.api_v2010_account_call_stream = out

        return res

    def create_token(self, request: operations.CreateTokenRequest, security: operations.CreateTokenSecurity, server_url: Optional[str] = None) -> operations.CreateTokenResponse:
        r"""Create a new token for ICE servers"""
        base_url = operations.CREATE_TOKEN_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateTokenRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Tokens.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateTokenResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountToken])
                res.api_v2010_account_token = out

        return res

    def create_usage_trigger(self, request: operations.CreateUsageTriggerRequest, security: operations.CreateUsageTriggerSecurity, server_url: Optional[str] = None) -> operations.CreateUsageTriggerResponse:
        r"""Create a new UsageTrigger"""
        base_url = operations.CREATE_USAGE_TRIGGER_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateUsageTriggerRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Usage/Triggers.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateUsageTriggerResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountUsageUsageTrigger])
                res.api_v2010_account_usage_usage_trigger = out

        return res

    def create_user_defined_message(self, request: operations.CreateUserDefinedMessageRequest, security: operations.CreateUserDefinedMessageSecurity, server_url: Optional[str] = None) -> operations.CreateUserDefinedMessageResponse:
        r"""Create a new User Defined Message for the given Call SID."""
        base_url = operations.CREATE_USER_DEFINED_MESSAGE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateUserDefinedMessageRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/UserDefinedMessages.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateUserDefinedMessageResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountCallUserDefinedMessage])
                res.api_v2010_account_call_user_defined_message = out

        return res

    def create_user_defined_message_subscription(self, request: operations.CreateUserDefinedMessageSubscriptionRequest, security: operations.CreateUserDefinedMessageSubscriptionSecurity, server_url: Optional[str] = None) -> operations.CreateUserDefinedMessageSubscriptionResponse:
        r"""Subscribe to User Defined Messages for a given Call SID."""
        base_url = operations.CREATE_USER_DEFINED_MESSAGE_SUBSCRIPTION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateUserDefinedMessageSubscriptionRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/UserDefinedMessageSubscriptions.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateUserDefinedMessageSubscriptionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountCallUserDefinedMessageSubscription])
                res.api_v2010_account_call_user_defined_message_subscription = out

        return res

    def create_validation_request(self, request: operations.CreateValidationRequestRequest, security: operations.CreateValidationRequestSecurity, server_url: Optional[str] = None) -> operations.CreateValidationRequestResponse:
        base_url = operations.CREATE_VALIDATION_REQUEST_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateValidationRequestRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/OutgoingCallerIds.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateValidationRequestResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountValidationRequest])
                res.api_v2010_account_validation_request = out

        return res

    def delete_address(self, request: operations.DeleteAddressRequest, security: operations.DeleteAddressSecurity, server_url: Optional[str] = None) -> operations.DeleteAddressResponse:
        base_url = operations.DELETE_ADDRESS_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteAddressRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Addresses/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteAddressResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_application(self, request: operations.DeleteApplicationRequest, security: operations.DeleteApplicationSecurity, server_url: Optional[str] = None) -> operations.DeleteApplicationResponse:
        r"""Delete the application by the specified application sid"""
        base_url = operations.DELETE_APPLICATION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteApplicationRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Applications/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteApplicationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_call(self, request: operations.DeleteCallRequest, security: operations.DeleteCallSecurity, server_url: Optional[str] = None) -> operations.DeleteCallResponse:
        r"""Delete a Call record from your account. Once the record is deleted, it will no longer appear in the API and Account Portal logs."""
        base_url = operations.DELETE_CALL_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteCallRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Calls/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteCallResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_call_feedback_summary(self, request: operations.DeleteCallFeedbackSummaryRequest, security: operations.DeleteCallFeedbackSummarySecurity, server_url: Optional[str] = None) -> operations.DeleteCallFeedbackSummaryResponse:
        r"""Delete a FeedbackSummary resource from a call"""
        base_url = operations.DELETE_CALL_FEEDBACK_SUMMARY_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteCallFeedbackSummaryRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Calls/FeedbackSummary/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteCallFeedbackSummaryResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_call_recording(self, request: operations.DeleteCallRecordingRequest, security: operations.DeleteCallRecordingSecurity, server_url: Optional[str] = None) -> operations.DeleteCallRecordingResponse:
        r"""Delete a recording from your account"""
        base_url = operations.DELETE_CALL_RECORDING_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteCallRecordingRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Recordings/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteCallRecordingResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_conference_recording(self, request: operations.DeleteConferenceRecordingRequest, security: operations.DeleteConferenceRecordingSecurity, server_url: Optional[str] = None) -> operations.DeleteConferenceRecordingResponse:
        r"""Delete a recording from your account"""
        base_url = operations.DELETE_CONFERENCE_RECORDING_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteConferenceRecordingRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Recordings/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteConferenceRecordingResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_connect_app(self, request: operations.DeleteConnectAppRequest, security: operations.DeleteConnectAppSecurity, server_url: Optional[str] = None) -> operations.DeleteConnectAppResponse:
        r"""Delete an instance of a connect-app"""
        base_url = operations.DELETE_CONNECT_APP_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteConnectAppRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/ConnectApps/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteConnectAppResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_incoming_phone_number(self, request: operations.DeleteIncomingPhoneNumberRequest, security: operations.DeleteIncomingPhoneNumberSecurity, server_url: Optional[str] = None) -> operations.DeleteIncomingPhoneNumberResponse:
        r"""Delete a phone-numbers belonging to the account used to make the request."""
        base_url = operations.DELETE_INCOMING_PHONE_NUMBER_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteIncomingPhoneNumberRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteIncomingPhoneNumberResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_incoming_phone_number_assigned_add_on(self, request: operations.DeleteIncomingPhoneNumberAssignedAddOnRequest, security: operations.DeleteIncomingPhoneNumberAssignedAddOnSecurity, server_url: Optional[str] = None) -> operations.DeleteIncomingPhoneNumberAssignedAddOnResponse:
        r"""Remove the assignment of an Add-on installation from the Number specified."""
        base_url = operations.DELETE_INCOMING_PHONE_NUMBER_ASSIGNED_ADD_ON_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteIncomingPhoneNumberAssignedAddOnRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{ResourceSid}/AssignedAddOns/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteIncomingPhoneNumberAssignedAddOnResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_key(self, request: operations.DeleteKeyRequest, security: operations.DeleteKeySecurity, server_url: Optional[str] = None) -> operations.DeleteKeyResponse:
        base_url = operations.DELETE_KEY_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteKeyRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Keys/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteKeyResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_media(self, request: operations.DeleteMediaRequest, security: operations.DeleteMediaSecurity, server_url: Optional[str] = None) -> operations.DeleteMediaResponse:
        r"""Delete media from your account. Once delete, you will no longer be billed"""
        base_url = operations.DELETE_MEDIA_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteMediaRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Messages/{MessageSid}/Media/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteMediaResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_message(self, request: operations.DeleteMessageRequest, security: operations.DeleteMessageSecurity, server_url: Optional[str] = None) -> operations.DeleteMessageResponse:
        r"""Deletes a message record from your account"""
        base_url = operations.DELETE_MESSAGE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteMessageRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Messages/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteMessageResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_outgoing_caller_id(self, request: operations.DeleteOutgoingCallerIDRequest, security: operations.DeleteOutgoingCallerIDSecurity, server_url: Optional[str] = None) -> operations.DeleteOutgoingCallerIDResponse:
        r"""Delete the caller-id specified from the account"""
        base_url = operations.DELETE_OUTGOING_CALLER_ID_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteOutgoingCallerIDRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/OutgoingCallerIds/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteOutgoingCallerIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_participant(self, request: operations.DeleteParticipantRequest, security: operations.DeleteParticipantSecurity, server_url: Optional[str] = None) -> operations.DeleteParticipantResponse:
        r"""Kick a participant from a given conference"""
        base_url = operations.DELETE_PARTICIPANT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteParticipantRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Participants/{CallSid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteParticipantResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_queue(self, request: operations.DeleteQueueRequest, security: operations.DeleteQueueSecurity, server_url: Optional[str] = None) -> operations.DeleteQueueResponse:
        r"""Remove an empty queue"""
        base_url = operations.DELETE_QUEUE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteQueueRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Queues/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteQueueResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_recording(self, request: operations.DeleteRecordingRequest, security: operations.DeleteRecordingSecurity, server_url: Optional[str] = None) -> operations.DeleteRecordingResponse:
        r"""Delete a recording from your account"""
        base_url = operations.DELETE_RECORDING_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteRecordingRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Recordings/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteRecordingResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_recording_add_on_result(self, request: operations.DeleteRecordingAddOnResultRequest, security: operations.DeleteRecordingAddOnResultSecurity, server_url: Optional[str] = None) -> operations.DeleteRecordingAddOnResultResponse:
        r"""Delete a result and purge all associated Payloads"""
        base_url = operations.DELETE_RECORDING_ADD_ON_RESULT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteRecordingAddOnResultRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Recordings/{ReferenceSid}/AddOnResults/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteRecordingAddOnResultResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_recording_add_on_result_payload(self, request: operations.DeleteRecordingAddOnResultPayloadRequest, security: operations.DeleteRecordingAddOnResultPayloadSecurity, server_url: Optional[str] = None) -> operations.DeleteRecordingAddOnResultPayloadResponse:
        r"""Delete a payload from the result along with all associated Data"""
        base_url = operations.DELETE_RECORDING_ADD_ON_RESULT_PAYLOAD_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteRecordingAddOnResultPayloadRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Recordings/{ReferenceSid}/AddOnResults/{AddOnResultSid}/Payloads/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteRecordingAddOnResultPayloadResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_recording_transcription(self, request: operations.DeleteRecordingTranscriptionRequest, security: operations.DeleteRecordingTranscriptionSecurity, server_url: Optional[str] = None) -> operations.DeleteRecordingTranscriptionResponse:
        base_url = operations.DELETE_RECORDING_TRANSCRIPTION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteRecordingTranscriptionRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Recordings/{RecordingSid}/Transcriptions/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteRecordingTranscriptionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_signing_key(self, request: operations.DeleteSigningKeyRequest, security: operations.DeleteSigningKeySecurity, server_url: Optional[str] = None) -> operations.DeleteSigningKeyResponse:
        base_url = operations.DELETE_SIGNING_KEY_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteSigningKeyRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/SigningKeys/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteSigningKeyResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_sip_auth_calls_credential_list_mapping(self, request: operations.DeleteSipAuthCallsCredentialListMappingRequest, security: operations.DeleteSipAuthCallsCredentialListMappingSecurity, server_url: Optional[str] = None) -> operations.DeleteSipAuthCallsCredentialListMappingResponse:
        r"""Delete a credential list mapping from the requested domain"""
        base_url = operations.DELETE_SIP_AUTH_CALLS_CREDENTIAL_LIST_MAPPING_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteSipAuthCallsCredentialListMappingRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Calls/CredentialListMappings/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteSipAuthCallsCredentialListMappingResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_sip_auth_calls_ip_access_control_list_mapping(self, request: operations.DeleteSipAuthCallsIPAccessControlListMappingRequest, security: operations.DeleteSipAuthCallsIPAccessControlListMappingSecurity, server_url: Optional[str] = None) -> operations.DeleteSipAuthCallsIPAccessControlListMappingResponse:
        r"""Delete an IP Access Control List mapping from the requested domain"""
        base_url = operations.DELETE_SIP_AUTH_CALLS_IP_ACCESS_CONTROL_LIST_MAPPING_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteSipAuthCallsIPAccessControlListMappingRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Calls/IpAccessControlListMappings/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteSipAuthCallsIPAccessControlListMappingResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_sip_auth_registrations_credential_list_mapping(self, request: operations.DeleteSipAuthRegistrationsCredentialListMappingRequest, security: operations.DeleteSipAuthRegistrationsCredentialListMappingSecurity, server_url: Optional[str] = None) -> operations.DeleteSipAuthRegistrationsCredentialListMappingResponse:
        r"""Delete a credential list mapping from the requested domain"""
        base_url = operations.DELETE_SIP_AUTH_REGISTRATIONS_CREDENTIAL_LIST_MAPPING_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteSipAuthRegistrationsCredentialListMappingRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Registrations/CredentialListMappings/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteSipAuthRegistrationsCredentialListMappingResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_sip_credential(self, request: operations.DeleteSipCredentialRequest, security: operations.DeleteSipCredentialSecurity, server_url: Optional[str] = None) -> operations.DeleteSipCredentialResponse:
        r"""Delete a credential resource."""
        base_url = operations.DELETE_SIP_CREDENTIAL_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteSipCredentialRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists/{CredentialListSid}/Credentials/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteSipCredentialResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_sip_credential_list(self, request: operations.DeleteSipCredentialListRequest, security: operations.DeleteSipCredentialListSecurity, server_url: Optional[str] = None) -> operations.DeleteSipCredentialListResponse:
        r"""Delete a Credential List"""
        base_url = operations.DELETE_SIP_CREDENTIAL_LIST_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteSipCredentialListRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteSipCredentialListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_sip_credential_list_mapping(self, request: operations.DeleteSipCredentialListMappingRequest, security: operations.DeleteSipCredentialListMappingSecurity, server_url: Optional[str] = None) -> operations.DeleteSipCredentialListMappingResponse:
        r"""Delete a CredentialListMapping resource from an account."""
        base_url = operations.DELETE_SIP_CREDENTIAL_LIST_MAPPING_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteSipCredentialListMappingRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/CredentialListMappings/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteSipCredentialListMappingResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_sip_domain(self, request: operations.DeleteSipDomainRequest, security: operations.DeleteSipDomainSecurity, server_url: Optional[str] = None) -> operations.DeleteSipDomainResponse:
        r"""Delete an instance of a Domain"""
        base_url = operations.DELETE_SIP_DOMAIN_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteSipDomainRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteSipDomainResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_sip_ip_access_control_list(self, request: operations.DeleteSipIPAccessControlListRequest, security: operations.DeleteSipIPAccessControlListSecurity, server_url: Optional[str] = None) -> operations.DeleteSipIPAccessControlListResponse:
        r"""Delete an IpAccessControlList from the requested account"""
        base_url = operations.DELETE_SIP_IP_ACCESS_CONTROL_LIST_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteSipIPAccessControlListRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteSipIPAccessControlListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_sip_ip_access_control_list_mapping(self, request: operations.DeleteSipIPAccessControlListMappingRequest, security: operations.DeleteSipIPAccessControlListMappingSecurity, server_url: Optional[str] = None) -> operations.DeleteSipIPAccessControlListMappingResponse:
        r"""Delete an IpAccessControlListMapping resource."""
        base_url = operations.DELETE_SIP_IP_ACCESS_CONTROL_LIST_MAPPING_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteSipIPAccessControlListMappingRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/IpAccessControlListMappings/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteSipIPAccessControlListMappingResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_sip_ip_address(self, request: operations.DeleteSipIPAddressRequest, security: operations.DeleteSipIPAddressSecurity, server_url: Optional[str] = None) -> operations.DeleteSipIPAddressResponse:
        r"""Delete an IpAddress resource."""
        base_url = operations.DELETE_SIP_IP_ADDRESS_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteSipIPAddressRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists/{IpAccessControlListSid}/IpAddresses/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteSipIPAddressResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_transcription(self, request: operations.DeleteTranscriptionRequest, security: operations.DeleteTranscriptionSecurity, server_url: Optional[str] = None) -> operations.DeleteTranscriptionResponse:
        r"""Delete a transcription from the account used to make the request"""
        base_url = operations.DELETE_TRANSCRIPTION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteTranscriptionRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Transcriptions/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteTranscriptionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_usage_trigger(self, request: operations.DeleteUsageTriggerRequest, security: operations.DeleteUsageTriggerSecurity, server_url: Optional[str] = None) -> operations.DeleteUsageTriggerResponse:
        base_url = operations.DELETE_USAGE_TRIGGER_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteUsageTriggerRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Usage/Triggers/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteUsageTriggerResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_user_defined_message_subscription(self, request: operations.DeleteUserDefinedMessageSubscriptionRequest, security: operations.DeleteUserDefinedMessageSubscriptionSecurity, server_url: Optional[str] = None) -> operations.DeleteUserDefinedMessageSubscriptionResponse:
        r"""Delete a specific User Defined Message Subscription."""
        base_url = operations.DELETE_USER_DEFINED_MESSAGE_SUBSCRIPTION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteUserDefinedMessageSubscriptionRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/UserDefinedMessageSubscriptions/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteUserDefinedMessageSubscriptionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def fetch_account(self, request: operations.FetchAccountRequest, security: operations.FetchAccountSecurity, server_url: Optional[str] = None) -> operations.FetchAccountResponse:
        r"""Fetch the account specified by the provided Account Sid"""
        base_url = operations.FETCH_ACCOUNT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchAccountRequest, base_url, '/2010-04-01/Accounts/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchAccountResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010Account])
                res.api_v2010_account = out

        return res

    def fetch_address(self, request: operations.FetchAddressRequest, security: operations.FetchAddressSecurity, server_url: Optional[str] = None) -> operations.FetchAddressResponse:
        base_url = operations.FETCH_ADDRESS_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchAddressRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Addresses/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchAddressResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountAddress])
                res.api_v2010_account_address = out

        return res

    def fetch_application(self, request: operations.FetchApplicationRequest, security: operations.FetchApplicationSecurity, server_url: Optional[str] = None) -> operations.FetchApplicationResponse:
        r"""Fetch the application specified by the provided sid"""
        base_url = operations.FETCH_APPLICATION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchApplicationRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Applications/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchApplicationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountApplication])
                res.api_v2010_account_application = out

        return res

    def fetch_authorized_connect_app(self, request: operations.FetchAuthorizedConnectAppRequest, security: operations.FetchAuthorizedConnectAppSecurity, server_url: Optional[str] = None) -> operations.FetchAuthorizedConnectAppResponse:
        r"""Fetch an instance of an authorized-connect-app"""
        base_url = operations.FETCH_AUTHORIZED_CONNECT_APP_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchAuthorizedConnectAppRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/AuthorizedConnectApps/{ConnectAppSid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchAuthorizedConnectAppResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountAuthorizedConnectApp])
                res.api_v2010_account_authorized_connect_app = out

        return res

    def fetch_available_phone_number_country(self, request: operations.FetchAvailablePhoneNumberCountryRequest, security: operations.FetchAvailablePhoneNumberCountrySecurity, server_url: Optional[str] = None) -> operations.FetchAvailablePhoneNumberCountryResponse:
        base_url = operations.FETCH_AVAILABLE_PHONE_NUMBER_COUNTRY_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchAvailablePhoneNumberCountryRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers/{CountryCode}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchAvailablePhoneNumberCountryResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountAvailablePhoneNumberCountry])
                res.api_v2010_account_available_phone_number_country = out

        return res

    def fetch_balance(self, request: operations.FetchBalanceRequest, security: operations.FetchBalanceSecurity, server_url: Optional[str] = None) -> operations.FetchBalanceResponse:
        r"""Fetch the balance for an Account based on Account Sid. Balance changes may not be reflected immediately. Child accounts do not contain balance information"""
        base_url = operations.FETCH_BALANCE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchBalanceRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Balance.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchBalanceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountBalance])
                res.api_v2010_account_balance = out

        return res

    def fetch_call(self, request: operations.FetchCallRequest, security: operations.FetchCallSecurity, server_url: Optional[str] = None) -> operations.FetchCallResponse:
        r"""Fetch the call specified by the provided Call SID"""
        base_url = operations.FETCH_CALL_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchCallRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Calls/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchCallResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountCall])
                res.api_v2010_account_call = out

        return res

    def fetch_call_feedback(self, request: operations.FetchCallFeedbackRequest, security: operations.FetchCallFeedbackSecurity, server_url: Optional[str] = None) -> operations.FetchCallFeedbackResponse:
        r"""Fetch a Feedback resource from a call"""
        base_url = operations.FETCH_CALL_FEEDBACK_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchCallFeedbackRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Feedback.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchCallFeedbackResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountCallCallFeedback])
                res.api_v2010_account_call_call_feedback = out

        return res

    def fetch_call_feedback_summary(self, request: operations.FetchCallFeedbackSummaryRequest, security: operations.FetchCallFeedbackSummarySecurity, server_url: Optional[str] = None) -> operations.FetchCallFeedbackSummaryResponse:
        r"""Fetch a FeedbackSummary resource from a call"""
        base_url = operations.FETCH_CALL_FEEDBACK_SUMMARY_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchCallFeedbackSummaryRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Calls/FeedbackSummary/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchCallFeedbackSummaryResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountCallCallFeedbackSummary])
                res.api_v2010_account_call_call_feedback_summary = out

        return res

    def fetch_call_notification(self, request: operations.FetchCallNotificationRequest, security: operations.FetchCallNotificationSecurity, server_url: Optional[str] = None) -> operations.FetchCallNotificationResponse:
        base_url = operations.FETCH_CALL_NOTIFICATION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchCallNotificationRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Notifications/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchCallNotificationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountCallCallNotificationInstance])
                res.api_v2010_account_call_call_notification_instance = out

        return res

    def fetch_call_recording(self, request: operations.FetchCallRecordingRequest, security: operations.FetchCallRecordingSecurity, server_url: Optional[str] = None) -> operations.FetchCallRecordingResponse:
        r"""Fetch an instance of a recording for a call"""
        base_url = operations.FETCH_CALL_RECORDING_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchCallRecordingRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Recordings/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchCallRecordingResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountCallCallRecording])
                res.api_v2010_account_call_call_recording = out

        return res

    def fetch_conference(self, request: operations.FetchConferenceRequest, security: operations.FetchConferenceSecurity, server_url: Optional[str] = None) -> operations.FetchConferenceResponse:
        r"""Fetch an instance of a conference"""
        base_url = operations.FETCH_CONFERENCE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchConferenceRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Conferences/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchConferenceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountConference])
                res.api_v2010_account_conference = out

        return res

    def fetch_conference_recording(self, request: operations.FetchConferenceRecordingRequest, security: operations.FetchConferenceRecordingSecurity, server_url: Optional[str] = None) -> operations.FetchConferenceRecordingResponse:
        r"""Fetch an instance of a recording for a call"""
        base_url = operations.FETCH_CONFERENCE_RECORDING_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchConferenceRecordingRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Recordings/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchConferenceRecordingResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountConferenceConferenceRecording])
                res.api_v2010_account_conference_conference_recording = out

        return res

    def fetch_connect_app(self, request: operations.FetchConnectAppRequest, security: operations.FetchConnectAppSecurity, server_url: Optional[str] = None) -> operations.FetchConnectAppResponse:
        r"""Fetch an instance of a connect-app"""
        base_url = operations.FETCH_CONNECT_APP_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchConnectAppRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/ConnectApps/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchConnectAppResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountConnectApp])
                res.api_v2010_account_connect_app = out

        return res

    def fetch_incoming_phone_number(self, request: operations.FetchIncomingPhoneNumberRequest, security: operations.FetchIncomingPhoneNumberSecurity, server_url: Optional[str] = None) -> operations.FetchIncomingPhoneNumberResponse:
        r"""Fetch an incoming-phone-number belonging to the account used to make the request."""
        base_url = operations.FETCH_INCOMING_PHONE_NUMBER_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchIncomingPhoneNumberRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchIncomingPhoneNumberResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountIncomingPhoneNumber])
                res.api_v2010_account_incoming_phone_number = out

        return res

    def fetch_incoming_phone_number_assigned_add_on(self, request: operations.FetchIncomingPhoneNumberAssignedAddOnRequest, security: operations.FetchIncomingPhoneNumberAssignedAddOnSecurity, server_url: Optional[str] = None) -> operations.FetchIncomingPhoneNumberAssignedAddOnResponse:
        r"""Fetch an instance of an Add-on installation currently assigned to this Number."""
        base_url = operations.FETCH_INCOMING_PHONE_NUMBER_ASSIGNED_ADD_ON_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchIncomingPhoneNumberAssignedAddOnRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{ResourceSid}/AssignedAddOns/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchIncomingPhoneNumberAssignedAddOnResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountIncomingPhoneNumberIncomingPhoneNumberAssignedAddOn])
                res.api_v2010_account_incoming_phone_number_incoming_phone_number_assigned_add_on = out

        return res

    def fetch_incoming_phone_number_assigned_add_on_extension(self, request: operations.FetchIncomingPhoneNumberAssignedAddOnExtensionRequest, security: operations.FetchIncomingPhoneNumberAssignedAddOnExtensionSecurity, server_url: Optional[str] = None) -> operations.FetchIncomingPhoneNumberAssignedAddOnExtensionResponse:
        r"""Fetch an instance of an Extension for the Assigned Add-on."""
        base_url = operations.FETCH_INCOMING_PHONE_NUMBER_ASSIGNED_ADD_ON_EXTENSION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchIncomingPhoneNumberAssignedAddOnExtensionRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{ResourceSid}/AssignedAddOns/{AssignedAddOnSid}/Extensions/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchIncomingPhoneNumberAssignedAddOnExtensionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountIncomingPhoneNumberIncomingPhoneNumberAssignedAddOnIncomingPhoneNumberAssignedAddOnExtension])
                res.api_v2010_account_incoming_phone_number_incoming_phone_number_assigned_add_on_incoming_phone_number_assigned_add_on_extension = out

        return res

    def fetch_key(self, request: operations.FetchKeyRequest, security: operations.FetchKeySecurity, server_url: Optional[str] = None) -> operations.FetchKeyResponse:
        base_url = operations.FETCH_KEY_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchKeyRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Keys/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchKeyResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountKey])
                res.api_v2010_account_key = out

        return res

    def fetch_media(self, request: operations.FetchMediaRequest, security: operations.FetchMediaSecurity, server_url: Optional[str] = None) -> operations.FetchMediaResponse:
        r"""Fetch a single media instance belonging to the account used to make the request"""
        base_url = operations.FETCH_MEDIA_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchMediaRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Messages/{MessageSid}/Media/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchMediaResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountMessageMedia])
                res.api_v2010_account_message_media = out

        return res

    def fetch_member(self, request: operations.FetchMemberRequest, security: operations.FetchMemberSecurity, server_url: Optional[str] = None) -> operations.FetchMemberResponse:
        r"""Fetch a specific member from the queue"""
        base_url = operations.FETCH_MEMBER_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchMemberRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Queues/{QueueSid}/Members/{CallSid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchMemberResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountQueueMember])
                res.api_v2010_account_queue_member = out

        return res

    def fetch_message(self, request: operations.FetchMessageRequest, security: operations.FetchMessageSecurity, server_url: Optional[str] = None) -> operations.FetchMessageResponse:
        r"""Fetch a message belonging to the account used to make the request"""
        base_url = operations.FETCH_MESSAGE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchMessageRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Messages/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchMessageResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountMessage])
                res.api_v2010_account_message = out

        return res

    def fetch_notification(self, request: operations.FetchNotificationRequest, security: operations.FetchNotificationSecurity, server_url: Optional[str] = None) -> operations.FetchNotificationResponse:
        r"""Fetch a notification belonging to the account used to make the request"""
        base_url = operations.FETCH_NOTIFICATION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchNotificationRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Notifications/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchNotificationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountNotificationInstance])
                res.api_v2010_account_notification_instance = out

        return res

    def fetch_outgoing_caller_id(self, request: operations.FetchOutgoingCallerIDRequest, security: operations.FetchOutgoingCallerIDSecurity, server_url: Optional[str] = None) -> operations.FetchOutgoingCallerIDResponse:
        r"""Fetch an outgoing-caller-id belonging to the account used to make the request"""
        base_url = operations.FETCH_OUTGOING_CALLER_ID_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchOutgoingCallerIDRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/OutgoingCallerIds/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchOutgoingCallerIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountOutgoingCallerID])
                res.api_v2010_account_outgoing_caller_id = out

        return res

    def fetch_participant(self, request: operations.FetchParticipantRequest, security: operations.FetchParticipantSecurity, server_url: Optional[str] = None) -> operations.FetchParticipantResponse:
        r"""Fetch an instance of a participant"""
        base_url = operations.FETCH_PARTICIPANT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchParticipantRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Participants/{CallSid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchParticipantResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountConferenceParticipant])
                res.api_v2010_account_conference_participant = out

        return res

    def fetch_queue(self, request: operations.FetchQueueRequest, security: operations.FetchQueueSecurity, server_url: Optional[str] = None) -> operations.FetchQueueResponse:
        r"""Fetch an instance of a queue identified by the QueueSid"""
        base_url = operations.FETCH_QUEUE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchQueueRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Queues/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchQueueResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountQueue])
                res.api_v2010_account_queue = out

        return res

    def fetch_recording(self, request: operations.FetchRecordingRequest, security: operations.FetchRecordingSecurity, server_url: Optional[str] = None) -> operations.FetchRecordingResponse:
        r"""Fetch an instance of a recording"""
        base_url = operations.FETCH_RECORDING_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchRecordingRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Recordings/{Sid}.json', request)
        
        query_params = utils.get_query_params(operations.FetchRecordingRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchRecordingResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountRecording])
                res.api_v2010_account_recording = out

        return res

    def fetch_recording_add_on_result(self, request: operations.FetchRecordingAddOnResultRequest, security: operations.FetchRecordingAddOnResultSecurity, server_url: Optional[str] = None) -> operations.FetchRecordingAddOnResultResponse:
        r"""Fetch an instance of an AddOnResult"""
        base_url = operations.FETCH_RECORDING_ADD_ON_RESULT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchRecordingAddOnResultRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Recordings/{ReferenceSid}/AddOnResults/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchRecordingAddOnResultResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountRecordingRecordingAddOnResult])
                res.api_v2010_account_recording_recording_add_on_result = out

        return res

    def fetch_recording_add_on_result_payload(self, request: operations.FetchRecordingAddOnResultPayloadRequest, security: operations.FetchRecordingAddOnResultPayloadSecurity, server_url: Optional[str] = None) -> operations.FetchRecordingAddOnResultPayloadResponse:
        r"""Fetch an instance of a result payload"""
        base_url = operations.FETCH_RECORDING_ADD_ON_RESULT_PAYLOAD_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchRecordingAddOnResultPayloadRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Recordings/{ReferenceSid}/AddOnResults/{AddOnResultSid}/Payloads/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchRecordingAddOnResultPayloadResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountRecordingRecordingAddOnResultRecordingAddOnResultPayload])
                res.api_v2010_account_recording_recording_add_on_result_recording_add_on_result_payload = out

        return res

    def fetch_recording_transcription(self, request: operations.FetchRecordingTranscriptionRequest, security: operations.FetchRecordingTranscriptionSecurity, server_url: Optional[str] = None) -> operations.FetchRecordingTranscriptionResponse:
        base_url = operations.FETCH_RECORDING_TRANSCRIPTION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchRecordingTranscriptionRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Recordings/{RecordingSid}/Transcriptions/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchRecordingTranscriptionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountRecordingRecordingTranscription])
                res.api_v2010_account_recording_recording_transcription = out

        return res

    def fetch_short_code(self, request: operations.FetchShortCodeRequest, security: operations.FetchShortCodeSecurity, server_url: Optional[str] = None) -> operations.FetchShortCodeResponse:
        r"""Fetch an instance of a short code"""
        base_url = operations.FETCH_SHORT_CODE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchShortCodeRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/SMS/ShortCodes/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchShortCodeResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountShortCode])
                res.api_v2010_account_short_code = out

        return res

    def fetch_signing_key(self, request: operations.FetchSigningKeyRequest, security: operations.FetchSigningKeySecurity, server_url: Optional[str] = None) -> operations.FetchSigningKeyResponse:
        base_url = operations.FETCH_SIGNING_KEY_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchSigningKeyRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/SigningKeys/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchSigningKeyResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountSigningKey])
                res.api_v2010_account_signing_key = out

        return res

    def fetch_sip_auth_calls_credential_list_mapping(self, request: operations.FetchSipAuthCallsCredentialListMappingRequest, security: operations.FetchSipAuthCallsCredentialListMappingSecurity, server_url: Optional[str] = None) -> operations.FetchSipAuthCallsCredentialListMappingResponse:
        r"""Fetch a specific instance of a credential list mapping"""
        base_url = operations.FETCH_SIP_AUTH_CALLS_CREDENTIAL_LIST_MAPPING_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchSipAuthCallsCredentialListMappingRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Calls/CredentialListMappings/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchSipAuthCallsCredentialListMappingResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsCredentialListMapping])
                res.api_v2010_account_sip_sip_domain_sip_auth_sip_auth_calls_sip_auth_calls_credential_list_mapping = out

        return res

    def fetch_sip_auth_calls_ip_access_control_list_mapping(self, request: operations.FetchSipAuthCallsIPAccessControlListMappingRequest, security: operations.FetchSipAuthCallsIPAccessControlListMappingSecurity, server_url: Optional[str] = None) -> operations.FetchSipAuthCallsIPAccessControlListMappingResponse:
        r"""Fetch a specific instance of an IP Access Control List mapping"""
        base_url = operations.FETCH_SIP_AUTH_CALLS_IP_ACCESS_CONTROL_LIST_MAPPING_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchSipAuthCallsIPAccessControlListMappingRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Calls/IpAccessControlListMappings/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchSipAuthCallsIPAccessControlListMappingResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsIPAccessControlListMapping])
                res.api_v2010_account_sip_sip_domain_sip_auth_sip_auth_calls_sip_auth_calls_ip_access_control_list_mapping = out

        return res

    def fetch_sip_auth_registrations_credential_list_mapping(self, request: operations.FetchSipAuthRegistrationsCredentialListMappingRequest, security: operations.FetchSipAuthRegistrationsCredentialListMappingSecurity, server_url: Optional[str] = None) -> operations.FetchSipAuthRegistrationsCredentialListMappingResponse:
        r"""Fetch a specific instance of a credential list mapping"""
        base_url = operations.FETCH_SIP_AUTH_REGISTRATIONS_CREDENTIAL_LIST_MAPPING_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchSipAuthRegistrationsCredentialListMappingRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Registrations/CredentialListMappings/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchSipAuthRegistrationsCredentialListMappingResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountSipSipDomainSipAuthSipAuthRegistrationsSipAuthRegistrationsCredentialListMapping])
                res.api_v2010_account_sip_sip_domain_sip_auth_sip_auth_registrations_sip_auth_registrations_credential_list_mapping = out

        return res

    def fetch_sip_credential(self, request: operations.FetchSipCredentialRequest, security: operations.FetchSipCredentialSecurity, server_url: Optional[str] = None) -> operations.FetchSipCredentialResponse:
        r"""Fetch a single credential."""
        base_url = operations.FETCH_SIP_CREDENTIAL_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchSipCredentialRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists/{CredentialListSid}/Credentials/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchSipCredentialResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountSipSipCredentialListSipCredential])
                res.api_v2010_account_sip_sip_credential_list_sip_credential = out

        return res

    def fetch_sip_credential_list(self, request: operations.FetchSipCredentialListRequest, security: operations.FetchSipCredentialListSecurity, server_url: Optional[str] = None) -> operations.FetchSipCredentialListResponse:
        r"""Get a Credential List"""
        base_url = operations.FETCH_SIP_CREDENTIAL_LIST_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchSipCredentialListRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchSipCredentialListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountSipSipCredentialList])
                res.api_v2010_account_sip_sip_credential_list = out

        return res

    def fetch_sip_credential_list_mapping(self, request: operations.FetchSipCredentialListMappingRequest, security: operations.FetchSipCredentialListMappingSecurity, server_url: Optional[str] = None) -> operations.FetchSipCredentialListMappingResponse:
        r"""Fetch a single CredentialListMapping resource from an account."""
        base_url = operations.FETCH_SIP_CREDENTIAL_LIST_MAPPING_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchSipCredentialListMappingRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/CredentialListMappings/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchSipCredentialListMappingResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountSipSipDomainSipCredentialListMapping])
                res.api_v2010_account_sip_sip_domain_sip_credential_list_mapping = out

        return res

    def fetch_sip_domain(self, request: operations.FetchSipDomainRequest, security: operations.FetchSipDomainSecurity, server_url: Optional[str] = None) -> operations.FetchSipDomainResponse:
        r"""Fetch an instance of a Domain"""
        base_url = operations.FETCH_SIP_DOMAIN_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchSipDomainRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchSipDomainResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountSipSipDomain])
                res.api_v2010_account_sip_sip_domain = out

        return res

    def fetch_sip_ip_access_control_list(self, request: operations.FetchSipIPAccessControlListRequest, security: operations.FetchSipIPAccessControlListSecurity, server_url: Optional[str] = None) -> operations.FetchSipIPAccessControlListResponse:
        r"""Fetch a specific instance of an IpAccessControlList"""
        base_url = operations.FETCH_SIP_IP_ACCESS_CONTROL_LIST_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchSipIPAccessControlListRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchSipIPAccessControlListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountSipSipIPAccessControlList])
                res.api_v2010_account_sip_sip_ip_access_control_list = out

        return res

    def fetch_sip_ip_access_control_list_mapping(self, request: operations.FetchSipIPAccessControlListMappingRequest, security: operations.FetchSipIPAccessControlListMappingSecurity, server_url: Optional[str] = None) -> operations.FetchSipIPAccessControlListMappingResponse:
        r"""Fetch an IpAccessControlListMapping resource."""
        base_url = operations.FETCH_SIP_IP_ACCESS_CONTROL_LIST_MAPPING_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchSipIPAccessControlListMappingRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/IpAccessControlListMappings/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchSipIPAccessControlListMappingResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountSipSipDomainSipIPAccessControlListMapping])
                res.api_v2010_account_sip_sip_domain_sip_ip_access_control_list_mapping = out

        return res

    def fetch_sip_ip_address(self, request: operations.FetchSipIPAddressRequest, security: operations.FetchSipIPAddressSecurity, server_url: Optional[str] = None) -> operations.FetchSipIPAddressResponse:
        r"""Read one IpAddress resource."""
        base_url = operations.FETCH_SIP_IP_ADDRESS_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchSipIPAddressRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists/{IpAccessControlListSid}/IpAddresses/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchSipIPAddressResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountSipSipIPAccessControlListSipIPAddress])
                res.api_v2010_account_sip_sip_ip_access_control_list_sip_ip_address = out

        return res

    def fetch_transcription(self, request: operations.FetchTranscriptionRequest, security: operations.FetchTranscriptionSecurity, server_url: Optional[str] = None) -> operations.FetchTranscriptionResponse:
        r"""Fetch an instance of a Transcription"""
        base_url = operations.FETCH_TRANSCRIPTION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchTranscriptionRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Transcriptions/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchTranscriptionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountTranscription])
                res.api_v2010_account_transcription = out

        return res

    def fetch_usage_trigger(self, request: operations.FetchUsageTriggerRequest, security: operations.FetchUsageTriggerSecurity, server_url: Optional[str] = None) -> operations.FetchUsageTriggerResponse:
        r"""Fetch and instance of a usage-trigger"""
        base_url = operations.FETCH_USAGE_TRIGGER_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchUsageTriggerRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Usage/Triggers/{Sid}.json', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchUsageTriggerResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountUsageUsageTrigger])
                res.api_v2010_account_usage_usage_trigger = out

        return res

    def list_account(self, request: operations.ListAccountRequest, security: operations.ListAccountSecurity, server_url: Optional[str] = None) -> operations.ListAccountResponse:
        r"""Retrieves a collection of Accounts belonging to the account used to make the request"""
        base_url = operations.LIST_ACCOUNT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/2010-04-01/Accounts.json'
        
        query_params = utils.get_query_params(operations.ListAccountRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListAccountResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListAccountListAccountResponse])
                res.list_account_response = out

        return res

    def list_address(self, request: operations.ListAddressRequest, security: operations.ListAddressSecurity, server_url: Optional[str] = None) -> operations.ListAddressResponse:
        base_url = operations.LIST_ADDRESS_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListAddressRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Addresses.json', request)
        
        query_params = utils.get_query_params(operations.ListAddressRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListAddressResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListAddressListAddressResponse])
                res.list_address_response = out

        return res

    def list_application(self, request: operations.ListApplicationRequest, security: operations.ListApplicationSecurity, server_url: Optional[str] = None) -> operations.ListApplicationResponse:
        r"""Retrieve a list of applications representing an application within the requesting account"""
        base_url = operations.LIST_APPLICATION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListApplicationRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Applications.json', request)
        
        query_params = utils.get_query_params(operations.ListApplicationRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListApplicationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListApplicationListApplicationResponse])
                res.list_application_response = out

        return res

    def list_authorized_connect_app(self, request: operations.ListAuthorizedConnectAppRequest, security: operations.ListAuthorizedConnectAppSecurity, server_url: Optional[str] = None) -> operations.ListAuthorizedConnectAppResponse:
        r"""Retrieve a list of authorized-connect-apps belonging to the account used to make the request"""
        base_url = operations.LIST_AUTHORIZED_CONNECT_APP_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListAuthorizedConnectAppRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/AuthorizedConnectApps.json', request)
        
        query_params = utils.get_query_params(operations.ListAuthorizedConnectAppRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListAuthorizedConnectAppResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListAuthorizedConnectAppListAuthorizedConnectAppResponse])
                res.list_authorized_connect_app_response = out

        return res

    def list_available_phone_number_country(self, request: operations.ListAvailablePhoneNumberCountryRequest, security: operations.ListAvailablePhoneNumberCountrySecurity, server_url: Optional[str] = None) -> operations.ListAvailablePhoneNumberCountryResponse:
        base_url = operations.LIST_AVAILABLE_PHONE_NUMBER_COUNTRY_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListAvailablePhoneNumberCountryRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers.json', request)
        
        query_params = utils.get_query_params(operations.ListAvailablePhoneNumberCountryRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListAvailablePhoneNumberCountryResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListAvailablePhoneNumberCountryListAvailablePhoneNumberCountryResponse])
                res.list_available_phone_number_country_response = out

        return res

    def list_available_phone_number_local(self, request: operations.ListAvailablePhoneNumberLocalRequest, security: operations.ListAvailablePhoneNumberLocalSecurity, server_url: Optional[str] = None) -> operations.ListAvailablePhoneNumberLocalResponse:
        base_url = operations.LIST_AVAILABLE_PHONE_NUMBER_LOCAL_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListAvailablePhoneNumberLocalRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers/{CountryCode}/Local.json', request)
        
        query_params = utils.get_query_params(operations.ListAvailablePhoneNumberLocalRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListAvailablePhoneNumberLocalResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListAvailablePhoneNumberLocalListAvailablePhoneNumberLocalResponse])
                res.list_available_phone_number_local_response = out

        return res

    def list_available_phone_number_machine_to_machine(self, request: operations.ListAvailablePhoneNumberMachineToMachineRequest, security: operations.ListAvailablePhoneNumberMachineToMachineSecurity, server_url: Optional[str] = None) -> operations.ListAvailablePhoneNumberMachineToMachineResponse:
        base_url = operations.LIST_AVAILABLE_PHONE_NUMBER_MACHINE_TO_MACHINE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListAvailablePhoneNumberMachineToMachineRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers/{CountryCode}/MachineToMachine.json', request)
        
        query_params = utils.get_query_params(operations.ListAvailablePhoneNumberMachineToMachineRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListAvailablePhoneNumberMachineToMachineResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListAvailablePhoneNumberMachineToMachineListAvailablePhoneNumberMachineToMachineResponse])
                res.list_available_phone_number_machine_to_machine_response = out

        return res

    def list_available_phone_number_mobile(self, request: operations.ListAvailablePhoneNumberMobileRequest, security: operations.ListAvailablePhoneNumberMobileSecurity, server_url: Optional[str] = None) -> operations.ListAvailablePhoneNumberMobileResponse:
        base_url = operations.LIST_AVAILABLE_PHONE_NUMBER_MOBILE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListAvailablePhoneNumberMobileRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers/{CountryCode}/Mobile.json', request)
        
        query_params = utils.get_query_params(operations.ListAvailablePhoneNumberMobileRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListAvailablePhoneNumberMobileResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListAvailablePhoneNumberMobileListAvailablePhoneNumberMobileResponse])
                res.list_available_phone_number_mobile_response = out

        return res

    def list_available_phone_number_national(self, request: operations.ListAvailablePhoneNumberNationalRequest, security: operations.ListAvailablePhoneNumberNationalSecurity, server_url: Optional[str] = None) -> operations.ListAvailablePhoneNumberNationalResponse:
        base_url = operations.LIST_AVAILABLE_PHONE_NUMBER_NATIONAL_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListAvailablePhoneNumberNationalRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers/{CountryCode}/National.json', request)
        
        query_params = utils.get_query_params(operations.ListAvailablePhoneNumberNationalRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListAvailablePhoneNumberNationalResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListAvailablePhoneNumberNationalListAvailablePhoneNumberNationalResponse])
                res.list_available_phone_number_national_response = out

        return res

    def list_available_phone_number_shared_cost(self, request: operations.ListAvailablePhoneNumberSharedCostRequest, security: operations.ListAvailablePhoneNumberSharedCostSecurity, server_url: Optional[str] = None) -> operations.ListAvailablePhoneNumberSharedCostResponse:
        base_url = operations.LIST_AVAILABLE_PHONE_NUMBER_SHARED_COST_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListAvailablePhoneNumberSharedCostRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers/{CountryCode}/SharedCost.json', request)
        
        query_params = utils.get_query_params(operations.ListAvailablePhoneNumberSharedCostRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListAvailablePhoneNumberSharedCostResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListAvailablePhoneNumberSharedCostListAvailablePhoneNumberSharedCostResponse])
                res.list_available_phone_number_shared_cost_response = out

        return res

    def list_available_phone_number_toll_free(self, request: operations.ListAvailablePhoneNumberTollFreeRequest, security: operations.ListAvailablePhoneNumberTollFreeSecurity, server_url: Optional[str] = None) -> operations.ListAvailablePhoneNumberTollFreeResponse:
        base_url = operations.LIST_AVAILABLE_PHONE_NUMBER_TOLL_FREE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListAvailablePhoneNumberTollFreeRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers/{CountryCode}/TollFree.json', request)
        
        query_params = utils.get_query_params(operations.ListAvailablePhoneNumberTollFreeRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListAvailablePhoneNumberTollFreeResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListAvailablePhoneNumberTollFreeListAvailablePhoneNumberTollFreeResponse])
                res.list_available_phone_number_toll_free_response = out

        return res

    def list_available_phone_number_voip(self, request: operations.ListAvailablePhoneNumberVoipRequest, security: operations.ListAvailablePhoneNumberVoipSecurity, server_url: Optional[str] = None) -> operations.ListAvailablePhoneNumberVoipResponse:
        base_url = operations.LIST_AVAILABLE_PHONE_NUMBER_VOIP_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListAvailablePhoneNumberVoipRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers/{CountryCode}/Voip.json', request)
        
        query_params = utils.get_query_params(operations.ListAvailablePhoneNumberVoipRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListAvailablePhoneNumberVoipResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListAvailablePhoneNumberVoipListAvailablePhoneNumberVoipResponse])
                res.list_available_phone_number_voip_response = out

        return res

    def list_call(self, request: operations.ListCallRequest, security: operations.ListCallSecurity, server_url: Optional[str] = None) -> operations.ListCallResponse:
        r"""Retrieves a collection of calls made to and from your account"""
        base_url = operations.LIST_CALL_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListCallRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Calls.json', request)
        
        query_params = utils.get_query_params(operations.ListCallRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListCallResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListCallListCallResponse])
                res.list_call_response = out

        return res

    def list_call_event(self, request: operations.ListCallEventRequest, security: operations.ListCallEventSecurity, server_url: Optional[str] = None) -> operations.ListCallEventResponse:
        r"""Retrieve a list of all events for a call."""
        base_url = operations.LIST_CALL_EVENT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListCallEventRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Events.json', request)
        
        query_params = utils.get_query_params(operations.ListCallEventRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListCallEventResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListCallEventListCallEventResponse])
                res.list_call_event_response = out

        return res

    def list_call_notification(self, request: operations.ListCallNotificationRequest, security: operations.ListCallNotificationSecurity, server_url: Optional[str] = None) -> operations.ListCallNotificationResponse:
        base_url = operations.LIST_CALL_NOTIFICATION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListCallNotificationRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Notifications.json', request)
        
        query_params = utils.get_query_params(operations.ListCallNotificationRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListCallNotificationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListCallNotificationListCallNotificationResponse])
                res.list_call_notification_response = out

        return res

    def list_call_recording(self, request: operations.ListCallRecordingRequest, security: operations.ListCallRecordingSecurity, server_url: Optional[str] = None) -> operations.ListCallRecordingResponse:
        r"""Retrieve a list of recordings belonging to the call used to make the request"""
        base_url = operations.LIST_CALL_RECORDING_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListCallRecordingRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Recordings.json', request)
        
        query_params = utils.get_query_params(operations.ListCallRecordingRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListCallRecordingResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListCallRecordingListCallRecordingResponse])
                res.list_call_recording_response = out

        return res

    def list_conference(self, request: operations.ListConferenceRequest, security: operations.ListConferenceSecurity, server_url: Optional[str] = None) -> operations.ListConferenceResponse:
        r"""Retrieve a list of conferences belonging to the account used to make the request"""
        base_url = operations.LIST_CONFERENCE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListConferenceRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Conferences.json', request)
        
        query_params = utils.get_query_params(operations.ListConferenceRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListConferenceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListConferenceListConferenceResponse])
                res.list_conference_response = out

        return res

    def list_conference_recording(self, request: operations.ListConferenceRecordingRequest, security: operations.ListConferenceRecordingSecurity, server_url: Optional[str] = None) -> operations.ListConferenceRecordingResponse:
        r"""Retrieve a list of recordings belonging to the call used to make the request"""
        base_url = operations.LIST_CONFERENCE_RECORDING_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListConferenceRecordingRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Recordings.json', request)
        
        query_params = utils.get_query_params(operations.ListConferenceRecordingRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListConferenceRecordingResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListConferenceRecordingListConferenceRecordingResponse])
                res.list_conference_recording_response = out

        return res

    def list_connect_app(self, request: operations.ListConnectAppRequest, security: operations.ListConnectAppSecurity, server_url: Optional[str] = None) -> operations.ListConnectAppResponse:
        r"""Retrieve a list of connect-apps belonging to the account used to make the request"""
        base_url = operations.LIST_CONNECT_APP_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListConnectAppRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/ConnectApps.json', request)
        
        query_params = utils.get_query_params(operations.ListConnectAppRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListConnectAppResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListConnectAppListConnectAppResponse])
                res.list_connect_app_response = out

        return res

    def list_dependent_phone_number(self, request: operations.ListDependentPhoneNumberRequest, security: operations.ListDependentPhoneNumberSecurity, server_url: Optional[str] = None) -> operations.ListDependentPhoneNumberResponse:
        base_url = operations.LIST_DEPENDENT_PHONE_NUMBER_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListDependentPhoneNumberRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Addresses/{AddressSid}/DependentPhoneNumbers.json', request)
        
        query_params = utils.get_query_params(operations.ListDependentPhoneNumberRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListDependentPhoneNumberResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListDependentPhoneNumberListDependentPhoneNumberResponse])
                res.list_dependent_phone_number_response = out

        return res

    def list_incoming_phone_number(self, request: operations.ListIncomingPhoneNumberRequest, security: operations.ListIncomingPhoneNumberSecurity, server_url: Optional[str] = None) -> operations.ListIncomingPhoneNumberResponse:
        r"""Retrieve a list of incoming-phone-numbers belonging to the account used to make the request."""
        base_url = operations.LIST_INCOMING_PHONE_NUMBER_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListIncomingPhoneNumberRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers.json', request)
        
        query_params = utils.get_query_params(operations.ListIncomingPhoneNumberRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListIncomingPhoneNumberResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListIncomingPhoneNumberListIncomingPhoneNumberResponse])
                res.list_incoming_phone_number_response = out

        return res

    def list_incoming_phone_number_assigned_add_on(self, request: operations.ListIncomingPhoneNumberAssignedAddOnRequest, security: operations.ListIncomingPhoneNumberAssignedAddOnSecurity, server_url: Optional[str] = None) -> operations.ListIncomingPhoneNumberAssignedAddOnResponse:
        r"""Retrieve a list of Add-on installations currently assigned to this Number."""
        base_url = operations.LIST_INCOMING_PHONE_NUMBER_ASSIGNED_ADD_ON_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListIncomingPhoneNumberAssignedAddOnRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{ResourceSid}/AssignedAddOns.json', request)
        
        query_params = utils.get_query_params(operations.ListIncomingPhoneNumberAssignedAddOnRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListIncomingPhoneNumberAssignedAddOnResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListIncomingPhoneNumberAssignedAddOnListIncomingPhoneNumberAssignedAddOnResponse])
                res.list_incoming_phone_number_assigned_add_on_response = out

        return res

    def list_incoming_phone_number_assigned_add_on_extension(self, request: operations.ListIncomingPhoneNumberAssignedAddOnExtensionRequest, security: operations.ListIncomingPhoneNumberAssignedAddOnExtensionSecurity, server_url: Optional[str] = None) -> operations.ListIncomingPhoneNumberAssignedAddOnExtensionResponse:
        r"""Retrieve a list of Extensions for the Assigned Add-on."""
        base_url = operations.LIST_INCOMING_PHONE_NUMBER_ASSIGNED_ADD_ON_EXTENSION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListIncomingPhoneNumberAssignedAddOnExtensionRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{ResourceSid}/AssignedAddOns/{AssignedAddOnSid}/Extensions.json', request)
        
        query_params = utils.get_query_params(operations.ListIncomingPhoneNumberAssignedAddOnExtensionRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListIncomingPhoneNumberAssignedAddOnExtensionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListIncomingPhoneNumberAssignedAddOnExtensionListIncomingPhoneNumberAssignedAddOnExtensionResponse])
                res.list_incoming_phone_number_assigned_add_on_extension_response = out

        return res

    def list_incoming_phone_number_local(self, request: operations.ListIncomingPhoneNumberLocalRequest, security: operations.ListIncomingPhoneNumberLocalSecurity, server_url: Optional[str] = None) -> operations.ListIncomingPhoneNumberLocalResponse:
        base_url = operations.LIST_INCOMING_PHONE_NUMBER_LOCAL_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListIncomingPhoneNumberLocalRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/Local.json', request)
        
        query_params = utils.get_query_params(operations.ListIncomingPhoneNumberLocalRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListIncomingPhoneNumberLocalResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListIncomingPhoneNumberLocalListIncomingPhoneNumberLocalResponse])
                res.list_incoming_phone_number_local_response = out

        return res

    def list_incoming_phone_number_mobile(self, request: operations.ListIncomingPhoneNumberMobileRequest, security: operations.ListIncomingPhoneNumberMobileSecurity, server_url: Optional[str] = None) -> operations.ListIncomingPhoneNumberMobileResponse:
        base_url = operations.LIST_INCOMING_PHONE_NUMBER_MOBILE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListIncomingPhoneNumberMobileRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/Mobile.json', request)
        
        query_params = utils.get_query_params(operations.ListIncomingPhoneNumberMobileRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListIncomingPhoneNumberMobileResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListIncomingPhoneNumberMobileListIncomingPhoneNumberMobileResponse])
                res.list_incoming_phone_number_mobile_response = out

        return res

    def list_incoming_phone_number_toll_free(self, request: operations.ListIncomingPhoneNumberTollFreeRequest, security: operations.ListIncomingPhoneNumberTollFreeSecurity, server_url: Optional[str] = None) -> operations.ListIncomingPhoneNumberTollFreeResponse:
        base_url = operations.LIST_INCOMING_PHONE_NUMBER_TOLL_FREE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListIncomingPhoneNumberTollFreeRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/TollFree.json', request)
        
        query_params = utils.get_query_params(operations.ListIncomingPhoneNumberTollFreeRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListIncomingPhoneNumberTollFreeResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListIncomingPhoneNumberTollFreeListIncomingPhoneNumberTollFreeResponse])
                res.list_incoming_phone_number_toll_free_response = out

        return res

    def list_key(self, request: operations.ListKeyRequest, security: operations.ListKeySecurity, server_url: Optional[str] = None) -> operations.ListKeyResponse:
        base_url = operations.LIST_KEY_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListKeyRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Keys.json', request)
        
        query_params = utils.get_query_params(operations.ListKeyRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListKeyResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListKeyListKeyResponse])
                res.list_key_response = out

        return res

    def list_media(self, request: operations.ListMediaRequest, security: operations.ListMediaSecurity, server_url: Optional[str] = None) -> operations.ListMediaResponse:
        r"""Retrieve a list of Media resources belonging to the account used to make the request"""
        base_url = operations.LIST_MEDIA_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListMediaRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Messages/{MessageSid}/Media.json', request)
        
        query_params = utils.get_query_params(operations.ListMediaRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListMediaResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListMediaListMediaResponse])
                res.list_media_response = out

        return res

    def list_member(self, request: operations.ListMemberRequest, security: operations.ListMemberSecurity, server_url: Optional[str] = None) -> operations.ListMemberResponse:
        r"""Retrieve the members of the queue"""
        base_url = operations.LIST_MEMBER_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListMemberRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Queues/{QueueSid}/Members.json', request)
        
        query_params = utils.get_query_params(operations.ListMemberRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListMemberResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListMemberListMemberResponse])
                res.list_member_response = out

        return res

    def list_message(self, request: operations.ListMessageRequest, security: operations.ListMessageSecurity, server_url: Optional[str] = None) -> operations.ListMessageResponse:
        r"""Retrieve a list of messages belonging to the account used to make the request"""
        base_url = operations.LIST_MESSAGE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListMessageRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Messages.json', request)
        
        query_params = utils.get_query_params(operations.ListMessageRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListMessageResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListMessageListMessageResponse])
                res.list_message_response = out

        return res

    def list_notification(self, request: operations.ListNotificationRequest, security: operations.ListNotificationSecurity, server_url: Optional[str] = None) -> operations.ListNotificationResponse:
        r"""Retrieve a list of notifications belonging to the account used to make the request"""
        base_url = operations.LIST_NOTIFICATION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListNotificationRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Notifications.json', request)
        
        query_params = utils.get_query_params(operations.ListNotificationRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListNotificationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListNotificationListNotificationResponse])
                res.list_notification_response = out

        return res

    def list_outgoing_caller_id(self, request: operations.ListOutgoingCallerIDRequest, security: operations.ListOutgoingCallerIDSecurity, server_url: Optional[str] = None) -> operations.ListOutgoingCallerIDResponse:
        r"""Retrieve a list of outgoing-caller-ids belonging to the account used to make the request"""
        base_url = operations.LIST_OUTGOING_CALLER_ID_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListOutgoingCallerIDRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/OutgoingCallerIds.json', request)
        
        query_params = utils.get_query_params(operations.ListOutgoingCallerIDRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListOutgoingCallerIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListOutgoingCallerIDListOutgoingCallerIDResponse])
                res.list_outgoing_caller_id_response = out

        return res

    def list_participant(self, request: operations.ListParticipantRequest, security: operations.ListParticipantSecurity, server_url: Optional[str] = None) -> operations.ListParticipantResponse:
        r"""Retrieve a list of participants belonging to the account used to make the request"""
        base_url = operations.LIST_PARTICIPANT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListParticipantRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Participants.json', request)
        
        query_params = utils.get_query_params(operations.ListParticipantRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListParticipantResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListParticipantListParticipantResponse])
                res.list_participant_response = out

        return res

    def list_queue(self, request: operations.ListQueueRequest, security: operations.ListQueueSecurity, server_url: Optional[str] = None) -> operations.ListQueueResponse:
        r"""Retrieve a list of queues belonging to the account used to make the request"""
        base_url = operations.LIST_QUEUE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListQueueRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Queues.json', request)
        
        query_params = utils.get_query_params(operations.ListQueueRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListQueueResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListQueueListQueueResponse])
                res.list_queue_response = out

        return res

    def list_recording(self, request: operations.ListRecordingRequest, security: operations.ListRecordingSecurity, server_url: Optional[str] = None) -> operations.ListRecordingResponse:
        r"""Retrieve a list of recordings belonging to the account used to make the request"""
        base_url = operations.LIST_RECORDING_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListRecordingRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Recordings.json', request)
        
        query_params = utils.get_query_params(operations.ListRecordingRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListRecordingResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListRecordingListRecordingResponse])
                res.list_recording_response = out

        return res

    def list_recording_add_on_result(self, request: operations.ListRecordingAddOnResultRequest, security: operations.ListRecordingAddOnResultSecurity, server_url: Optional[str] = None) -> operations.ListRecordingAddOnResultResponse:
        r"""Retrieve a list of results belonging to the recording"""
        base_url = operations.LIST_RECORDING_ADD_ON_RESULT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListRecordingAddOnResultRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Recordings/{ReferenceSid}/AddOnResults.json', request)
        
        query_params = utils.get_query_params(operations.ListRecordingAddOnResultRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListRecordingAddOnResultResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListRecordingAddOnResultListRecordingAddOnResultResponse])
                res.list_recording_add_on_result_response = out

        return res

    def list_recording_add_on_result_payload(self, request: operations.ListRecordingAddOnResultPayloadRequest, security: operations.ListRecordingAddOnResultPayloadSecurity, server_url: Optional[str] = None) -> operations.ListRecordingAddOnResultPayloadResponse:
        r"""Retrieve a list of payloads belonging to the AddOnResult"""
        base_url = operations.LIST_RECORDING_ADD_ON_RESULT_PAYLOAD_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListRecordingAddOnResultPayloadRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Recordings/{ReferenceSid}/AddOnResults/{AddOnResultSid}/Payloads.json', request)
        
        query_params = utils.get_query_params(operations.ListRecordingAddOnResultPayloadRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListRecordingAddOnResultPayloadResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListRecordingAddOnResultPayloadListRecordingAddOnResultPayloadResponse])
                res.list_recording_add_on_result_payload_response = out

        return res

    def list_recording_transcription(self, request: operations.ListRecordingTranscriptionRequest, security: operations.ListRecordingTranscriptionSecurity, server_url: Optional[str] = None) -> operations.ListRecordingTranscriptionResponse:
        base_url = operations.LIST_RECORDING_TRANSCRIPTION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListRecordingTranscriptionRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Recordings/{RecordingSid}/Transcriptions.json', request)
        
        query_params = utils.get_query_params(operations.ListRecordingTranscriptionRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListRecordingTranscriptionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListRecordingTranscriptionListRecordingTranscriptionResponse])
                res.list_recording_transcription_response = out

        return res

    def list_short_code(self, request: operations.ListShortCodeRequest, security: operations.ListShortCodeSecurity, server_url: Optional[str] = None) -> operations.ListShortCodeResponse:
        r"""Retrieve a list of short-codes belonging to the account used to make the request"""
        base_url = operations.LIST_SHORT_CODE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListShortCodeRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/SMS/ShortCodes.json', request)
        
        query_params = utils.get_query_params(operations.ListShortCodeRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListShortCodeResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListShortCodeListShortCodeResponse])
                res.list_short_code_response = out

        return res

    def list_signing_key(self, request: operations.ListSigningKeyRequest, security: operations.ListSigningKeySecurity, server_url: Optional[str] = None) -> operations.ListSigningKeyResponse:
        base_url = operations.LIST_SIGNING_KEY_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListSigningKeyRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/SigningKeys.json', request)
        
        query_params = utils.get_query_params(operations.ListSigningKeyRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListSigningKeyResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListSigningKeyListSigningKeyResponse])
                res.list_signing_key_response = out

        return res

    def list_sip_auth_calls_credential_list_mapping(self, request: operations.ListSipAuthCallsCredentialListMappingRequest, security: operations.ListSipAuthCallsCredentialListMappingSecurity, server_url: Optional[str] = None) -> operations.ListSipAuthCallsCredentialListMappingResponse:
        r"""Retrieve a list of credential list mappings belonging to the domain used in the request"""
        base_url = operations.LIST_SIP_AUTH_CALLS_CREDENTIAL_LIST_MAPPING_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListSipAuthCallsCredentialListMappingRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Calls/CredentialListMappings.json', request)
        
        query_params = utils.get_query_params(operations.ListSipAuthCallsCredentialListMappingRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListSipAuthCallsCredentialListMappingResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListSipAuthCallsCredentialListMappingListSipAuthCallsCredentialListMappingResponse])
                res.list_sip_auth_calls_credential_list_mapping_response = out

        return res

    def list_sip_auth_calls_ip_access_control_list_mapping(self, request: operations.ListSipAuthCallsIPAccessControlListMappingRequest, security: operations.ListSipAuthCallsIPAccessControlListMappingSecurity, server_url: Optional[str] = None) -> operations.ListSipAuthCallsIPAccessControlListMappingResponse:
        r"""Retrieve a list of IP Access Control List mappings belonging to the domain used in the request"""
        base_url = operations.LIST_SIP_AUTH_CALLS_IP_ACCESS_CONTROL_LIST_MAPPING_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListSipAuthCallsIPAccessControlListMappingRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Calls/IpAccessControlListMappings.json', request)
        
        query_params = utils.get_query_params(operations.ListSipAuthCallsIPAccessControlListMappingRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListSipAuthCallsIPAccessControlListMappingResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListSipAuthCallsIPAccessControlListMappingListSipAuthCallsIPAccessControlListMappingResponse])
                res.list_sip_auth_calls_ip_access_control_list_mapping_response = out

        return res

    def list_sip_auth_registrations_credential_list_mapping(self, request: operations.ListSipAuthRegistrationsCredentialListMappingRequest, security: operations.ListSipAuthRegistrationsCredentialListMappingSecurity, server_url: Optional[str] = None) -> operations.ListSipAuthRegistrationsCredentialListMappingResponse:
        r"""Retrieve a list of credential list mappings belonging to the domain used in the request"""
        base_url = operations.LIST_SIP_AUTH_REGISTRATIONS_CREDENTIAL_LIST_MAPPING_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListSipAuthRegistrationsCredentialListMappingRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Registrations/CredentialListMappings.json', request)
        
        query_params = utils.get_query_params(operations.ListSipAuthRegistrationsCredentialListMappingRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListSipAuthRegistrationsCredentialListMappingResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListSipAuthRegistrationsCredentialListMappingListSipAuthRegistrationsCredentialListMappingResponse])
                res.list_sip_auth_registrations_credential_list_mapping_response = out

        return res

    def list_sip_credential(self, request: operations.ListSipCredentialRequest, security: operations.ListSipCredentialSecurity, server_url: Optional[str] = None) -> operations.ListSipCredentialResponse:
        r"""Retrieve a list of credentials."""
        base_url = operations.LIST_SIP_CREDENTIAL_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListSipCredentialRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists/{CredentialListSid}/Credentials.json', request)
        
        query_params = utils.get_query_params(operations.ListSipCredentialRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListSipCredentialResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListSipCredentialListSipCredentialResponse])
                res.list_sip_credential_response = out

        return res

    def list_sip_credential_list(self, request: operations.ListSipCredentialListRequest, security: operations.ListSipCredentialListSecurity, server_url: Optional[str] = None) -> operations.ListSipCredentialListResponse:
        r"""Get All Credential Lists"""
        base_url = operations.LIST_SIP_CREDENTIAL_LIST_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListSipCredentialListRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists.json', request)
        
        query_params = utils.get_query_params(operations.ListSipCredentialListRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListSipCredentialListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListSipCredentialListListSipCredentialListResponse])
                res.list_sip_credential_list_response = out

        return res

    def list_sip_credential_list_mapping(self, request: operations.ListSipCredentialListMappingRequest, security: operations.ListSipCredentialListMappingSecurity, server_url: Optional[str] = None) -> operations.ListSipCredentialListMappingResponse:
        r"""Read multiple CredentialListMapping resources from an account."""
        base_url = operations.LIST_SIP_CREDENTIAL_LIST_MAPPING_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListSipCredentialListMappingRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/CredentialListMappings.json', request)
        
        query_params = utils.get_query_params(operations.ListSipCredentialListMappingRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListSipCredentialListMappingResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListSipCredentialListMappingListSipCredentialListMappingResponse])
                res.list_sip_credential_list_mapping_response = out

        return res

    def list_sip_domain(self, request: operations.ListSipDomainRequest, security: operations.ListSipDomainSecurity, server_url: Optional[str] = None) -> operations.ListSipDomainResponse:
        r"""Retrieve a list of domains belonging to the account used to make the request"""
        base_url = operations.LIST_SIP_DOMAIN_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListSipDomainRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/SIP/Domains.json', request)
        
        query_params = utils.get_query_params(operations.ListSipDomainRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListSipDomainResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListSipDomainListSipDomainResponse])
                res.list_sip_domain_response = out

        return res

    def list_sip_ip_access_control_list(self, request: operations.ListSipIPAccessControlListRequest, security: operations.ListSipIPAccessControlListSecurity, server_url: Optional[str] = None) -> operations.ListSipIPAccessControlListResponse:
        r"""Retrieve a list of IpAccessControlLists that belong to the account used to make the request"""
        base_url = operations.LIST_SIP_IP_ACCESS_CONTROL_LIST_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListSipIPAccessControlListRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists.json', request)
        
        query_params = utils.get_query_params(operations.ListSipIPAccessControlListRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListSipIPAccessControlListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListSipIPAccessControlListListSipIPAccessControlListResponse])
                res.list_sip_ip_access_control_list_response = out

        return res

    def list_sip_ip_access_control_list_mapping(self, request: operations.ListSipIPAccessControlListMappingRequest, security: operations.ListSipIPAccessControlListMappingSecurity, server_url: Optional[str] = None) -> operations.ListSipIPAccessControlListMappingResponse:
        r"""Retrieve a list of IpAccessControlListMapping resources."""
        base_url = operations.LIST_SIP_IP_ACCESS_CONTROL_LIST_MAPPING_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListSipIPAccessControlListMappingRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/IpAccessControlListMappings.json', request)
        
        query_params = utils.get_query_params(operations.ListSipIPAccessControlListMappingRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListSipIPAccessControlListMappingResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListSipIPAccessControlListMappingListSipIPAccessControlListMappingResponse])
                res.list_sip_ip_access_control_list_mapping_response = out

        return res

    def list_sip_ip_address(self, request: operations.ListSipIPAddressRequest, security: operations.ListSipIPAddressSecurity, server_url: Optional[str] = None) -> operations.ListSipIPAddressResponse:
        r"""Read multiple IpAddress resources."""
        base_url = operations.LIST_SIP_IP_ADDRESS_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListSipIPAddressRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists/{IpAccessControlListSid}/IpAddresses.json', request)
        
        query_params = utils.get_query_params(operations.ListSipIPAddressRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListSipIPAddressResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListSipIPAddressListSipIPAddressResponse])
                res.list_sip_ip_address_response = out

        return res

    def list_transcription(self, request: operations.ListTranscriptionRequest, security: operations.ListTranscriptionSecurity, server_url: Optional[str] = None) -> operations.ListTranscriptionResponse:
        r"""Retrieve a list of transcriptions belonging to the account used to make the request"""
        base_url = operations.LIST_TRANSCRIPTION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListTranscriptionRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Transcriptions.json', request)
        
        query_params = utils.get_query_params(operations.ListTranscriptionRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListTranscriptionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListTranscriptionListTranscriptionResponse])
                res.list_transcription_response = out

        return res

    def list_usage_record(self, request: operations.ListUsageRecordRequest, security: operations.ListUsageRecordSecurity, server_url: Optional[str] = None) -> operations.ListUsageRecordResponse:
        r"""Retrieve a list of usage-records belonging to the account used to make the request"""
        base_url = operations.LIST_USAGE_RECORD_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListUsageRecordRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Usage/Records.json', request)
        
        query_params = utils.get_query_params(operations.ListUsageRecordRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListUsageRecordResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListUsageRecordListUsageRecordResponse])
                res.list_usage_record_response = out

        return res

    def list_usage_record_all_time(self, request: operations.ListUsageRecordAllTimeRequest, security: operations.ListUsageRecordAllTimeSecurity, server_url: Optional[str] = None) -> operations.ListUsageRecordAllTimeResponse:
        base_url = operations.LIST_USAGE_RECORD_ALL_TIME_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListUsageRecordAllTimeRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Usage/Records/AllTime.json', request)
        
        query_params = utils.get_query_params(operations.ListUsageRecordAllTimeRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListUsageRecordAllTimeResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListUsageRecordAllTimeListUsageRecordAllTimeResponse])
                res.list_usage_record_all_time_response = out

        return res

    def list_usage_record_daily(self, request: operations.ListUsageRecordDailyRequest, security: operations.ListUsageRecordDailySecurity, server_url: Optional[str] = None) -> operations.ListUsageRecordDailyResponse:
        base_url = operations.LIST_USAGE_RECORD_DAILY_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListUsageRecordDailyRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Usage/Records/Daily.json', request)
        
        query_params = utils.get_query_params(operations.ListUsageRecordDailyRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListUsageRecordDailyResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListUsageRecordDailyListUsageRecordDailyResponse])
                res.list_usage_record_daily_response = out

        return res

    def list_usage_record_last_month(self, request: operations.ListUsageRecordLastMonthRequest, security: operations.ListUsageRecordLastMonthSecurity, server_url: Optional[str] = None) -> operations.ListUsageRecordLastMonthResponse:
        base_url = operations.LIST_USAGE_RECORD_LAST_MONTH_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListUsageRecordLastMonthRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Usage/Records/LastMonth.json', request)
        
        query_params = utils.get_query_params(operations.ListUsageRecordLastMonthRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListUsageRecordLastMonthResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListUsageRecordLastMonthListUsageRecordLastMonthResponse])
                res.list_usage_record_last_month_response = out

        return res

    def list_usage_record_monthly(self, request: operations.ListUsageRecordMonthlyRequest, security: operations.ListUsageRecordMonthlySecurity, server_url: Optional[str] = None) -> operations.ListUsageRecordMonthlyResponse:
        base_url = operations.LIST_USAGE_RECORD_MONTHLY_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListUsageRecordMonthlyRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Usage/Records/Monthly.json', request)
        
        query_params = utils.get_query_params(operations.ListUsageRecordMonthlyRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListUsageRecordMonthlyResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListUsageRecordMonthlyListUsageRecordMonthlyResponse])
                res.list_usage_record_monthly_response = out

        return res

    def list_usage_record_this_month(self, request: operations.ListUsageRecordThisMonthRequest, security: operations.ListUsageRecordThisMonthSecurity, server_url: Optional[str] = None) -> operations.ListUsageRecordThisMonthResponse:
        base_url = operations.LIST_USAGE_RECORD_THIS_MONTH_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListUsageRecordThisMonthRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Usage/Records/ThisMonth.json', request)
        
        query_params = utils.get_query_params(operations.ListUsageRecordThisMonthRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListUsageRecordThisMonthResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListUsageRecordThisMonthListUsageRecordThisMonthResponse])
                res.list_usage_record_this_month_response = out

        return res

    def list_usage_record_today(self, request: operations.ListUsageRecordTodayRequest, security: operations.ListUsageRecordTodaySecurity, server_url: Optional[str] = None) -> operations.ListUsageRecordTodayResponse:
        base_url = operations.LIST_USAGE_RECORD_TODAY_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListUsageRecordTodayRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Usage/Records/Today.json', request)
        
        query_params = utils.get_query_params(operations.ListUsageRecordTodayRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListUsageRecordTodayResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListUsageRecordTodayListUsageRecordTodayResponse])
                res.list_usage_record_today_response = out

        return res

    def list_usage_record_yearly(self, request: operations.ListUsageRecordYearlyRequest, security: operations.ListUsageRecordYearlySecurity, server_url: Optional[str] = None) -> operations.ListUsageRecordYearlyResponse:
        base_url = operations.LIST_USAGE_RECORD_YEARLY_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListUsageRecordYearlyRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Usage/Records/Yearly.json', request)
        
        query_params = utils.get_query_params(operations.ListUsageRecordYearlyRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListUsageRecordYearlyResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListUsageRecordYearlyListUsageRecordYearlyResponse])
                res.list_usage_record_yearly_response = out

        return res

    def list_usage_record_yesterday(self, request: operations.ListUsageRecordYesterdayRequest, security: operations.ListUsageRecordYesterdaySecurity, server_url: Optional[str] = None) -> operations.ListUsageRecordYesterdayResponse:
        base_url = operations.LIST_USAGE_RECORD_YESTERDAY_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListUsageRecordYesterdayRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Usage/Records/Yesterday.json', request)
        
        query_params = utils.get_query_params(operations.ListUsageRecordYesterdayRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListUsageRecordYesterdayResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListUsageRecordYesterdayListUsageRecordYesterdayResponse])
                res.list_usage_record_yesterday_response = out

        return res

    def list_usage_trigger(self, request: operations.ListUsageTriggerRequest, security: operations.ListUsageTriggerSecurity, server_url: Optional[str] = None) -> operations.ListUsageTriggerResponse:
        r"""Retrieve a list of usage-triggers belonging to the account used to make the request"""
        base_url = operations.LIST_USAGE_TRIGGER_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListUsageTriggerRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Usage/Triggers.json', request)
        
        query_params = utils.get_query_params(operations.ListUsageTriggerRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListUsageTriggerResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListUsageTriggerListUsageTriggerResponse])
                res.list_usage_trigger_response = out

        return res

    def update_account(self, request: operations.UpdateAccountRequest, security: operations.UpdateAccountSecurity, server_url: Optional[str] = None) -> operations.UpdateAccountResponse:
        r"""Modify the properties of a given Account"""
        base_url = operations.UPDATE_ACCOUNT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateAccountRequest, base_url, '/2010-04-01/Accounts/{Sid}.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateAccountResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010Account])
                res.api_v2010_account = out

        return res

    def update_address(self, request: operations.UpdateAddressRequest, security: operations.UpdateAddressSecurity, server_url: Optional[str] = None) -> operations.UpdateAddressResponse:
        base_url = operations.UPDATE_ADDRESS_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateAddressRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Addresses/{Sid}.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateAddressResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountAddress])
                res.api_v2010_account_address = out

        return res

    def update_application(self, request: operations.UpdateApplicationRequest, security: operations.UpdateApplicationSecurity, server_url: Optional[str] = None) -> operations.UpdateApplicationResponse:
        r"""Updates the application's properties"""
        base_url = operations.UPDATE_APPLICATION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateApplicationRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Applications/{Sid}.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateApplicationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountApplication])
                res.api_v2010_account_application = out

        return res

    def update_call(self, request: operations.UpdateCallRequest, security: operations.UpdateCallSecurity, server_url: Optional[str] = None) -> operations.UpdateCallResponse:
        r"""Initiates a call redirect or terminates a call"""
        base_url = operations.UPDATE_CALL_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateCallRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Calls/{Sid}.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateCallResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountCall])
                res.api_v2010_account_call = out

        return res

    def update_call_feedback(self, request: operations.UpdateCallFeedbackRequest, security: operations.UpdateCallFeedbackSecurity, server_url: Optional[str] = None) -> operations.UpdateCallFeedbackResponse:
        r"""Update a Feedback resource for a call"""
        base_url = operations.UPDATE_CALL_FEEDBACK_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateCallFeedbackRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Feedback.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateCallFeedbackResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountCallCallFeedback])
                res.api_v2010_account_call_call_feedback = out

        return res

    def update_call_recording(self, request: operations.UpdateCallRecordingRequest, security: operations.UpdateCallRecordingSecurity, server_url: Optional[str] = None) -> operations.UpdateCallRecordingResponse:
        r"""Changes the status of the recording to paused, stopped, or in-progress. Note: Pass `Twilio.CURRENT` instead of recording sid to reference current active recording."""
        base_url = operations.UPDATE_CALL_RECORDING_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateCallRecordingRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Recordings/{Sid}.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateCallRecordingResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountCallCallRecording])
                res.api_v2010_account_call_call_recording = out

        return res

    def update_conference(self, request: operations.UpdateConferenceRequest, security: operations.UpdateConferenceSecurity, server_url: Optional[str] = None) -> operations.UpdateConferenceResponse:
        base_url = operations.UPDATE_CONFERENCE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateConferenceRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Conferences/{Sid}.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateConferenceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountConference])
                res.api_v2010_account_conference = out

        return res

    def update_conference_recording(self, request: operations.UpdateConferenceRecordingRequest, security: operations.UpdateConferenceRecordingSecurity, server_url: Optional[str] = None) -> operations.UpdateConferenceRecordingResponse:
        r"""Changes the status of the recording to paused, stopped, or in-progress. Note: To use `Twilio.CURRENT`, pass it as recording sid."""
        base_url = operations.UPDATE_CONFERENCE_RECORDING_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateConferenceRecordingRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Recordings/{Sid}.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateConferenceRecordingResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountConferenceConferenceRecording])
                res.api_v2010_account_conference_conference_recording = out

        return res

    def update_connect_app(self, request: operations.UpdateConnectAppRequest, security: operations.UpdateConnectAppSecurity, server_url: Optional[str] = None) -> operations.UpdateConnectAppResponse:
        r"""Update a connect-app with the specified parameters"""
        base_url = operations.UPDATE_CONNECT_APP_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateConnectAppRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/ConnectApps/{Sid}.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateConnectAppResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountConnectApp])
                res.api_v2010_account_connect_app = out

        return res

    def update_incoming_phone_number(self, request: operations.UpdateIncomingPhoneNumberRequest, security: operations.UpdateIncomingPhoneNumberSecurity, server_url: Optional[str] = None) -> operations.UpdateIncomingPhoneNumberResponse:
        r"""Update an incoming-phone-number instance."""
        base_url = operations.UPDATE_INCOMING_PHONE_NUMBER_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateIncomingPhoneNumberRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{Sid}.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateIncomingPhoneNumberResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountIncomingPhoneNumber])
                res.api_v2010_account_incoming_phone_number = out

        return res

    def update_key(self, request: operations.UpdateKeyRequest, security: operations.UpdateKeySecurity, server_url: Optional[str] = None) -> operations.UpdateKeyResponse:
        base_url = operations.UPDATE_KEY_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateKeyRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Keys/{Sid}.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateKeyResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountKey])
                res.api_v2010_account_key = out

        return res

    def update_member(self, request: operations.UpdateMemberRequest, security: operations.UpdateMemberSecurity, server_url: Optional[str] = None) -> operations.UpdateMemberResponse:
        r"""Dequeue a member from a queue and have the member's call begin executing the TwiML document at that URL"""
        base_url = operations.UPDATE_MEMBER_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateMemberRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Queues/{QueueSid}/Members/{CallSid}.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateMemberResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountQueueMember])
                res.api_v2010_account_queue_member = out

        return res

    def update_message(self, request: operations.UpdateMessageRequest, security: operations.UpdateMessageSecurity, server_url: Optional[str] = None) -> operations.UpdateMessageResponse:
        r"""To redact a message-body from a post-flight message record, post to the message instance resource with an empty body"""
        base_url = operations.UPDATE_MESSAGE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateMessageRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Messages/{Sid}.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateMessageResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountMessage])
                res.api_v2010_account_message = out

        return res

    def update_outgoing_caller_id(self, request: operations.UpdateOutgoingCallerIDRequest, security: operations.UpdateOutgoingCallerIDSecurity, server_url: Optional[str] = None) -> operations.UpdateOutgoingCallerIDResponse:
        r"""Updates the caller-id"""
        base_url = operations.UPDATE_OUTGOING_CALLER_ID_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateOutgoingCallerIDRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/OutgoingCallerIds/{Sid}.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateOutgoingCallerIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountOutgoingCallerID])
                res.api_v2010_account_outgoing_caller_id = out

        return res

    def update_participant(self, request: operations.UpdateParticipantRequest, security: operations.UpdateParticipantSecurity, server_url: Optional[str] = None) -> operations.UpdateParticipantResponse:
        r"""Update the properties of the participant"""
        base_url = operations.UPDATE_PARTICIPANT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateParticipantRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Participants/{CallSid}.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateParticipantResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountConferenceParticipant])
                res.api_v2010_account_conference_participant = out

        return res

    def update_payments(self, request: operations.UpdatePaymentsRequest, security: operations.UpdatePaymentsSecurity, server_url: Optional[str] = None) -> operations.UpdatePaymentsResponse:
        r"""update an instance of payments with different phases of payment flows."""
        base_url = operations.UPDATE_PAYMENTS_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdatePaymentsRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Payments/{Sid}.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdatePaymentsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 202:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountCallPayments])
                res.api_v2010_account_call_payments = out

        return res

    def update_queue(self, request: operations.UpdateQueueRequest, security: operations.UpdateQueueSecurity, server_url: Optional[str] = None) -> operations.UpdateQueueResponse:
        r"""Update the queue with the new parameters"""
        base_url = operations.UPDATE_QUEUE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateQueueRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Queues/{Sid}.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateQueueResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountQueue])
                res.api_v2010_account_queue = out

        return res

    def update_short_code(self, request: operations.UpdateShortCodeRequest, security: operations.UpdateShortCodeSecurity, server_url: Optional[str] = None) -> operations.UpdateShortCodeResponse:
        r"""Update a short code with the following parameters"""
        base_url = operations.UPDATE_SHORT_CODE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateShortCodeRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/SMS/ShortCodes/{Sid}.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateShortCodeResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountShortCode])
                res.api_v2010_account_short_code = out

        return res

    def update_signing_key(self, request: operations.UpdateSigningKeyRequest, security: operations.UpdateSigningKeySecurity, server_url: Optional[str] = None) -> operations.UpdateSigningKeyResponse:
        base_url = operations.UPDATE_SIGNING_KEY_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateSigningKeyRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/SigningKeys/{Sid}.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateSigningKeyResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountSigningKey])
                res.api_v2010_account_signing_key = out

        return res

    def update_sip_credential(self, request: operations.UpdateSipCredentialRequest, security: operations.UpdateSipCredentialSecurity, server_url: Optional[str] = None) -> operations.UpdateSipCredentialResponse:
        r"""Update a credential resource."""
        base_url = operations.UPDATE_SIP_CREDENTIAL_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateSipCredentialRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists/{CredentialListSid}/Credentials/{Sid}.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateSipCredentialResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountSipSipCredentialListSipCredential])
                res.api_v2010_account_sip_sip_credential_list_sip_credential = out

        return res

    def update_sip_credential_list(self, request: operations.UpdateSipCredentialListRequest, security: operations.UpdateSipCredentialListSecurity, server_url: Optional[str] = None) -> operations.UpdateSipCredentialListResponse:
        r"""Update a Credential List"""
        base_url = operations.UPDATE_SIP_CREDENTIAL_LIST_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateSipCredentialListRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists/{Sid}.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateSipCredentialListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountSipSipCredentialList])
                res.api_v2010_account_sip_sip_credential_list = out

        return res

    def update_sip_domain(self, request: operations.UpdateSipDomainRequest, security: operations.UpdateSipDomainSecurity, server_url: Optional[str] = None) -> operations.UpdateSipDomainResponse:
        r"""Update the attributes of a domain"""
        base_url = operations.UPDATE_SIP_DOMAIN_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateSipDomainRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{Sid}.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateSipDomainResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountSipSipDomain])
                res.api_v2010_account_sip_sip_domain = out

        return res

    def update_sip_ip_access_control_list(self, request: operations.UpdateSipIPAccessControlListRequest, security: operations.UpdateSipIPAccessControlListSecurity, server_url: Optional[str] = None) -> operations.UpdateSipIPAccessControlListResponse:
        r"""Rename an IpAccessControlList"""
        base_url = operations.UPDATE_SIP_IP_ACCESS_CONTROL_LIST_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateSipIPAccessControlListRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists/{Sid}.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateSipIPAccessControlListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountSipSipIPAccessControlList])
                res.api_v2010_account_sip_sip_ip_access_control_list = out

        return res

    def update_sip_ip_address(self, request: operations.UpdateSipIPAddressRequest, security: operations.UpdateSipIPAddressSecurity, server_url: Optional[str] = None) -> operations.UpdateSipIPAddressResponse:
        r"""Update an IpAddress resource."""
        base_url = operations.UPDATE_SIP_IP_ADDRESS_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateSipIPAddressRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists/{IpAccessControlListSid}/IpAddresses/{Sid}.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateSipIPAddressResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountSipSipIPAccessControlListSipIPAddress])
                res.api_v2010_account_sip_sip_ip_access_control_list_sip_ip_address = out

        return res

    def update_siprec(self, request: operations.UpdateSiprecRequest, security: operations.UpdateSiprecSecurity, server_url: Optional[str] = None) -> operations.UpdateSiprecResponse:
        r"""Stop a Siprec using either the SID of the Siprec resource or the `name` used when creating the resource"""
        base_url = operations.UPDATE_SIPREC_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateSiprecRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Siprec/{Sid}.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateSiprecResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountCallSiprec])
                res.api_v2010_account_call_siprec = out

        return res

    def update_stream(self, request: operations.UpdateStreamRequest, security: operations.UpdateStreamSecurity, server_url: Optional[str] = None) -> operations.UpdateStreamResponse:
        r"""Stop a Stream using either the SID of the Stream resource or the `name` used when creating the resource"""
        base_url = operations.UPDATE_STREAM_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateStreamRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Streams/{Sid}.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateStreamResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountCallStream])
                res.api_v2010_account_call_stream = out

        return res

    def update_usage_trigger(self, request: operations.UpdateUsageTriggerRequest, security: operations.UpdateUsageTriggerSecurity, server_url: Optional[str] = None) -> operations.UpdateUsageTriggerResponse:
        r"""Update an instance of a usage trigger"""
        base_url = operations.UPDATE_USAGE_TRIGGER_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateUsageTriggerRequest, base_url, '/2010-04-01/Accounts/{AccountSid}/Usage/Triggers/{Sid}.json', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateUsageTriggerResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIV2010AccountUsageUsageTrigger])
                res.api_v2010_account_usage_usage_trigger = out

        return res

    