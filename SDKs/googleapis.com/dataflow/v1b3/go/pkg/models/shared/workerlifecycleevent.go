// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
)

// WorkerLifecycleEventEventEnum - The event being reported.
type WorkerLifecycleEventEventEnum string

const (
	WorkerLifecycleEventEventEnumUnknownEvent               WorkerLifecycleEventEventEnum = "UNKNOWN_EVENT"
	WorkerLifecycleEventEventEnumOsStart                    WorkerLifecycleEventEventEnum = "OS_START"
	WorkerLifecycleEventEventEnumContainerStart             WorkerLifecycleEventEventEnum = "CONTAINER_START"
	WorkerLifecycleEventEventEnumNetworkUp                  WorkerLifecycleEventEventEnum = "NETWORK_UP"
	WorkerLifecycleEventEventEnumStagingFilesDownloadStart  WorkerLifecycleEventEventEnum = "STAGING_FILES_DOWNLOAD_START"
	WorkerLifecycleEventEventEnumStagingFilesDownloadFinish WorkerLifecycleEventEventEnum = "STAGING_FILES_DOWNLOAD_FINISH"
	WorkerLifecycleEventEventEnumSDKInstallStart            WorkerLifecycleEventEventEnum = "SDK_INSTALL_START"
	WorkerLifecycleEventEventEnumSDKInstallFinish           WorkerLifecycleEventEventEnum = "SDK_INSTALL_FINISH"
)

func (e WorkerLifecycleEventEventEnum) ToPointer() *WorkerLifecycleEventEventEnum {
	return &e
}

func (e *WorkerLifecycleEventEventEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "UNKNOWN_EVENT":
		fallthrough
	case "OS_START":
		fallthrough
	case "CONTAINER_START":
		fallthrough
	case "NETWORK_UP":
		fallthrough
	case "STAGING_FILES_DOWNLOAD_START":
		fallthrough
	case "STAGING_FILES_DOWNLOAD_FINISH":
		fallthrough
	case "SDK_INSTALL_START":
		fallthrough
	case "SDK_INSTALL_FINISH":
		*e = WorkerLifecycleEventEventEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for WorkerLifecycleEventEventEnum: %v", v)
	}
}

// WorkerLifecycleEvent - A report of an event in a worker's lifecycle. The proto contains one event, because the worker is expected to asynchronously send each message immediately after the event. Due to this asynchrony, messages may arrive out of order (or missing), and it is up to the consumer to interpret. The timestamp of the event is in the enclosing WorkerMessage proto.
type WorkerLifecycleEvent struct {
	// The start time of this container. All events will report this so that events can be grouped together across container/VM restarts.
	ContainerStartTime *string `json:"containerStartTime,omitempty"`
	// The event being reported.
	Event *WorkerLifecycleEventEventEnum `json:"event,omitempty"`
	// Other stats that can accompany an event. E.g. { "downloaded_bytes" : "123456" }
	Metadata map[string]string `json:"metadata,omitempty"`
}
