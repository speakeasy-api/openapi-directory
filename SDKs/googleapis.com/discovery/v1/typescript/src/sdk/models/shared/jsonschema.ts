/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import {
  objectToClass,
  SpeakeasyBase,
  SpeakeasyMetadata,
} from "../../../internal/utils";
import { Expose, Transform, Type } from "class-transformer";

/**
 * Additional information about this property.
 */
export class JsonSchemaAnnotations extends SpeakeasyBase {
  /**
   * A list of methods for which this property is required on requests.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "required" })
  required?: string[];
}

export class JsonSchemaVariantMap extends SpeakeasyBase {
  @SpeakeasyMetadata()
  @Expose({ name: "$ref" })
  dollarRef?: string;

  @SpeakeasyMetadata()
  @Expose({ name: "type_value" })
  typeValue?: string;
}

/**
 * In a variant data type, the value of one property is used to determine how to interpret the entire entity. Its value must exist in a map of descriminant values to schema names.
 */
export class JsonSchemaVariant extends SpeakeasyBase {
  /**
   * The name of the type discriminant property.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "discriminant" })
  discriminant?: string;

  /**
   * The map of discriminant value to schema to use for parsing..
   */
  @SpeakeasyMetadata({ elemType: JsonSchemaVariantMap })
  @Expose({ name: "map" })
  @Type(() => JsonSchemaVariantMap)
  map?: JsonSchemaVariantMap[];
}

export class JsonSchema extends SpeakeasyBase {
  /**
   * A reference to another schema. The value of this property is the "id" of another schema.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "$ref" })
  dollarRef?: string;

  @SpeakeasyMetadata()
  @Expose({ name: "additionalProperties" })
  @Type(() => JsonSchema)
  additionalProperties?: JsonSchema;

  /**
   * Additional information about this property.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "annotations" })
  @Type(() => JsonSchemaAnnotations)
  annotations?: JsonSchemaAnnotations;

  /**
   * A description of this object.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "description" })
  description?: string;

  /**
   * Values this parameter may take (if it is an enum).
   */
  @SpeakeasyMetadata()
  @Expose({ name: "enum" })
  enum?: string[];

  /**
   * The descriptions for the enums. Each position maps to the corresponding value in the "enum" array.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "enumDescriptions" })
  enumDescriptions?: string[];

  /**
   * An additional regular expression or key that helps constrain the value. For more details see: http://tools.ietf.org/html/draft-zyp-json-schema-03#section-5.23
   */
  @SpeakeasyMetadata()
  @Expose({ name: "format" })
  format?: string;

  /**
   * Unique identifier for this schema.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "id" })
  id?: string;

  @SpeakeasyMetadata()
  @Expose({ name: "items" })
  @Type(() => JsonSchema)
  items?: JsonSchema;

  /**
   * Whether this parameter goes in the query or the path for REST requests.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "location" })
  location?: string;

  /**
   * The maximum value of this parameter.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "maximum" })
  maximum?: string;

  /**
   * The minimum value of this parameter.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "minimum" })
  minimum?: string;

  /**
   * The regular expression this parameter must conform to. Uses Java 6 regex format: http://docs.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html
   */
  @SpeakeasyMetadata()
  @Expose({ name: "pattern" })
  pattern?: string;

  /**
   * If this is a schema for an object, list the schema for each property of this object.
   */
  @SpeakeasyMetadata({ elemType: JsonSchema })
  @Expose({ name: "properties" })
  @Transform(
    ({ value }) => {
      const obj: Record<string, JsonSchema> = {};
      for (const key in value) {
        obj[key] = objectToClass(value[key], JsonSchema);
      }
      return obj;
    },
    { toClassOnly: true }
  )
  properties?: Record<string, JsonSchema>;

  /**
   * The value is read-only, generated by the service. The value cannot be modified by the client. If the value is included in a POST, PUT, or PATCH request, it is ignored by the service.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "readOnly" })
  readOnly?: boolean;

  /**
   * Whether this parameter may appear multiple times.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "repeated" })
  repeated?: boolean;

  /**
   * Whether the parameter is required.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "required" })
  required?: boolean;

  /**
   * The value type for this schema. A list of values can be found here: http://tools.ietf.org/html/draft-zyp-json-schema-03#section-5.1
   */
  @SpeakeasyMetadata()
  @Expose({ name: "type" })
  type?: string;

  /**
   * In a variant data type, the value of one property is used to determine how to interpret the entire entity. Its value must exist in a map of descriminant values to schema names.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "variant" })
  @Type(() => JsonSchemaVariant)
  variant?: JsonSchemaVariant;
}
