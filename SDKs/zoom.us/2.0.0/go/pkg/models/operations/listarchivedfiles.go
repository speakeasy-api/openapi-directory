// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"fmt"
	"net/http"
)

// ListArchivedFilesQueryDataTypeEnum - Query data type for `from` and `to`.
type ListArchivedFilesQueryDataTypeEnum string

const (
	ListArchivedFilesQueryDataTypeEnumMeetingStartTime    ListArchivedFilesQueryDataTypeEnum = "meeting_start_time"
	ListArchivedFilesQueryDataTypeEnumArchiveCompleteTime ListArchivedFilesQueryDataTypeEnum = "archive_complete_time"
)

func (e *ListArchivedFilesQueryDataTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "meeting_start_time":
		fallthrough
	case "archive_complete_time":
		*e = ListArchivedFilesQueryDataTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for ListArchivedFilesQueryDataTypeEnum: %s", s)
	}
}

type ListArchivedFilesRequest struct {
	// Start date for the query in "yyyy-MM-dd'T'HH:mm:ss'Z'" format. The duration for the query defined using the "from" and "to" parameters should not exceed 7 days as this API only provides a week's data at once.
	From *string `queryParam:"style=form,explode=true,name=from"`
	// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
	NextPageToken *string `queryParam:"style=form,explode=true,name=next_page_token"`
	// The number of records returned within a single API call.
	PageSize *int64 `queryParam:"style=form,explode=true,name=page_size"`
	// Query data type for `from` and `to`.
	QueryDataType *ListArchivedFilesQueryDataTypeEnum `queryParam:"style=form,explode=true,name=query_data_type"`
	// End date for the query in "yyyy-MM-dd'T'HH:mm:ss'Z'" format.
	To *string `queryParam:"style=form,explode=true,name=to"`
}

type ListArchivedFiles200ApplicationXMLMeetingsArchiveFiles struct {
	// The URL using which the archived file can be downloaded. To download the archived file of a meeting or a webinar hosted in your account, create a [Zoom JWT App Type](https://marketplace.zoom.us/docs/guides/getting-started/app-types/create-jwt-app). Use the generated JWT token as the value of the access_token query parameter and include this query parameter at the end of the URL as shown in the example.
	//
	// Example: `https://{{base-domain}}/rec/archive/download/xxx?access_token={{Your-JWT}}`
	//
	// If a user has authorized and installed your OAuth app that supports archiving, use the user’s [OAuth access token](https://marketplace.zoom.us/docs/guides/auth/oauth) to download the file.
	//
	// Example: `https://{{base-domain}}/rec/archive/download/xxx?access_token={{ OAuth Access Token }}`
	DownloadURL *string
	// Extension of the recording file.
	//
	FileExtension *string
	// The recording file size.
	//
	FileSize *int64
	// Recorded file type. The value of this field could be one of the following:
	//
	// `MP4`: Video file of the recording.<br>
	// `M4A`: Audio-only file of the recording.<br>
	// `TRANSCRIPT`: Transcription file of the recording in VTT format.
	// CHAT: A TXT file containing in-meeting chat messages that were sent during the meeting.<br>
	// `CC`: File containing closed captions of the recording in VTT file format.<br>
	// `CSV`: File containing polling data in csv format.
	FileType *string
	// Unique identifier of the archived file.
	//
	ID *string
	// The recording type. The value of this field can be one of the following:
	// * `shared_screen_with_speaker_view(CC)`
	// * `shared_screen_with_speaker_view`
	// * `shared_screen_with_gallery_view`
	// * `speaker_view`
	// * `gallery_view`
	// * `shared_screen`
	// * `audio_only`
	// * `audio_transcript`
	// * `chat_file`,
	// * `active_speaker`
	// * `host_video`
	//
	RecordingType *string
	// Status of the archived file.
	//
	Status *string
}

type ListArchivedFiles200ApplicationXMLMeetings struct {
	ArchiveFiles []ListArchivedFiles200ApplicationXMLMeetingsArchiveFiles
	// Scheduled duration of the meeting or the webinar.
	Duration *int64
	// ID of the user set as the host of meeting or the webinar that was archived.
	//
	HostID *string
	// Unique identifier of the meeting(meetingId) or the webinar(webinarId).
	//
	ID *int64
	// Number of recording files returned in the response of this API call.
	//
	RecordingCount *int64
	// The time at which the meeting or the webinar started.
	//
	StartTime *string
	// Timezone of the host.
	Timezone *string
	// Meeting or webinar topic.
	Topic *string
	// Total size of the archive.
	//
	TotalSize *int64
	// Type of the meeting or the webinar that was archived.<br>
	// <br>Meeting types:<br>
	// `1` - Instant meeting<br>
	// `2` - Scheduled meeting<br>
	// `3` - Recurring meeting with no fixed time<br>
	// 8 - Recurring meeting with fixed time
	//
	// Webinar types:<br>
	// `5` - Webinar<br>
	// `6` - Recurring webinar with no fixed time<br>
	// `9` - Recurring webinar with a fixed time
	//
	Type *int64
	// Unique identifier of the meeting instance or the webinar instance during which the archiving took place. Each instance of the meeting will have its own UUID.
	//
	UUID *string
}

// ListArchivedFiles200ApplicationXML - **HTTP Status Code:** `200` **OK**
// Archived files returned.
type ListArchivedFiles200ApplicationXML struct {
	// Start date for the query in "yyyy-MM-dd'T'HH:mm:ss'Z'" format. The duration for the query defined using the "from" and "to" parameters should not exceed 7 days as this API only provides a week's data at once.
	From     *string
	Meetings []ListArchivedFiles200ApplicationXMLMeetings
	// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
	NextPageToken *string
	// The number of records returned within a single API call.
	PageSize *int64
	// End date for the query in "yyyy-MM-dd'T'HH:mm:ss'Z'" format.
	To *string
}

type ListArchivedFiles200ApplicationJSONMeetingsArchiveFiles struct {
	// The URL using which the archived file can be downloaded. To download the archived file of a meeting or a webinar hosted in your account, create a [Zoom JWT App Type](https://marketplace.zoom.us/docs/guides/getting-started/app-types/create-jwt-app). Use the generated JWT token as the value of the access_token query parameter and include this query parameter at the end of the URL as shown in the example.
	//
	// Example: `https://{{base-domain}}/rec/archive/download/xxx?access_token={{Your-JWT}}`
	//
	// If a user has authorized and installed your OAuth app that supports archiving, use the user’s [OAuth access token](https://marketplace.zoom.us/docs/guides/auth/oauth) to download the file.
	//
	// Example: `https://{{base-domain}}/rec/archive/download/xxx?access_token={{ OAuth Access Token }}`
	DownloadURL *string `json:"download_url,omitempty"`
	// Extension of the recording file.
	//
	FileExtension *string `json:"file_extension,omitempty"`
	// The recording file size.
	//
	FileSize *int64 `json:"file_size,omitempty"`
	// Recorded file type. The value of this field could be one of the following:
	//
	// `MP4`: Video file of the recording.<br>
	// `M4A`: Audio-only file of the recording.<br>
	// `TRANSCRIPT`: Transcription file of the recording in VTT format.
	// CHAT: A TXT file containing in-meeting chat messages that were sent during the meeting.<br>
	// `CC`: File containing closed captions of the recording in VTT file format.<br>
	// `CSV`: File containing polling data in csv format.
	FileType *string `json:"file_type,omitempty"`
	// Unique identifier of the archived file.
	//
	ID *string `json:"id,omitempty"`
	// The recording type. The value of this field can be one of the following:
	// * `shared_screen_with_speaker_view(CC)`
	// * `shared_screen_with_speaker_view`
	// * `shared_screen_with_gallery_view`
	// * `speaker_view`
	// * `gallery_view`
	// * `shared_screen`
	// * `audio_only`
	// * `audio_transcript`
	// * `chat_file`,
	// * `active_speaker`
	// * `host_video`
	//
	RecordingType *string `json:"recording_type,omitempty"`
	// Status of the archived file.
	//
	Status *string `json:"status,omitempty"`
}

type ListArchivedFiles200ApplicationJSONMeetings struct {
	ArchiveFiles []ListArchivedFiles200ApplicationJSONMeetingsArchiveFiles `json:"archive_files,omitempty"`
	// Scheduled duration of the meeting or the webinar.
	Duration *int64 `json:"duration,omitempty"`
	// ID of the user set as the host of meeting or the webinar that was archived.
	//
	HostID *string `json:"host_id,omitempty"`
	// Unique identifier of the meeting(meetingId) or the webinar(webinarId).
	//
	ID *int64 `json:"id,omitempty"`
	// Number of recording files returned in the response of this API call.
	//
	RecordingCount *int64 `json:"recording_count,omitempty"`
	// The time at which the meeting or the webinar started.
	//
	StartTime *string `json:"start_time,omitempty"`
	// Timezone of the host.
	Timezone *string `json:"timezone,omitempty"`
	// Meeting or webinar topic.
	Topic *string `json:"topic,omitempty"`
	// Total size of the archive.
	//
	TotalSize *int64 `json:"total_size,omitempty"`
	// Type of the meeting or the webinar that was archived.<br>
	// <br>Meeting types:<br>
	// `1` - Instant meeting<br>
	// `2` - Scheduled meeting<br>
	// `3` - Recurring meeting with no fixed time<br>
	// 8 - Recurring meeting with fixed time
	//
	// Webinar types:<br>
	// `5` - Webinar<br>
	// `6` - Recurring webinar with no fixed time<br>
	// `9` - Recurring webinar with a fixed time
	//
	Type *int64 `json:"type,omitempty"`
	// Unique identifier of the meeting instance or the webinar instance during which the archiving took place. Each instance of the meeting will have its own UUID.
	//
	UUID *string `json:"uuid,omitempty"`
}

// ListArchivedFiles200ApplicationJSON - **HTTP Status Code:** `200` **OK**
// Archived files returned.
type ListArchivedFiles200ApplicationJSON struct {
	// Start date for the query in "yyyy-MM-dd'T'HH:mm:ss'Z'" format. The duration for the query defined using the "from" and "to" parameters should not exceed 7 days as this API only provides a week's data at once.
	From     *string                                       `json:"from,omitempty"`
	Meetings []ListArchivedFiles200ApplicationJSONMeetings `json:"meetings,omitempty"`
	// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
	NextPageToken *string `json:"next_page_token,omitempty"`
	// The number of records returned within a single API call.
	PageSize *int64 `json:"page_size,omitempty"`
	// End date for the query in "yyyy-MM-dd'T'HH:mm:ss'Z'" format.
	To *string `json:"to,omitempty"`
}

type ListArchivedFilesResponse struct {
	Body        []byte
	ContentType string
	StatusCode  int
	RawResponse *http.Response
	// **HTTP Status Code:** `200` **OK**
	// Archived files returned.
	//
	ListArchivedFiles200ApplicationJSONObject *ListArchivedFiles200ApplicationJSON
}
