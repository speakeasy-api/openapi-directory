"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Optional

class Ee:
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def assign_msisdn(self, request: operations.AssignMsisdnRequest, security: operations.AssignMsisdnSecurity) -> operations.AssignMsisdnResponse:
        r"""Assigns a msisdn to a profile on ITV side."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/ee/msisdn'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "itv_assign_msisdn_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        query_params = utils.get_query_params(operations.AssignMsisdnRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AssignMsisdnResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [201, 401]:
            pass
        elif http_res.status_code == 500:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def check_ee_bt_eligibility(self, request: operations.CheckEeBtEligibilityRequest, security: operations.CheckEeBtEligibilitySecurity) -> operations.CheckEeBtEligibilityResponse:
        r"""Check whether or not a user is eligible for switching to Bt or EE offers."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/ee-bt/eligibility'
        
        query_params = utils.get_query_params(operations.CheckEeBtEligibilityRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CheckEeBtEligibilityResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.EeBtEligibility])
                res.ee_bt_eligibility = out
        elif http_res.status_code == 406:
            pass

        return res

    def create_pin_request(self, request: operations.CreatePinRequestRequest) -> operations.CreatePinRequestResponse:
        r"""Creates a PIN request that will send an SMS to the given msisdn.
        This call is to validate MSISDN entered by a user not comming through EE network.
        This call should be followed by POST ee/pin.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/ee/pin'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "ee_create_pin_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        query_params = utils.get_query_params(operations.CreatePinRequestRequest, request)
        
        client = self._client
        
        http_res = client.request('PUT', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreatePinRequestResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.EeCreatePinResponse])
                res.ee_create_pin_response = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def create_token(self) -> operations.CreateTokenResponse:
        r"""Returns a token for later calls to EE API. TTL is one hour. Recommended is FE refreshes this token before each call."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/ee/token/create'
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateTokenResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.EeCreateTokenResponse])
                res.ee_create_token_response = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def get_eligible_offers(self, request: operations.GetEligibleOffersRequest) -> operations.GetEligibleOffersResponse:
        r"""Returns eligible partner specific offers for the querying partner for an EE MSISDN.
        This call is supposed to be called after we have MSISDN accired.
        This call should be followed by POST /ee/msisdn.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/ee/offers'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "ee_offers_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        query_params = utils.get_query_params(operations.GetEligibleOffersRequest, request)
        
        client = self._client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetEligibleOffersResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.EeOffersResponse])
                res.ee_offers_response = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def get_plan(self, request: operations.GetPlanRequest) -> operations.GetPlanResponse:
        r"""Returns the plan description for EE flow including additional description data."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetPlanRequest, base_url, '/ee/plans/{id}', request)
        
        query_params = utils.get_query_params(operations.GetPlanRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetPlanResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.EePlanListItem])
                res.ee_plan_list_item = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def get_ee_plans(self, request: operations.GetEePlansRequest) -> operations.GetEePlansResponse:
        r"""Returns all the plans available for EE flow including additional description data."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/ee/plans'
        
        query_params = utils.get_query_params(operations.GetEePlansRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetEePlansResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.EePlans])
                res.ee_plans = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def validate_pin_request(self, request: operations.ValidatePinRequestRequest) -> operations.ValidatePinRequestResponse:
        r"""Validate PIN request created by calling POST /ee/pin This call is to validate MSISDN entered by a user not comming through EE network. This call should be called after PUT /ee/pin. This call should be followed by POST /ee/offers."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/ee/pin'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "ee_validate_pin_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        query_params = utils.get_query_params(operations.ValidatePinRequestRequest, request)
        
        client = self._client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ValidatePinRequestResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.EeValidatePinResponse])
                res.ee_validate_pin_response = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    