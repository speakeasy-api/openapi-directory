<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class RootVmwareVcenter 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * Refresh vCenter Server metadata
     * 
     * Create a job to refresh the metadata for the specified vCenter Server.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateRefreshRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateRefreshResponse
     */
	public function createRefresh(
        \OpenAPI\OpenAPI\Models\Operations\CreateRefreshRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateRefreshResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/vmware/vcenter/{id}/refresh', \OpenAPI\OpenAPI\Models\Operations\CreateRefreshRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateRefreshResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 202) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->asyncRequestStatus = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AsyncRequestStatus', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Refresh single virtual machine metadata in a vcenter
     * 
     * Refresh the metadata for a single virtual machine controlled by vCenter.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateRefreshVmV1Request $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateRefreshVmV1Response
     */
	public function createRefreshVmV1(
        \OpenAPI\OpenAPI\Models\Operations\CreateRefreshVmV1Request $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateRefreshVmV1Response
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/vmware/vcenter/{id}/refresh_vm', \OpenAPI\OpenAPI\Models\Operations\CreateRefreshVmV1Request::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "string");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateRefreshVmV1Response();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
	
    /**
     * Add vCenter Server
     * 
     * (DEPRECATED) Create a vCenter Server object by providing the address and account credentials of the vCenter Server. Initiates an asynchronous job to establish a connection with the vCenter Server and retrieve all metadata. Use GET /vcenter/{id}/status to check status. The recommended endpoint is /v2/vmware/vcenter. This endpoint will remain available in future releases despite deprecation.
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\VcenterConfig $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateVcenterResponse
     */
	public function createVcenter(
        \OpenAPI\OpenAPI\Models\Shared\VcenterConfig $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateVcenterResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/vmware/vcenter');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateVcenterResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 202) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->asyncRequestStatus = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AsyncRequestStatus', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Remove vCenter Server
     * 
     * Initiates an asynchronous job to remove a vCenter Server object. The vCenter Server cannot have VMs mounted through the Rubrik cluster.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteVcenterRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteVcenterResponse
     */
	public function deleteVcenter(
        \OpenAPI\OpenAPI\Models\Operations\DeleteVcenterRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteVcenterResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/vmware/vcenter/{id}', \OpenAPI\OpenAPI\Models\Operations\DeleteVcenterRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteVcenterResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 202) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->asyncRequestStatus = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AsyncRequestStatus', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get the ingest and export bandwidth limits for HotAdd with the vCenter
     * 
     * Get the ingest and export bandwidth limits in Mbps when using HotAdd with the vCenter. These limits are shared across all HotAdd proxies for the Center.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetHotAddBandwidthRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetHotAddBandwidthResponse
     */
	public function getHotAddBandwidth(
        \OpenAPI\OpenAPI\Models\Operations\GetHotAddBandwidthRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetHotAddBandwidthResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/vmware/vcenter/{id}/hotadd/bandwidth', \OpenAPI\OpenAPI\Models\Operations\GetHotAddBandwidthRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetHotAddBandwidthResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->hotAddBandwidthInfo = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\HotAddBandwidthInfo', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Retrieve the user-configured network for HotAdd operations
     * 
     * Retrieve the user-configured network for HotAdd backup and recovery operations on VMware on AWS.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetHotAddNetworkRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetHotAddNetworkResponse
     */
	public function getHotAddNetwork(
        \OpenAPI\OpenAPI\Models\Operations\GetHotAddNetworkRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetHotAddNetworkResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/vmware/vcenter/{id}/hotadd/network', \OpenAPI\OpenAPI\Models\Operations\GetHotAddNetworkRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetHotAddNetworkResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->hotAddNetworkConfigWithName = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\HotAddNetworkConfigWithName', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get the user-configured networks in the vCenter
     * 
     * Get the names and IDs of the user configured networks in the vCenter. This information enables users to choose a desired network for backups to go through for VMware Cloud on AWS setups.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetNetworksRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNetworksResponse
     */
	public function getNetworks(
        \OpenAPI\OpenAPI\Models\Operations\GetNetworksRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetNetworksResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/vmware/vcenter/{id}/networks', \OpenAPI\OpenAPI\Models\Operations\GetNetworksRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNetworksResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->networkInfoListResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\NetworkInfoListResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get the number of HotAdd proxies needed for the vCenter
     * 
     * Get the number of HotAdd proxies that need to be deployed to the vCenter to support the maximum number of ingest jobs.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetNumProxiesNeededRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNumProxiesNeededResponse
     */
	public function getNumProxiesNeeded(
        \OpenAPI\OpenAPI\Models\Operations\GetNumProxiesNeededRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetNumProxiesNeededResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/vmware/vcenter/{id}/hotadd/needed', \OpenAPI\OpenAPI\Models\Operations\GetNumProxiesNeededRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNumProxiesNeededResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->hotAddProxiesNeededInfo = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\HotAddProxiesNeededInfo', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get the details of a vCenter Server
     * 
     * Retrieve detailed information for a vCenter Server object.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetVcenterRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetVcenterResponse
     */
	public function getVcenter(
        \OpenAPI\OpenAPI\Models\Operations\GetVcenterRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetVcenterResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/vmware/vcenter/{id}', \OpenAPI\OpenAPI\Models\Operations\GetVcenterRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetVcenterResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->vcenterDetail = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\VcenterDetail', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get vCenter Server async request
     * 
     * Get details about a vcenter related async request.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetVcenterAsyncRequestStatusRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetVcenterAsyncRequestStatusResponse
     */
	public function getVcenterAsyncRequestStatus(
        \OpenAPI\OpenAPI\Models\Operations\GetVcenterAsyncRequestStatusRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetVcenterAsyncRequestStatusResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/vmware/vcenter/request/{id}', \OpenAPI\OpenAPI\Models\Operations\GetVcenterAsyncRequestStatusRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetVcenterAsyncRequestStatusResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->asyncRequestStatus = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AsyncRequestStatus', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update the SLA Domain for a vCenter Server
     * 
     * Update the SLA Domain that is configured for a vCenter Server.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PatchVcenterRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PatchVcenterResponse
     */
	public function patchVcenter(
        \OpenAPI\OpenAPI\Models\Operations\PatchVcenterRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PatchVcenterResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/vmware/vcenter/{id}', \OpenAPI\OpenAPI\Models\Operations\PatchVcenterRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "vcenterPatch", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PatchVcenterResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->vcenterSummary = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\VcenterSummary', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get a list of HotAdd proxy virtual machines
     * 
     * Retrieve summary information for all HotAdd proxy virtual machines.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\QueryHotAddProxyVmRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\QueryHotAddProxyVmResponse
     */
	public function queryHotAddProxyVm(
        \OpenAPI\OpenAPI\Models\Operations\QueryHotAddProxyVmRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\QueryHotAddProxyVmResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/vmware/vcenter/hotadd/vm');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\QueryHotAddProxyVmRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\QueryHotAddProxyVmResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->hotAddProxyVmInfoListResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\HotAddProxyVmInfoListResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get list of vCenters
     * 
     * Retrieve information for each managed vCenter, including: ID, managed ID, address, username, SLA ID, and primary cluster ID.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\QueryVcenterRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\QueryVcenterResponse
     */
	public function queryVcenter(
        \OpenAPI\OpenAPI\Models\Operations\QueryVcenterRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\QueryVcenterResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/vmware/vcenter');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\QueryVcenterRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\QueryVcenterResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->vcenterSummaryListResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\VcenterSummaryListResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Set the ingest and export bandwidth limits for HotAdd with the vCenter
     * 
     * Set the ingest and export bandwidth limits in Mbps when using HotAdd with the vCenter. These limits are shared across all HotAdd proxies for the Center.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\SetHotAddBandwidthRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\SetHotAddBandwidthResponse
     */
	public function setHotAddBandwidth(
        \OpenAPI\OpenAPI\Models\Operations\SetHotAddBandwidthRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\SetHotAddBandwidthResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/vmware/vcenter/{id}/hotadd/bandwidth', \OpenAPI\OpenAPI\Models\Operations\SetHotAddBandwidthRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "hotAddBandwidthInfo", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SetHotAddBandwidthResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
	
    /**
     * Set the user-configured network for HotAdd backup and recovery
     * 
     * Set the user-configured network for HotAdd backup and recovery operations on VMware on AWS.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\SetHotAddNetworkRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\SetHotAddNetworkResponse
     */
	public function setHotAddNetwork(
        \OpenAPI\OpenAPI\Models\Operations\SetHotAddNetworkRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\SetHotAddNetworkResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/vmware/vcenter/{id}/hotadd/network', \OpenAPI\OpenAPI\Models\Operations\SetHotAddNetworkRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "hotAddNetworkConfigWithId", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SetHotAddNetworkResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
	
    /**
     * Update vCenter Server
     * 
     * Update the address, username and password of the specified vCenter Server object.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateVcenterRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateVcenterResponse
     */
	public function updateVcenter(
        \OpenAPI\OpenAPI\Models\Operations\UpdateVcenterRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateVcenterResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/vmware/vcenter/{id}', \OpenAPI\OpenAPI\Models\Operations\UpdateVcenterRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "vcenterConfig", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateVcenterResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->vcenterSummary = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\VcenterSummary', 'json');
            }
        }

        return $response;
    }
}