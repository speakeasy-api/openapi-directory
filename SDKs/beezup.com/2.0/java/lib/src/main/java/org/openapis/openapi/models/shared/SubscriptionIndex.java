/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package org.openapis.openapi.models.shared;

import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import java.time.OffsetDateTime;
import org.openapis.openapi.utils.DateTimeDeserializer;
import org.openapis.openapi.utils.DateTimeSerializer;

/**
 * SubscriptionIndex - The subscription definition
 */
public class SubscriptionIndex {
    /**
     * The subscription consumption status
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("consumerHealthStatus")
    public ConsumptionAvailabilityStatusEnum consumerHealthStatus;

    public SubscriptionIndex withConsumerHealthStatus(ConsumptionAvailabilityStatusEnum consumerHealthStatus) {
        this.consumerHealthStatus = consumerHealthStatus;
        return this;
    }
    
    /**
     * The URL &lt;a href="https://en.wikipedia.org/wiki/URL"&gt;https://en.wikipedia.org/wiki/URL&lt;/a&gt;
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("consumerLastRequestSentUri")
    public String consumerLastRequestSentUri;

    public SubscriptionIndex withConsumerLastRequestSentUri(String consumerLastRequestSentUri) {
        this.consumerLastRequestSentUri = consumerLastRequestSentUri;
        return this;
    }
    
    /**
     * This date indicates since when the subscription consumer is unavailable
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonSerialize(using = DateTimeSerializer.class)
    @JsonDeserialize(using = DateTimeDeserializer.class)
    @JsonProperty("consumerUnvailableSinceUtcDate")
    public OffsetDateTime consumerUnvailableSinceUtcDate;

    public SubscriptionIndex withConsumerUnvailableSinceUtcDate(OffsetDateTime consumerUnvailableSinceUtcDate) {
        this.consumerUnvailableSinceUtcDate = consumerUnvailableSinceUtcDate;
        return this;
    }
    
    /**
     * The identifier of the subscription to the orders for a merchant
     */
    @JsonProperty("id")
    public String id;

    public SubscriptionIndex withId(String id) {
        this.id = id;
        return this;
    }
    
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("lastErrorMessage")
    public ErrorResponseMessage lastErrorMessage;

    public SubscriptionIndex withLastErrorMessage(ErrorResponseMessage lastErrorMessage) {
        this.lastErrorMessage = lastErrorMessage;
        return this;
    }
    
    /**
     * This modification date correspond to the last order pushed by your subscription consumer
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonSerialize(using = DateTimeSerializer.class)
    @JsonDeserialize(using = DateTimeDeserializer.class)
    @JsonProperty("lastOrderPushedModificationUtcDate")
    public OffsetDateTime lastOrderPushedModificationUtcDate;

    public SubscriptionIndex withLastOrderPushedModificationUtcDate(OffsetDateTime lastOrderPushedModificationUtcDate) {
        this.lastOrderPushedModificationUtcDate = lastOrderPushedModificationUtcDate;
        return this;
    }
    
    /**
     * The last date we retry to send orders
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonSerialize(using = DateTimeSerializer.class)
    @JsonDeserialize(using = DateTimeDeserializer.class)
    @JsonProperty("lastRetryUtcDate")
    public OffsetDateTime lastRetryUtcDate;

    public SubscriptionIndex withLastRetryUtcDate(OffsetDateTime lastRetryUtcDate) {
        this.lastRetryUtcDate = lastRetryUtcDate;
        return this;
    }
    
    /**
     * The date of the last pushed order successfully received by your subscription consumer
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonSerialize(using = DateTimeSerializer.class)
    @JsonDeserialize(using = DateTimeDeserializer.class)
    @JsonProperty("lastSuccessfulOrderPushedUtcDate")
    public OffsetDateTime lastSuccessfulOrderPushedUtcDate;

    public SubscriptionIndex withLastSuccessfulOrderPushedUtcDate(OffsetDateTime lastSuccessfulOrderPushedUtcDate) {
        this.lastSuccessfulOrderPushedUtcDate = lastSuccessfulOrderPushedUtcDate;
        return this;
    }
    
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("links")
    public SubscriptionLinks links;

    public SubscriptionIndex withLinks(SubscriptionLinks links) {
        this.links = links;
        return this;
    }
    
    /**
     * The maximum BeezUP will retry to push orders. When we the retry count will reach maximum retry count, the subscription will be deactivated.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("maxRetryCount")
    public Long maxRetryCount;

    public SubscriptionIndex withMaxRetryCount(Long maxRetryCount) {
        this.maxRetryCount = maxRetryCount;
        return this;
    }
    
    /**
     * The name of your application
     */
    @JsonProperty("merchantApplicationName")
    public String merchantApplicationName;

    public SubscriptionIndex withMerchantApplicationName(String merchantApplicationName) {
        this.merchantApplicationName = merchantApplicationName;
        return this;
    }
    
    /**
     * The version of your application
     */
    @JsonProperty("merchantApplicationVersion")
    public String merchantApplicationVersion;

    public SubscriptionIndex withMerchantApplicationVersion(String merchantApplicationVersion) {
        this.merchantApplicationVersion = merchantApplicationVersion;
        return this;
    }
    
    /**
     * The email
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("merchantEmailAlert")
    public String merchantEmailAlert;

    public SubscriptionIndex withMerchantEmailAlert(String merchantEmailAlert) {
        this.merchantEmailAlert = merchantEmailAlert;
        return this;
    }
    
    /**
     * The subscription name you want to use
     */
    @JsonProperty("name")
    public String name;

    public SubscriptionIndex withName(String name) {
        this.name = name;
        return this;
    }
    
    /**
     * The next scheduled  date we retry to send orders
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonSerialize(using = DateTimeSerializer.class)
    @JsonDeserialize(using = DateTimeDeserializer.class)
    @JsonProperty("nextScheduledRetryUtcDate")
    public OffsetDateTime nextScheduledRetryUtcDate;

    public SubscriptionIndex withNextScheduledRetryUtcDate(OffsetDateTime nextScheduledRetryUtcDate) {
        this.nextScheduledRetryUtcDate = nextScheduledRetryUtcDate;
        return this;
    }
    
    /**
     * Recover existing orders using the begin period order last modification date. If not set then you will receive new/updated orders in real-time.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonSerialize(using = DateTimeSerializer.class)
    @JsonDeserialize(using = DateTimeDeserializer.class)
    @JsonProperty("recoverBeginPeriodOrderLastModificationUtcDate")
    public OffsetDateTime recoverBeginPeriodOrderLastModificationUtcDate;

    public SubscriptionIndex withRecoverBeginPeriodOrderLastModificationUtcDate(OffsetDateTime recoverBeginPeriodOrderLastModificationUtcDate) {
        this.recoverBeginPeriodOrderLastModificationUtcDate = recoverBeginPeriodOrderLastModificationUtcDate;
        return this;
    }
    
    /**
     * Recover existing orders using the begin and the end period order last modification date.
     * Otherwise, you will receive new/updated orders in real-time.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonSerialize(using = DateTimeSerializer.class)
    @JsonDeserialize(using = DateTimeDeserializer.class)
    @JsonProperty("recoverEndPeriodOrderLastModificationUtcDate")
    public OffsetDateTime recoverEndPeriodOrderLastModificationUtcDate;

    public SubscriptionIndex withRecoverEndPeriodOrderLastModificationUtcDate(OffsetDateTime recoverEndPeriodOrderLastModificationUtcDate) {
        this.recoverEndPeriodOrderLastModificationUtcDate = recoverEndPeriodOrderLastModificationUtcDate;
        return this;
    }
    
    /**
     * The retry count. When we the retry count will reach maximum retry count, the subscription will be deactivated.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("retryCount")
    public Long retryCount;

    public SubscriptionIndex withRetryCount(Long retryCount) {
        this.retryCount = retryCount;
        return this;
    }
    
    /**
     * The status of your subscription
     */
    @JsonProperty("status")
    public SubscriptionStatusEnum status;

    public SubscriptionIndex withStatus(SubscriptionStatusEnum status) {
        this.status = status;
        return this;
    }
    
    /**
     * The URL &lt;a href="https://en.wikipedia.org/wiki/URL"&gt;https://en.wikipedia.org/wiki/URL&lt;/a&gt;
     */
    @JsonProperty("targetUrl")
    public String targetUrl;

    public SubscriptionIndex withTargetUrl(String targetUrl) {
        this.targetUrl = targetUrl;
        return this;
    }
    
    public SubscriptionIndex(@JsonProperty("id") String id, @JsonProperty("merchantApplicationName") String merchantApplicationName, @JsonProperty("merchantApplicationVersion") String merchantApplicationVersion, @JsonProperty("name") String name, @JsonProperty("status") SubscriptionStatusEnum status, @JsonProperty("targetUrl") String targetUrl) {
        this.id = id;
        this.merchantApplicationName = merchantApplicationName;
        this.merchantApplicationVersion = merchantApplicationVersion;
        this.name = name;
        this.status = status;
        this.targetUrl = targetUrl;
  }
}
