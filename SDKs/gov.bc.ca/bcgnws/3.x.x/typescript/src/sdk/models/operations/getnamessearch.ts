/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { SpeakeasyBase, SpeakeasyMetadata } from "../../../internal/utils";
import { AxiosResponse } from "axios";

/**
 * A flag to indicate whether to embed the corresponding 'feature' into each matching name
 */
export enum GetNamesSearchEmbedEnum {
  Zero = "0",
  One = "1",
}

/**
 * If the 'name' parameter is specified, 'exactSpelling' specifies whether to include only names that exactly match the search text (exactSpelling=1), or whether to also include names with similar spellings (exactSpelling=0)
 */
export enum GetNamesSearchExactSpellingEnum {
  Zero = "0",
  One = "1",
}

/**
 * The format of the output.
 */
export enum GetNamesSearchOutputFormatEnum {
  Json = "json",
  Xml = "xml",
  Kml = "kml",
  Csv = "csv",
}

/**
 * The EPSG code of the spatial reference system (SRS) to use for output geometries.
 */
export enum GetNamesSearchOutputSrsEnum {
  FourThousandThreeHundredAndTwentySix = "4326",
  FourThousandTwoHundredAndSixtyNine = "4269",
  ThreeThousandAndFive = "3005",
  ThreeThousandEightHundredAndFiftySeven = "3857",
  TwentySixThousandNineHundredAndSeven = "26907",
  TwentySixThousandNineHundredAndEight = "26908",
  TwentySixThousandNineHundredAndNine = "26909",
  TwentySixThousandNineHundredAndTen = "26910",
  TwentySixThousandNineHundredAndEleven = "26911",
}

/**
 * A flag indicating whether to include with each matching name a succinct list of attributes (summary), or a comprehensive list of attributes (detail)
 */
export enum GetNamesSearchOutputStyleEnum {
  Summary = "summary",
  Detail = "detail",
}

/**
 * The distance to move the accessPoint away from the curb and towards the inside of the parcel (in metres). Ignored if locationDescriptor not set to accessPoint.
 */
export enum GetNamesSearchSortByEnum {
  Relevance = "relevance",
  Name = "name",
  FeatureType = "featureType",
  DecisionDate = "decisionDate",
}

export class GetNamesSearchRequest extends SpeakeasyBase {
  /**
   * A flag to indicate whether to embed the corresponding 'feature' into each matching name
   */
  @SpeakeasyMetadata({ data: "queryParam, style=form;explode=true;name=embed" })
  embed?: GetNamesSearchEmbedEnum;

  /**
   * If the 'name' parameter is specified, 'exactSpelling' specifies whether to include only names that exactly match the search text (exactSpelling=1), or whether to also include names with similar spellings (exactSpelling=0)
   */
  @SpeakeasyMetadata({
    data: "queryParam, style=form;explode=true;name=exactSpelling",
  })
  exactSpelling?: GetNamesSearchExactSpellingEnum;

  /**
   * A filter to limit the search to names associated with features of a certain 'category'  The value of this parameter should be a 'featureCategoryCode' value returned by the /featureCategories resource, or an asterisk (*) to request that all feature categories be included.
   */
  @SpeakeasyMetadata({
    data: "queryParam, style=form;explode=true;name=featureCategory",
  })
  featureCategory?: string;

  /**
   * A filter to limit the search to names associated with features of a certain 'class'  The value of this parameter should be a 'featureClassCode' value returned by the /featureClasses resource, or an asterisk (*) to request that all feature classes be included.
   */
  @SpeakeasyMetadata({
    data: "queryParam, style=form;explode=true;name=featureClass",
  })
  featureClass?: string;

  /**
   * A filter to limit the search to names associated with features of a certain 'type'  The value of this parameter should be a 'featureTypeCode' value returned by the /featureTypes resource, or an asterisk (*) to request that all feature types be included
   */
  @SpeakeasyMetadata({
    data: "queryParam, style=form;explode=true;name=featureType",
  })
  featureType?: string;

  /**
   * The number of search results to return (1-200)
   */
  @SpeakeasyMetadata({
    data: "queryParam, style=form;explode=true;name=itemsPerPage",
  })
  itemsPerPage?: number;

  /**
   * A filter to search based on the the text of the name itself.  Use the asterisk (*) as a wildcard character.  For example 'vancouv*'
   */
  @SpeakeasyMetadata({ data: "queryParam, style=form;explode=true;name=name" })
  name: string;

  /**
   * The format of the output.
   */
  @SpeakeasyMetadata({
    data: "queryParam, style=form;explode=true;name=outputFormat",
  })
  outputFormat: GetNamesSearchOutputFormatEnum;

  /**
   * The EPSG code of the spatial reference system (SRS) to use for output geometries.
   */
  @SpeakeasyMetadata({
    data: "queryParam, style=form;explode=true;name=outputSRS",
  })
  outputSRS?: GetNamesSearchOutputSrsEnum;

  /**
   * A flag indicating whether to include with each matching name a succinct list of attributes (summary), or a comprehensive list of attributes (detail)
   */
  @SpeakeasyMetadata({
    data: "queryParam, style=form;explode=true;name=outputStyle",
  })
  outputStyle?: GetNamesSearchOutputStyleEnum;

  /**
   * The distance to move the accessPoint away from the curb and towards the inside of the parcel (in metres). Ignored if locationDescriptor not set to accessPoint.
   */
  @SpeakeasyMetadata({
    data: "queryParam, style=form;explode=true;name=sortBy",
  })
  sortBy?: GetNamesSearchSortByEnum;

  /**
   * The index of the first record to be returned (>= 1)
   */
  @SpeakeasyMetadata({
    data: "queryParam, style=form;explode=true;name=startIndex",
  })
  startIndex?: number;
}

export class GetNamesSearchResponse extends SpeakeasyBase {
  @SpeakeasyMetadata()
  contentType: string;

  @SpeakeasyMetadata()
  statusCode: number;

  @SpeakeasyMetadata()
  rawResponse?: AxiosResponse;
}
