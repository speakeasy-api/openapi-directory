// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package operations

import (
	"bytes"
	"encoding/json"
	"errors"
	"net/http"
	"openapi/pkg/models/shared"
)

type StreamFilterQueryParams struct {
	// A comma-separated list of tweet expansions.
	Expansions [][]shared.TweetExpansionsParamTypeEnum `queryParam:"style=form,explode=true,name=expansions"`
}

type StreamFilterRequest struct {
	QueryParams StreamFilterQueryParams
}

// StreamFilter200ApplicationJSON2 - A tweet or error that can be returned by the streaming tweet API
type StreamFilter200ApplicationJSON2 struct {
	Errors []shared.Problem `json:"errors"`
}

type StreamFilter200ApplicationJSON1MatchingRules struct {
	// Unique identifier of this rule.
	ID string `json:"id"`
	// The user-supplied tag assigned to the rule which matched
	Tag *string `json:"tag,omitempty"`
}

// StreamFilter200ApplicationJSON1 - The values returned with a successful streamed tweet. Includes the user provided rules that the tweet matched.
type StreamFilter200ApplicationJSON1 struct {
	Data     shared.Tweet       `json:"data"`
	Includes *shared.Expansions `json:"includes,omitempty"`
	// The list of rules which matched the tweet
	MatchingRules []StreamFilter200ApplicationJSON1MatchingRules `json:"matching_rules"`
}

type StreamFilter200ApplicationJSONType string

const (
	StreamFilter200ApplicationJSONTypeStreamFilter200ApplicationJSON1 StreamFilter200ApplicationJSONType = "streamFilter_200ApplicationJSON_1"
	StreamFilter200ApplicationJSONTypeStreamFilter200ApplicationJSON2 StreamFilter200ApplicationJSONType = "streamFilter_200ApplicationJSON_2"
)

type StreamFilter200ApplicationJSON struct {
	StreamFilter200ApplicationJSON1 *StreamFilter200ApplicationJSON1
	StreamFilter200ApplicationJSON2 *StreamFilter200ApplicationJSON2

	Type StreamFilter200ApplicationJSONType
}

func CreateStreamFilter200ApplicationJSONStreamFilter200ApplicationJSON1(streamFilter200ApplicationJSON1 StreamFilter200ApplicationJSON1) StreamFilter200ApplicationJSON {
	typ := StreamFilter200ApplicationJSONTypeStreamFilter200ApplicationJSON1

	return StreamFilter200ApplicationJSON{
		StreamFilter200ApplicationJSON1: &streamFilter200ApplicationJSON1,
		Type:                            typ,
	}
}

func CreateStreamFilter200ApplicationJSONStreamFilter200ApplicationJSON2(streamFilter200ApplicationJSON2 StreamFilter200ApplicationJSON2) StreamFilter200ApplicationJSON {
	typ := StreamFilter200ApplicationJSONTypeStreamFilter200ApplicationJSON2

	return StreamFilter200ApplicationJSON{
		StreamFilter200ApplicationJSON2: &streamFilter200ApplicationJSON2,
		Type:                            typ,
	}
}

func (u *StreamFilter200ApplicationJSON) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	streamFilter200ApplicationJSON1 := new(StreamFilter200ApplicationJSON1)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&streamFilter200ApplicationJSON1); err == nil {
		u.StreamFilter200ApplicationJSON1 = streamFilter200ApplicationJSON1
		u.Type = StreamFilter200ApplicationJSONTypeStreamFilter200ApplicationJSON1
		return nil
	}

	streamFilter200ApplicationJSON2 := new(StreamFilter200ApplicationJSON2)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&streamFilter200ApplicationJSON2); err == nil {
		u.StreamFilter200ApplicationJSON2 = streamFilter200ApplicationJSON2
		u.Type = StreamFilter200ApplicationJSONTypeStreamFilter200ApplicationJSON2
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u StreamFilter200ApplicationJSON) MarshalJSON() ([]byte, error) {
	if u.StreamFilter200ApplicationJSON1 != nil {
		return json.Marshal(u.StreamFilter200ApplicationJSON1)
	}

	if u.StreamFilter200ApplicationJSON2 != nil {
		return json.Marshal(u.StreamFilter200ApplicationJSON2)
	}

	return nil, nil
}

type StreamFilterResponse struct {
	ContentType string
	// The request has failed.
	Error *shared.Error
	// The request has failed.
	Problem     *shared.Problem
	StatusCode  int
	RawResponse *http.Response
	// The request was successful. Successful responses will return a stream of individual JSON Tweet payloads.
	StreamFilter200ApplicationJSONObject *StreamFilter200ApplicationJSON
}
