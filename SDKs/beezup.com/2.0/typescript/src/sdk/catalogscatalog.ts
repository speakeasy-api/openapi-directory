/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class CatalogsCatalog {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Get the index of the catalog API for this store
   *
   * @remarks
   * The operation will give you all the operations you will be able to do on this store for this API.
   */
  catalogStoreIndex(
    req: operations.CatalogStoreIndexRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CatalogStoreIndexResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CatalogStoreIndexRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/user/catalogs/{storeId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CatalogStoreIndexResponse =
        new operations.CatalogStoreIndexResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.catalogStoreIndex = utils.objectToClass(
              httpRes?.data,
              shared.CatalogStoreIndex
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.beezUPCommonErrorResponseMessage = utils.objectToClass(
              httpRes?.data,
              shared.BeezUPCommonErrorResponseMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Change Catalog Column User Name
   */
  catalogChangeCatalogColumnUserName(
    req: operations.CatalogChangeCatalogColumnUserNameRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CatalogChangeCatalogColumnUserNameResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CatalogChangeCatalogColumnUserNameRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/user/catalogs/{storeId}/catalogColumns/{columnId}/rename",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "changeUserColumnNameRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CatalogChangeCatalogColumnUserNameResponse =
        new operations.CatalogChangeCatalogColumnUserNameResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        case httpRes?.status == 409:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.importAlreadyInProgressResponse = utils.objectToClass(
              httpRes?.data,
              shared.ImportAlreadyInProgressResponse
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.beezUPCommonErrorResponseMessage = utils.objectToClass(
              httpRes?.data,
              shared.BeezUPCommonErrorResponseMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Change custom column expression
   */
  catalogChangeCustomColumnExpression(
    req: operations.CatalogChangeCustomColumnExpressionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CatalogChangeCustomColumnExpressionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CatalogChangeCustomColumnExpressionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/user/catalogs/{storeId}/customColumns/{columnId}/expression",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "changeCustomColumnExpressionRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CatalogChangeCustomColumnExpressionResponse =
        new operations.CatalogChangeCustomColumnExpressionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        case httpRes?.status == 409:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.importAlreadyInProgressResponse = utils.objectToClass(
              httpRes?.data,
              shared.ImportAlreadyInProgressResponse
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.beezUPCommonErrorResponseMessage = utils.objectToClass(
              httpRes?.data,
              shared.BeezUPCommonErrorResponseMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Change Custom Column User Name
   */
  catalogChangeCustomColumnUserName(
    req: operations.CatalogChangeCustomColumnUserNameRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CatalogChangeCustomColumnUserNameResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CatalogChangeCustomColumnUserNameRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/user/catalogs/{storeId}/customColumns/{columnId}/rename",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "changeUserColumnNameRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CatalogChangeCustomColumnUserNameResponse =
        new operations.CatalogChangeCustomColumnUserNameResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        case httpRes?.status == 409:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.importAlreadyInProgressResponse = utils.objectToClass(
              httpRes?.data,
              shared.ImportAlreadyInProgressResponse
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.beezUPCommonErrorResponseMessage = utils.objectToClass(
              httpRes?.data,
              shared.BeezUPCommonErrorResponseMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Compute the expression for this catalog.
   */
  catalogComputeExpression(
    req: operations.CatalogComputeExpressionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CatalogComputeExpressionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CatalogComputeExpressionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/user/catalogs/{storeId}/customColumns/computeExpression",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "computeExpressionRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CatalogComputeExpressionResponse =
        new operations.CatalogComputeExpressionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.catalogComputeExpression200ApplicationJSONString =
              JSON.stringify(httpRes?.data);
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.catalogComputeExpression400ApplicationJSONString =
              JSON.stringify(httpRes?.data);
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.beezUPCommonErrorResponseMessage = utils.objectToClass(
              httpRes?.data,
              shared.BeezUPCommonErrorResponseMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete custom column
   */
  catalogDeleteCustomColumn(
    req: operations.CatalogDeleteCustomColumnRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CatalogDeleteCustomColumnResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CatalogDeleteCustomColumnRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/user/catalogs/{storeId}/customColumns/{columnId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CatalogDeleteCustomColumnResponse =
        new operations.CatalogDeleteCustomColumnResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.beezUPCommonErrorResponseMessage = utils.objectToClass(
              httpRes?.data,
              shared.BeezUPCommonErrorResponseMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get catalog column list
   */
  catalogGetCatalogColumns(
    req: operations.CatalogGetCatalogColumnsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CatalogGetCatalogColumnsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CatalogGetCatalogColumnsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/user/catalogs/{storeId}/catalogColumns",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CatalogGetCatalogColumnsResponse =
        new operations.CatalogGetCatalogColumnsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.catalogColumnList = utils.objectToClass(
              httpRes?.data,
              shared.CatalogColumnList
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.beezUPCommonErrorResponseMessage = utils.objectToClass(
              httpRes?.data,
              shared.BeezUPCommonErrorResponseMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get category list
   */
  catalogGetCategories(
    req: operations.CatalogGetCategoriesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CatalogGetCategoriesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CatalogGetCategoriesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/user/catalogs/{storeId}/categories",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CatalogGetCategoriesResponse =
        new operations.CatalogGetCategoriesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.categoryList = utils.objectToClass(
              httpRes?.data,
              shared.CategoryList
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.beezUPCommonErrorResponseMessage = utils.objectToClass(
              httpRes?.data,
              shared.BeezUPCommonErrorResponseMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get the encrypted custom column expression
   */
  catalogGetCustomColumnExpression(
    req: operations.CatalogGetCustomColumnExpressionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CatalogGetCustomColumnExpressionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CatalogGetCustomColumnExpressionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/user/catalogs/{storeId}/customColumns/{columnId}/expression",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CatalogGetCustomColumnExpressionResponse =
        new operations.CatalogGetCustomColumnExpressionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.catalogGetCustomColumnExpression200ApplicationJSONString =
              JSON.stringify(httpRes?.data);
          }
          break;
        case httpRes?.status == 404:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.beezUPCommonErrorResponseMessage = utils.objectToClass(
              httpRes?.data,
              shared.BeezUPCommonErrorResponseMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get custom column list
   */
  catalogGetCustomColumns(
    req: operations.CatalogGetCustomColumnsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CatalogGetCustomColumnsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CatalogGetCustomColumnsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/user/catalogs/{storeId}/customColumns",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CatalogGetCustomColumnsResponse =
        new operations.CatalogGetCustomColumnsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.customColumnList = utils.objectToClass(
              httpRes?.data,
              shared.CustomColumnList
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.beezUPCommonErrorResponseMessage = utils.objectToClass(
              httpRes?.data,
              shared.BeezUPCommonErrorResponseMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get product by ProductId
   */
  catalogGetProductByProductId(
    req: operations.CatalogGetProductByProductIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CatalogGetProductByProductIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CatalogGetProductByProductIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/user/catalogs/{storeId}/products/{productId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CatalogGetProductByProductIdResponse =
        new operations.CatalogGetProductByProductIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.product = utils.objectToClass(httpRes?.data, shared.Product);
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.beezUPCommonErrorResponseMessage = utils.objectToClass(
              httpRes?.data,
              shared.BeezUPCommonErrorResponseMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get product by Sku
   */
  catalogGetProductBySku(
    req: operations.CatalogGetProductBySkuRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CatalogGetProductBySkuResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CatalogGetProductBySkuRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/user/catalogs/{storeId}/products",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CatalogGetProductBySkuResponse =
        new operations.CatalogGetProductBySkuResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.product = utils.objectToClass(httpRes?.data, shared.Product);
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.beezUPCommonErrorResponseMessage = utils.objectToClass(
              httpRes?.data,
              shared.BeezUPCommonErrorResponseMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get product list
   */
  catalogGetProducts(
    req: operations.CatalogGetProductsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CatalogGetProductsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CatalogGetProductsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/user/catalogs/{storeId}/products/list",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getProductsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CatalogGetProductsResponse =
        new operations.CatalogGetProductsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.productList = utils.objectToClass(
              httpRes?.data,
              shared.ProductList
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.beezUPCommonErrorResponseMessage = utils.objectToClass(
              httpRes?.data,
              shared.BeezUPCommonErrorResponseMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get random product list
   *
   * @remarks
   * We will return 10 products randomly selected with all product values
   */
  catalogGetRandomProducts(
    req: operations.CatalogGetRandomProductsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CatalogGetRandomProductsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CatalogGetRandomProductsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/user/catalogs/{storeId}/products/random",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CatalogGetRandomProductsResponse =
        new operations.CatalogGetRandomProductsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.randomProductList = utils.objectToClass(
              httpRes?.data,
              shared.RandomProductList
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.beezUPCommonErrorResponseMessage = utils.objectToClass(
              httpRes?.data,
              shared.BeezUPCommonErrorResponseMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create or replace a custom column
   */
  catalogSaveCustomColumn(
    req: operations.CatalogSaveCustomColumnRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CatalogSaveCustomColumnResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CatalogSaveCustomColumnRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/user/catalogs/{storeId}/customColumns/{columnId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "createCustomColumnRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CatalogSaveCustomColumnResponse =
        new operations.CatalogSaveCustomColumnResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 404].includes(httpRes?.status):
          break;
        case httpRes?.status == 409:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.importAlreadyInProgressResponse = utils.objectToClass(
              httpRes?.data,
              shared.ImportAlreadyInProgressResponse
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.beezUPCommonErrorResponseMessage = utils.objectToClass(
              httpRes?.data,
              shared.BeezUPCommonErrorResponseMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get the last input configuration
   */
  importationGetManualUpdateLastInputConfig(
    req: operations.ImportationGetManualUpdateLastInputConfigRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ImportationGetManualUpdateLastInputConfigResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ImportationGetManualUpdateLastInputConfigRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/user/catalogs/{storeId}/inputConfiguration",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ImportationGetManualUpdateLastInputConfigResponse =
        new operations.ImportationGetManualUpdateLastInputConfigResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.lastManualImportInputConfiguration = utils.objectToClass(
              httpRes?.data,
              shared.LastManualImportInputConfiguration
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.beezUPCommonErrorResponseMessage = utils.objectToClass(
              httpRes?.data,
              shared.BeezUPCommonErrorResponseMessage
            );
          }
          break;
      }

      return res;
    });
  }
}
