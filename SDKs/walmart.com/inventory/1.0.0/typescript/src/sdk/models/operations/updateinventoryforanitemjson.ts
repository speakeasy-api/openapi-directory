/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { SpeakeasyBase, SpeakeasyMetadata } from "../../../internal/utils";
import { AxiosResponse } from "axios";
import { Expose, Type } from "class-transformer";

/**
 * The unit of measurement. Example: 'EACH'
 */
export enum UpdateInventoryForAnItemApplicationJSONQuantityUnitEnum {
  Each = "EACH",
}

/**
 * Quantity that has been ordered by the customers but not yet shipped
 */
export class UpdateInventoryForAnItemApplicationJSONQuantity extends SpeakeasyBase {
  /**
   * Inventory Count
   */
  @SpeakeasyMetadata()
  @Expose({ name: "amount" })
  amount: number;

  /**
   * The unit of measurement. Example: 'EACH'
   */
  @SpeakeasyMetadata()
  @Expose({ name: "unit" })
  unit: UpdateInventoryForAnItemApplicationJSONQuantityUnitEnum;
}

/**
 * File fields
 */
export class UpdateInventoryForAnItemApplicationJSON extends SpeakeasyBase {
  /**
   * Quantity that has been ordered by the customers but not yet shipped
   */
  @SpeakeasyMetadata()
  @Expose({ name: "quantity" })
  @Type(() => UpdateInventoryForAnItemApplicationJSONQuantity)
  quantity: UpdateInventoryForAnItemApplicationJSONQuantity;

  /**
   * A seller-provided Product ID. Response will have decoded value.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "sku" })
  sku: string;
}

export class UpdateInventoryForAnItemJsonRequest extends SpeakeasyBase {
  /**
   * File fields
   */
  @SpeakeasyMetadata({ data: "request, media_type=application/json" })
  requestBody: UpdateInventoryForAnItemApplicationJSON;

  /**
   * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
   */
  @SpeakeasyMetadata({
    data: "header, style=simple;explode=false;name=WM_CONSUMER.CHANNEL.TYPE",
  })
  wmConsumerChannelType?: string;

  /**
   * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
   */
  @SpeakeasyMetadata({
    data: "header, style=simple;explode=false;name=WM_QOS.CORRELATION_ID",
  })
  wmQosCorrelationId: string;

  /**
   * The access token retrieved in the Token API call
   */
  @SpeakeasyMetadata({
    data: "header, style=simple;explode=false;name=WM_SEC.ACCESS_TOKEN",
  })
  wmSecAccessToken: string;

  /**
   * Walmart Service Name
   */
  @SpeakeasyMetadata({
    data: "header, style=simple;explode=false;name=WM_SVC.NAME",
  })
  wmSvcName: string;

  /**
   * The shipNode for which the inventory is to be updated.
   */
  @SpeakeasyMetadata({
    data: "queryParam, style=form;explode=true;name=shipNode",
  })
  shipNode?: string;

  /**
   * An arbitrary alphanumeric unique ID, specified by the seller, which identifies each item. This will be used by the seller in the XSD file to refer to each item. Special characters in the sku needing encoding are: ':', '/', '?', '#', '[', ']', '@', '!', '$', '&', "'", '(', ')', '*', '+', ',', ';', '=', ‘ ’, '{', '}' as well as '%' itself if it's a part of sku. Make sure to encode space with %20. Other characters don't need to be encoded.
   */
  @SpeakeasyMetadata({ data: "queryParam, style=form;explode=true;name=sku" })
  sku: string;
}

/**
 * The unit of measurement. Example: 'EACH'
 */
export enum UpdateInventoryForAnItemJson200ApplicationXMLQuantityUnitEnum {
  Each = "EACH",
}

/**
 * Quantity that has been ordered by the customers but not yet shipped
 */
export class UpdateInventoryForAnItemJson200ApplicationXMLQuantity extends SpeakeasyBase {
  /**
   * Inventory Count
   */
  @SpeakeasyMetadata()
  amount: number;

  /**
   * The unit of measurement. Example: 'EACH'
   */
  @SpeakeasyMetadata()
  unit: UpdateInventoryForAnItemJson200ApplicationXMLQuantityUnitEnum;
}

/**
 * Successful Operation
 */
export class UpdateInventoryForAnItemJson200ApplicationXML extends SpeakeasyBase {
  /**
   * Quantity that has been ordered by the customers but not yet shipped
   */
  @SpeakeasyMetadata()
  quantity: UpdateInventoryForAnItemJson200ApplicationXMLQuantity;

  /**
   * A seller-provided Product ID. Response will have decoded value.
   */
  @SpeakeasyMetadata()
  sku: string;
}

/**
 * The unit of measurement. Example: 'EACH'
 */
export enum UpdateInventoryForAnItemJson200ApplicationJSONQuantityUnitEnum {
  Each = "EACH",
}

/**
 * Quantity that has been ordered by the customers but not yet shipped
 */
export class UpdateInventoryForAnItemJson200ApplicationJSONQuantity extends SpeakeasyBase {
  /**
   * Inventory Count
   */
  @SpeakeasyMetadata()
  @Expose({ name: "amount" })
  amount: number;

  /**
   * The unit of measurement. Example: 'EACH'
   */
  @SpeakeasyMetadata()
  @Expose({ name: "unit" })
  unit: UpdateInventoryForAnItemJson200ApplicationJSONQuantityUnitEnum;
}

/**
 * Successful Operation
 */
export class UpdateInventoryForAnItemJson200ApplicationJSON extends SpeakeasyBase {
  /**
   * Quantity that has been ordered by the customers but not yet shipped
   */
  @SpeakeasyMetadata()
  @Expose({ name: "quantity" })
  @Type(() => UpdateInventoryForAnItemJson200ApplicationJSONQuantity)
  quantity: UpdateInventoryForAnItemJson200ApplicationJSONQuantity;

  /**
   * A seller-provided Product ID. Response will have decoded value.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "sku" })
  sku: string;
}

export class UpdateInventoryForAnItemJsonResponse extends SpeakeasyBase {
  @SpeakeasyMetadata()
  body?: Uint8Array;

  @SpeakeasyMetadata()
  contentType: string;

  @SpeakeasyMetadata()
  statusCode: number;

  @SpeakeasyMetadata()
  rawResponse?: AxiosResponse;

  /**
   * Successful Operation
   */
  @SpeakeasyMetadata()
  updateInventoryForAnItemJSON200ApplicationJSONObject?: UpdateInventoryForAnItemJson200ApplicationJSON;
}
