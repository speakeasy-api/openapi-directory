"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
import requests as requests_http
from ..shared import createslotresponse as shared_createslotresponse
from ..shared import obfuscationsettingtype_enum as shared_obfuscationsettingtype_enum
from ..shared import promptspecification as shared_promptspecification
from ..shared import sampleutterance as shared_sampleutterance
from ..shared import slotcapturesetting as shared_slotcapturesetting
from ..shared import slotconstraint_enum as shared_slotconstraint_enum
from ..shared import slotdefaultvaluespecification as shared_slotdefaultvaluespecification
from ..shared import specifications as shared_specifications
from ..shared import waitandcontinuespecification as shared_waitandcontinuespecification
from dataclasses_json import Undefined, dataclass_json
from sdk import utils
from typing import Any, Optional


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class CreateSlotRequestBodyMultipleValuesSetting:
    r"""Indicates whether a slot can return multiple values."""
    
    allow_multiple_values: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('allowMultipleValues'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class CreateSlotRequestBodyObfuscationSetting:
    r"""Determines whether Amazon Lex obscures slot values in conversation logs."""
    
    obfuscation_setting_type: Optional[shared_obfuscationsettingtype_enum.ObfuscationSettingTypeEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('obfuscationSettingType'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class CreateSlotRequestBodySubSlotSetting:
    r"""Specifications for the constituent sub slots and the expression for the composite slot."""
    
    expression: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('expression'), 'exclude': lambda f: f is None }})  
    slot_specifications: Optional[dict[str, shared_specifications.Specifications]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('slotSpecifications'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class CreateSlotRequestBodyValueElicitationSetting:
    r"""Specifies the elicitation setting details for constituent sub slots of a composite slot."""
    
    default_value_specification: Optional[shared_slotdefaultvaluespecification.SlotDefaultValueSpecification] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('defaultValueSpecification'), 'exclude': lambda f: f is None }})  
    prompt_specification: Optional[shared_promptspecification.PromptSpecification] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('promptSpecification'), 'exclude': lambda f: f is None }})  
    sample_utterances: Optional[list[shared_sampleutterance.SampleUtterance]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('sampleUtterances'), 'exclude': lambda f: f is None }})  
    slot_capture_setting: Optional[shared_slotcapturesetting.SlotCaptureSetting] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('slotCaptureSetting'), 'exclude': lambda f: f is None }})  
    slot_constraint: Optional[shared_slotconstraint_enum.SlotConstraintEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('slotConstraint'), 'exclude': lambda f: f is None }})  
    wait_and_continue_specification: Optional[shared_waitandcontinuespecification.WaitAndContinueSpecification] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('waitAndContinueSpecification'), 'exclude': lambda f: f is None }})
    r"""Specifies the prompts that Amazon Lex uses while a bot is waiting for customer input."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class CreateSlotRequestBody:
    
    slot_name: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('slotName') }})
    r"""The name of the slot. Slot names must be unique within the bot that contains the slot."""  
    value_elicitation_setting: CreateSlotRequestBodyValueElicitationSetting = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('valueElicitationSetting') }})
    r"""Specifies the elicitation setting details for constituent sub slots of a composite slot."""  
    description: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('description'), 'exclude': lambda f: f is None }})
    r"""A description of the slot. Use this to help identify the slot in lists."""  
    multiple_values_setting: Optional[CreateSlotRequestBodyMultipleValuesSetting] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('multipleValuesSetting'), 'exclude': lambda f: f is None }})
    r"""Indicates whether a slot can return multiple values."""  
    obfuscation_setting: Optional[CreateSlotRequestBodyObfuscationSetting] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('obfuscationSetting'), 'exclude': lambda f: f is None }})
    r"""Determines whether Amazon Lex obscures slot values in conversation logs."""  
    slot_type_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('slotTypeId'), 'exclude': lambda f: f is None }})
    r"""The unique identifier for the slot type associated with this slot. The slot type determines the values that can be entered into the slot."""  
    sub_slot_setting: Optional[CreateSlotRequestBodySubSlotSetting] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('subSlotSetting'), 'exclude': lambda f: f is None }})
    r"""Specifications for the constituent sub slots and the expression for the composite slot."""  
    

@dataclasses.dataclass
class CreateSlotRequest:
    
    bot_id: str = dataclasses.field(metadata={'path_param': { 'field_name': 'botId', 'style': 'simple', 'explode': False }})
    r"""The identifier of the bot associated with the slot."""  
    bot_version: str = dataclasses.field(metadata={'path_param': { 'field_name': 'botVersion', 'style': 'simple', 'explode': False }})
    r"""The version of the bot associated with the slot."""  
    intent_id: str = dataclasses.field(metadata={'path_param': { 'field_name': 'intentId', 'style': 'simple', 'explode': False }})
    r"""The identifier of the intent that contains the slot."""  
    locale_id: str = dataclasses.field(metadata={'path_param': { 'field_name': 'localeId', 'style': 'simple', 'explode': False }})
    r"""The identifier of the language and locale that the slot will be used in. The string must match one of the supported locales. All of the bots, intents, slot types used by the slot must have the same locale. For more information, see <a href=\\"https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html\\">Supported languages</a>."""  
    request_body: CreateSlotRequestBody = dataclasses.field(metadata={'request': { 'media_type': 'application/json' }})  
    x_amz_algorithm: Optional[str] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'X-Amz-Algorithm', 'style': 'simple', 'explode': False }})  
    x_amz_content_sha256: Optional[str] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'X-Amz-Content-Sha256', 'style': 'simple', 'explode': False }})  
    x_amz_credential: Optional[str] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'X-Amz-Credential', 'style': 'simple', 'explode': False }})  
    x_amz_date: Optional[str] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'X-Amz-Date', 'style': 'simple', 'explode': False }})  
    x_amz_security_token: Optional[str] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'X-Amz-Security-Token', 'style': 'simple', 'explode': False }})  
    x_amz_signature: Optional[str] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'X-Amz-Signature', 'style': 'simple', 'explode': False }})  
    x_amz_signed_headers: Optional[str] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'X-Amz-SignedHeaders', 'style': 'simple', 'explode': False }})  
    

@dataclasses.dataclass
class CreateSlotResponse:
    
    content_type: str = dataclasses.field()  
    status_code: int = dataclasses.field()  
    conflict_exception: Optional[Any] = dataclasses.field(default=None)
    r"""ConflictException"""  
    create_slot_response: Optional[shared_createslotresponse.CreateSlotResponse] = dataclasses.field(default=None)
    r"""Success"""  
    internal_server_exception: Optional[Any] = dataclasses.field(default=None)
    r"""InternalServerException"""  
    precondition_failed_exception: Optional[Any] = dataclasses.field(default=None)
    r"""PreconditionFailedException"""  
    raw_response: Optional[requests_http.Response] = dataclasses.field(default=None)  
    service_quota_exceeded_exception: Optional[Any] = dataclasses.field(default=None)
    r"""ServiceQuotaExceededException"""  
    throttling_exception: Optional[Any] = dataclasses.field(default=None)
    r"""ThrottlingException"""  
    validation_exception: Optional[Any] = dataclasses.field(default=None)
    r"""ValidationException"""  
    