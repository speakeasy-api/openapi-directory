"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations
from typing import Optional

class Inventory:
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def get_supply_lots(self, request: operations.GetSupplyLotsRequest) -> operations.GetSupplyLotsResponse:
        r"""List supply lots
        Returns a list of the supply lots of an SKU in a specific warehouse.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetSupplyLotsRequest, base_url, '/api/logistics/pvt/inventory/items/{skuId}/warehouses/{warehouseId}/supplyLots', request)
        
        headers = utils.get_headers(request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetSupplyLotsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def getinventorywithdispatchedreservations(self, request: operations.GetinventorywithdispatchedreservationsRequest) -> operations.GetinventorywithdispatchedreservationsResponse:
        r"""List inventory with dispatched reservations
        Lists inventory with dispatched reservations. When the number of active reservations is more than 2000 the return is an error with status code 400 (BadRequest) and the message: Too many active reservations.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetinventorywithdispatchedreservationsRequest, base_url, '/api/logistics/pvt/inventory/items/{itemId}/warehouses/{warehouseId}/dispatched', request)
        
        headers = utils.get_headers(request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetinventorywithdispatchedreservationsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[operations.Getinventorywithdispatchedreservations200ApplicationJSON]])
                res.getinventorywithdispatchedreservations_200_application_json_objects = out

        return res

    def inventory_by_sku(self, request: operations.InventoryBySkuRequest) -> operations.InventoryBySkuResponse:
        r"""List inventory by SKU
        Lists your store's inventory by SKU ID
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.InventoryBySkuRequest, base_url, '/api/logistics/pvt/inventory/skus/{skuId}', request)
        
        headers = utils.get_headers(request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.InventoryBySkuResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json; charset=utf-8'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.InventoryBySku200ApplicationJSON])
                res.inventory_by_sku_200_application_json_object = out

        return res

    def inventoryperdock(self, request: operations.InventoryperdockRequest) -> operations.InventoryperdockResponse:
        r"""List inventory per dock
        Lists inventory information per dock set up in your store.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.InventoryperdockRequest, base_url, '/api/logistics/pvt/inventory/items/{skuId}/docks/{dockId}', request)
        
        headers = utils.get_headers(request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.InventoryperdockResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[operations.Inventoryperdock200ApplicationJSON]])
                res.inventoryperdock_200_application_json_objects = out

        return res

    def inventoryperdockandwarehouse(self, request: operations.InventoryperdockandwarehouseRequest) -> operations.InventoryperdockandwarehouseResponse:
        r"""List inventory per dock and warehouse
        Lists information of inventory per dock and warehouse.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.InventoryperdockandwarehouseRequest, base_url, '/api/logistics/pvt/inventory/items/{skuId}/docks/{dockId}/warehouses/{warehouseId}', request)
        
        headers = utils.get_headers(request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.InventoryperdockandwarehouseResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[operations.Inventoryperdockandwarehouse200ApplicationJSON]])
                res.inventoryperdockandwarehouse_200_application_json_objects = out

        return res

    def inventoryperwarehouse(self, request: operations.InventoryperwarehouseRequest) -> operations.InventoryperwarehouseResponse:
        r"""List inventory per warehouse
        Lists inventory information per warehouse on your store.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.InventoryperwarehouseRequest, base_url, '/api/logistics/pvt/inventory/items/{skuId}/warehouses/{warehouseId}', request)
        
        headers = utils.get_headers(request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.InventoryperwarehouseResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[operations.Inventoryperwarehouse200ApplicationJSON]])
                res.inventoryperwarehouse_200_application_json_objects = out

        return res

    def save_supply_lot(self, request: operations.SaveSupplyLotRequest) -> operations.SaveSupplyLotResponse:
        r"""Save supply lot
        Creates a new Supply Lot. A Supply Lot lets the store sell products that are not currently available in stock but whose arrival is already scheduled.
        
        Check out our [documentation](https://help.vtex.com/en/tutorial/setting-up-future-inventory--UMSGjooqRfkRbeoh94kS4) about this feature.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.SaveSupplyLotRequest, base_url, '/api/logistics/pvt/inventory/items/{skuId}/warehouses/{warehouseId}/supplyLots/{supplyLotId}', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SaveSupplyLotResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def transfer_supply_lot(self, request: operations.TransferSupplyLotRequest) -> operations.TransferSupplyLotResponse:
        r"""Transfer supply lot
        Transfers an SKU from a Supply Lot to the currently available inventory.
        
        Check out how this transfer works in further detail by reading our [documentation](https://help.vtex.com/pt/tutorial/configurar-estoque-futuro--UMSGjooqRfkRbeoh94kS4) about this feature.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.TransferSupplyLotRequest, base_url, '/api/logistics/pvt/inventory/items/{skuId}/warehouses/{warehouseId}/supplyLots/{supplyLotId}/transfer', request)
        
        headers = utils.get_headers(request)
        
        client = self._security_client
        
        http_res = client.request('POST', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.TransferSupplyLotResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def update_inventory_by_skuand_warehouse(self, request: operations.UpdateInventoryBySkuandWarehouseRequest) -> operations.UpdateInventoryBySkuandWarehouseResponse:
        r"""Update inventory by SKU and warehouse
        Updates inventory for a given SKU and warehouse.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.UpdateInventoryBySkuandWarehouseRequest, base_url, '/api/logistics/pvt/inventory/skus/{skuId}/warehouses/{warehouseId}', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateInventoryBySkuandWarehouseResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    