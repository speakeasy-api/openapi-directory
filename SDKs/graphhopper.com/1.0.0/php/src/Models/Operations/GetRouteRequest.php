<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI\Models\Operations;

use \OpenAPI\OpenAPI\Utils\SpeakeasyMetadata;
class GetRouteRequest
{
    /**
     * Rather than looking for the shortest or fastest path, this parameter lets you solve two different problems related to routing:
     * 
     * With `alternative_route`, we give you not one but several routes that are close to optimal, but
     * not too similar to each other. 
     * With `round_trip`, the route will get you back to where you started. This is meant for fun (think of
     * a bike trip), so we will add some randomness. The `round_trip` option requires `ch.disable=true`.
     * You can control both of these features with additional parameters, see below. 
     * 
     * 
     * @var ?\OpenAPI\OpenAPI\Models\Operations\GetRouteAlgorithmEnum $algorithm
     */
	#[SpeakeasyMetadata('queryParam:style=form,explode=true,name=algorithm')]
    public ?GetRouteAlgorithmEnum $algorithm = null;
    
    /**
     * If `algorithm=alternative_route`, this parameter sets the number of maximum paths which should be calculated. Increasing can lead to worse alternatives.
     * 
     * 
     * 
     * @var ?int $alternativeRouteMaxPaths
     */
	#[SpeakeasyMetadata('queryParam:style=form,explode=true,name=alternative_route.max_paths')]
    public ?int $alternativeRouteMaxPaths = null;
    
    /**
     * If `algorithm=alternative_route`, this parameter specifies how similar an alternative route can be to the optimal route. Increasing can lead to worse alternatives.
     * 
     * 
     * 
     * @var ?float $alternativeRouteMaxShareFactor
     */
	#[SpeakeasyMetadata('queryParam:style=form,explode=true,name=alternative_route.max_share_factor')]
    public ?float $alternativeRouteMaxShareFactor = null;
    
    /**
     * If `algorithm=alternative_route`, this parameter sets the factor by which the alternatives routes can be longer than the optimal route. Increasing can lead to worse alternatives.
     * 
     * 
     * 
     * @var ?float $alternativeRouteMaxWeightFactor
     */
	#[SpeakeasyMetadata('queryParam:style=form,explode=true,name=alternative_route.max_weight_factor')]
    public ?float $alternativeRouteMaxWeightFactor = null;
    
    /**
     * Specify which road classes and environments you would like to avoid. 
     * 
     * Possible values are `motorway`, `steps`, `track`, `toll`, `ferry`, `tunnel` and `bridge`.
     * Separate several values with `;`. Obviously not all the values make sense for all vehicle profiles e.g. `bike` is already forbidden on a `motorway`. Requires `ch.disable=true`.
     * 
     * 
     * @var ?string $avoid
     */
	#[SpeakeasyMetadata('queryParam:style=form,explode=true,name=avoid')]
    public ?string $avoid = null;
    
    /**
     * Block road access by specifying a point close to the road segment to be blocked, with the format `lat,lon`.
     * 
     * You can also block all road segments crossing a geometric shape. Specify a circle using the format `lat,lon,radius`, or a polygon using the format `lat1,lon1,lat2,lon2,...,latN,lonN`.
     * You can specify several shapes, separating them with `;`. Requires `ch.disable=true`.
     * 
     * 
     * @var ?string $blockArea
     */
	#[SpeakeasyMetadata('queryParam:style=form,explode=true,name=block_area')]
    public ?string $blockArea = null;
    
    /**
     * If the points for the route should be calculated at all.
     * 
     * 
     * 
     * @var ?bool $calcPoints
     */
	#[SpeakeasyMetadata('queryParam:style=form,explode=true,name=calc_points')]
    public ?bool $calcPoints = null;
    
    /**
     * Use this parameter in combination with one or more parameters from below.
     * 
     * 
     * 
     * @var ?bool $chDisable
     */
	#[SpeakeasyMetadata('queryParam:style=form,explode=true,name=ch.disable')]
    public ?bool $chDisable = null;
    
    /**
     * Optional parameter. It specifies on which side a point should be relative to the driver when she leaves/arrives at a start/target/via point. You need to specify this parameter for either none or all points. Only supported for motor vehicles and OpenStreetMap.
     * 
     * 
     * 
     * @var ?array<\OpenAPI\OpenAPI\Models\Operations\GetRouteCurbsideEnum> $curbside
     */
	#[SpeakeasyMetadata('queryParam:style=form,explode=true,name=curbside')]
    public ?array $curbside = null;
    
    /**
     * If `true`, the output will be formatted.
     * 
     * 
     * 
     * @var ?bool $debug
     */
	#[SpeakeasyMetadata('queryParam:style=form,explode=true,name=debug')]
    public ?bool $debug = null;
    
    /**
     * Optional parameter to retrieve path details. You can request additional details for the route: `street_name`, 
     * 
     * `time`, `distance`, `max_speed`, `toll`, `road_class`, `road_class_link`, `road_access`, `road_environment`, `lanes`, and `surface`. Read more about the usage of path details [here](https://discuss.graphhopper.com/t/2539).
     * 
     * 
     * @var ?array<string> $details
     */
	#[SpeakeasyMetadata('queryParam:style=form,explode=true,name=details')]
    public ?array $details = null;
    
    /**
     * If `true`, a third coordinate, the altitude, is included with all positions in the response.
     * 
     * This changes the format of the `points` and `snapped_waypoints` fields of the response, in both their
     * encodings. Unless you switch off the `points_encoded` parameter, you need special code on the
     * client side that can handle three-dimensional coordinates.
     * A request can fail if the vehicle profile does not support elevation. See the features object for every vehicle profile.
     * 
     * 
     * @var ?bool $elevation
     */
	#[SpeakeasyMetadata('queryParam:style=form,explode=true,name=elevation')]
    public ?bool $elevation = null;
    
    /**
     * Favour a heading direction for a certain point. Specify either one heading for the start point or as many as there are points.
     * 
     * In this case headings are associated by their order to the specific points. Headings are given as north based clockwise angle between 0 and 360 degree.
     * This parameter also influences the tour generated with `algorithm=round_trip` and forces the initial direction.  Requires `ch.disable=true`.
     * 
     * 
     * @var ?array<int> $heading
     */
	#[SpeakeasyMetadata('queryParam:style=form,explode=true,name=heading')]
    public ?array $heading = null;
    
    /**
     * Time penalty in seconds for not obeying a specified heading. Requires `ch.disable=true`.
     * 
     * 
     * 
     * @var ?int $headingPenalty
     */
	#[SpeakeasyMetadata('queryParam:style=form,explode=true,name=heading_penalty')]
    public ?int $headingPenalty = null;
    
    /**
     * If instructions should be calculated and returned
     * 
     * 
     * 
     * @var ?bool $instructions
     */
	#[SpeakeasyMetadata('queryParam:style=form,explode=true,name=instructions')]
    public ?bool $instructions = null;
    
    /**
     * The locale of the resulting turn instructions. E.g. `pt_PT` for Portuguese or `de` for German.
     * 
     * 
     * 
     * @var ?string $locale
     */
	#[SpeakeasyMetadata('queryParam:style=form,explode=true,name=locale')]
    public ?string $locale = null;
    
    /**
     * Normally, the calculated route will visit the points in the order you specified them.
     * 
     * If you have more than two points, you can set this parameter to `"true"` and the points may be re-ordered to minimize the total travel time.
     * Keep in mind that the limits on the number of locations of the Route Optimization API applies, and the request costs more credits.
     * 
     * 
     * @var ?string $optimize
     */
	#[SpeakeasyMetadata('queryParam:style=form,explode=true,name=optimize')]
    public ?string $optimize = null;
    
    /**
     * If `true`, u-turns are avoided at via-points with regard to the `heading_penalty`. Requires `ch.disable=true`.
     * 
     * 
     * 
     * @var ?bool $passThrough
     */
	#[SpeakeasyMetadata('queryParam:style=form,explode=true,name=pass_through')]
    public ?bool $passThrough = null;
    
    /**
     * The points for which the route should be calculated. Format: `[latitude,longitude]`. Specify at least an origin and a destination. Via points are possible.
     * 
     * The maximum number depends on your plan.
     * 
     * 
     * @var array<string> $point
     */
	#[SpeakeasyMetadata('queryParam:style=form,explode=true,name=point')]
    public array $point;
    
    /**
     * The `point_hint` is typically a road name to which the associated `point` parameter should be snapped to. Specify no `point_hint` parameter or the same number as you have `point` parameters.
     * 
     * 
     * 
     * @var ?array<string> $pointHint
     */
	#[SpeakeasyMetadata('queryParam:style=form,explode=true,name=point_hint')]
    public ?array $pointHint = null;
    
    /**
     * Allows changing the encoding of location data in the response. The default is polyline encoding, which is compact
     * 
     * but requires special client code to unpack. (We provide it in our JavaScript client library!)
     * Set this parameter to `false` to switch the encoding to simple coordinate pairs like `[lon,lat]`, or `[lon,lat,elevation]`.
     * See the description of the response format for more information.
     * 
     * 
     * @var ?bool $pointsEncoded
     */
	#[SpeakeasyMetadata('queryParam:style=form,explode=true,name=points_encoded')]
    public ?bool $pointsEncoded = null;
    
    /**
     * If `algorithm=round_trip`, this parameter configures approximative length of the resulting round trip. Requires `ch.disable=true`.
     * 
     * 
     * 
     * @var ?int $roundTripDistance
     */
	#[SpeakeasyMetadata('queryParam:style=form,explode=true,name=round_trip.distance')]
    public ?int $roundTripDistance = null;
    
    /**
     * If `algorithm=round_trip`, this sets the random seed. Change this to get a different tour for each value.
     * 
     * 
     * 
     * @var ?int $roundTripSeed
     */
	#[SpeakeasyMetadata('queryParam:style=form,explode=true,name=round_trip.seed')]
    public ?int $roundTripSeed = null;
    
    /**
     * Optional parameter to avoid snapping to a certain road class or road environment. Currently supported values are `motorway`, `trunk`, `ferry`, `tunnel`, `bridge` and `ford`. Multiple values are specified like `snap_prevention=ferry&snap_prevention=motorway`.
     * 
     * 
     * 
     * @var ?array<string> $snapPrevention
     */
	#[SpeakeasyMetadata('queryParam:style=form,explode=true,name=snap_prevention')]
    public ?array $snapPrevention = null;
    
    /**
     * Specifies if turn restrictions should be considered. Enabling this option increases the route computation time. Only supported for motor vehicles and OpenStreetMap.
     * 
     * 
     * 
     * @var ?bool $turnCosts
     */
	#[SpeakeasyMetadata('queryParam:style=form,explode=true,name=turn_costs')]
    public ?bool $turnCosts = null;
    
    /**
     * The vehicle profile for which the route should be calculated.
     * 
     * 
     * 
     * @var ?\OpenAPI\OpenAPI\Models\Shared\VehicleProfileIdEnum $vehicle
     */
	#[SpeakeasyMetadata('queryParam:style=form,explode=true,name=vehicle')]
    public ?\OpenAPI\OpenAPI\Models\Shared\VehicleProfileIdEnum $vehicle = null;
    
    /**
     * Determines the way the "best" route is calculated. Besides `fastest` you can use `short_fastest` which finds a reasonable balance between the distance influence (`shortest`) and the time (`fastest`). You could also use `shortest` but is deprecated and not recommended for motor vehicles. All except `fastest` require `ch.disable=true`.
     * 
     * 
     * 
     * @var ?string $weighting
     */
	#[SpeakeasyMetadata('queryParam:style=form,explode=true,name=weighting')]
    public ?string $weighting = null;
    
	public function __construct()
	{
		$this->algorithm = null;
		$this->alternativeRouteMaxPaths = null;
		$this->alternativeRouteMaxShareFactor = null;
		$this->alternativeRouteMaxWeightFactor = null;
		$this->avoid = null;
		$this->blockArea = null;
		$this->calcPoints = null;
		$this->chDisable = null;
		$this->curbside = null;
		$this->debug = null;
		$this->details = null;
		$this->elevation = null;
		$this->heading = null;
		$this->headingPenalty = null;
		$this->instructions = null;
		$this->locale = null;
		$this->optimize = null;
		$this->passThrough = null;
		$this->point = [];
		$this->pointHint = null;
		$this->pointsEncoded = null;
		$this->roundTripDistance = null;
		$this->roundTripSeed = null;
		$this->snapPrevention = null;
		$this->turnCosts = null;
		$this->vehicle = null;
		$this->weighting = null;
	}
}
