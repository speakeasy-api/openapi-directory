/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { SpeakeasyBase, SpeakeasyMetadata } from "../../../internal/utils";
import * as shared from "../shared";
import { AxiosResponse } from "axios";

/**
 * Whether or not to exclude podcasts/episodes with explicit language. 1 is yes and 0 is no. It works only when **type** is *episode* or *podcast*.
 *
 * @remarks
 *
 */
export enum SearchSafeModeEnum {
  Zero = "0",
  One = "1",
}

/**
 * Sort by date or not? If 0, then sort by relevance. If 1, then sort by date.
 *
 * @remarks
 *
 */
export enum SearchSortByDateEnum {
  Zero = "0",
  One = "1",
}

/**
 * What type of contents do you want to search for?
 *
 * @remarks
 *
 */
export enum SearchTypeEnum {
  Episode = "episode",
  Podcast = "podcast",
  Curated = "curated",
}

/**
 * Whether or not to keep only one episode per podcast in search results. 1 is yes and 0 is no. It works only when **type** is *episode*.
 *
 * @remarks
 *
 */
export enum SearchUniquePodcastsEnum {
  Zero = "0",
  One = "1",
}

export class SearchRequest extends SpeakeasyBase {
  /**
   * Get API Key on listennotes.com/api
   */
  @SpeakeasyMetadata({
    data: "header, style=simple;explode=false;name=X-ListenAPI-Key",
  })
  xListenAPIKey: string;

  /**
   * Maximum number of episodes. Applicable only when type parameter is **podcast**.
   *
   * @remarks
   *
   */
  @SpeakeasyMetadata({
    data: "queryParam, style=form;explode=true;name=episode_count_max",
  })
  episodeCountMax?: number;

  /**
   * Minimum number of episodes. Applicable only when type parameter is **podcast**.
   *
   * @remarks
   *
   */
  @SpeakeasyMetadata({
    data: "queryParam, style=form;explode=true;name=episode_count_min",
  })
  episodeCountMin?: number;

  /**
   * A comma-delimited string of a list of genre ids. If not specified, then all genres are included. You can find the id and the name of all genres from `GET /genres`. It works only when **type** is *episode* or *podcast*.
   *
   * @remarks
   *
   */
  @SpeakeasyMetadata({
    data: "queryParam, style=form;explode=true;name=genre_ids",
  })
  genreIds?: string;

  /**
   * Limit search results to a specific language. If not specified, it'll be any language. You can get a list of supported languages from `GET /languages`. It works only when **type** is *episode* or *podcast*.
   *
   * @remarks
   *
   */
  @SpeakeasyMetadata({
    data: "queryParam, style=form;explode=true;name=language",
  })
  language?: string;

  /**
   * Maximum audio length in minutes. Applicable only when **type** parameter is **episode** or **podcast**.
   *
   * @remarks
   * If **type** parameter is **episode**, it's for audio length of an episode.
   * If **type** parameter is **podcast**, it's for average audio length of all episodes in a podcast.
   *
   */
  @SpeakeasyMetadata({
    data: "queryParam, style=form;explode=true;name=len_max",
  })
  lenMax?: number;

  /**
   * Minimum audio length in minutes. Applicable only when **type** parameter is **episode** or **podcast**.
   *
   * @remarks
   * If **type** parameter is **episode**, it's for audio length of an episode.
   * If **type** parameter is **podcast**, it's for average audio length of all episodes in a podcast.
   *
   */
  @SpeakeasyMetadata({
    data: "queryParam, style=form;explode=true;name=len_min",
  })
  lenMin?: number;

  /**
   * A comma-delimited string of podcast ids (up to 5 podcasts) - you can get a podcast id from the **podcast_id** field in response. This parameter is to exclude search results of a few specific podcasts. It works only when **type** is *episode*.
   *
   * @remarks
   *
   */
  @SpeakeasyMetadata({ data: "queryParam, style=form;explode=true;name=ncid" })
  ncid?: string;

  /**
   * A comma-delimited string of podcast ids (up to 5 podcasts) - you can get a podcast id from the **podcast_id** field in response. This parameter is to limit search results from only a few specific podcasts. It works only when **type** is *episode*.
   *
   * @remarks
   *
   */
  @SpeakeasyMetadata({ data: "queryParam, style=form;explode=true;name=ocid" })
  ocid?: string;

  /**
   * Offset for search results, for pagination. You'll use **next_offset** from response for this parameter.
   *
   * @remarks
   *
   */
  @SpeakeasyMetadata({
    data: "queryParam, style=form;explode=true;name=offset",
  })
  offset?: number;

  /**
   * A comma-delimited string to search only in specific fields. Allowed values are title, description, author, and audio. If not specified, then search every fields.
   *
   * @remarks
   *
   */
  @SpeakeasyMetadata({
    data: "queryParam, style=form;explode=true;name=only_in",
  })
  onlyIn?: string;

  /**
   * Only show episodes/podcasts/curated lists published after this timestamp (in milliseconds). If **published_before** & **published_after** are used at the same time, **published_before** should be bigger than **published_after**.
   *
   * @remarks
   *
   */
  @SpeakeasyMetadata({
    data: "queryParam, style=form;explode=true;name=published_after",
  })
  publishedAfter?: number;

  /**
   * Only show episodes/podcasts/curated lists published before this timestamp (in milliseconds). If **published_before** & **published_after** are used at the same time, **published_before** should be bigger than **published_after**.
   *
   * @remarks
   *
   */
  @SpeakeasyMetadata({
    data: "queryParam, style=form;explode=true;name=published_before",
  })
  publishedBefore?: number;

  /**
   * Search term, e.g., person, place, topic... You can use double quotes to do verbatim match, e.g., "game of thrones". Otherwise, it's fuzzy search.
   *
   * @remarks
   *
   */
  @SpeakeasyMetadata({ data: "queryParam, style=form;explode=true;name=q" })
  q: string;

  /**
   * Limit search results to a specific region (e.g., us, gb, in...). If not specified, it'll be any region. You can get the supported country codes from `GET /regions`. It works only when **type** is *episode* or *podcast*.
   *
   * @remarks
   *
   */
  @SpeakeasyMetadata({
    data: "queryParam, style=form;explode=true;name=region",
  })
  region?: string;

  /**
   * Whether or not to exclude podcasts/episodes with explicit language. 1 is yes and 0 is no. It works only when **type** is *episode* or *podcast*.
   *
   * @remarks
   *
   */
  @SpeakeasyMetadata({
    data: "queryParam, style=form;explode=true;name=safe_mode",
  })
  safeMode?: SearchSafeModeEnum;

  /**
   * Sort by date or not? If 0, then sort by relevance. If 1, then sort by date.
   *
   * @remarks
   *
   */
  @SpeakeasyMetadata({
    data: "queryParam, style=form;explode=true;name=sort_by_date",
  })
  sortByDate?: SearchSortByDateEnum;

  /**
   * What type of contents do you want to search for?
   *
   * @remarks
   *
   */
  @SpeakeasyMetadata({ data: "queryParam, style=form;explode=true;name=type" })
  type?: SearchTypeEnum;

  /**
   * Whether or not to keep only one episode per podcast in search results. 1 is yes and 0 is no. It works only when **type** is *episode*.
   *
   * @remarks
   *
   */
  @SpeakeasyMetadata({
    data: "queryParam, style=form;explode=true;name=unique_podcasts",
  })
  uniquePodcasts?: SearchUniquePodcastsEnum;

  /**
   * Maximum update frequency in hours (how frequently does a podcast release a new episode). For example, if you want to find "weekly" podcasts, then you can set **update_freq_min**=144 hours (or 6 days) and **update_freq_max**=192 hours (or 8 days). Applicable only when type parameter is **podcast**.
   *
   * @remarks
   *
   */
  @SpeakeasyMetadata({
    data: "queryParam, style=form;explode=true;name=update_freq_max",
  })
  updateFreqMax?: number;

  /**
   * Minimum update frequency in hours (how frequently does a podcast release a new episode). For example, if you want to find "weekly" podcasts, then you can set **update_freq_min**=144 hours (or 6 days) and **update_freq_max**=192 hours (or 8 days). Applicable only when type parameter is **podcast**.
   *
   * @remarks
   *
   */
  @SpeakeasyMetadata({
    data: "queryParam, style=form;explode=true;name=update_freq_min",
  })
  updateFreqMin?: number;
}

export class SearchResponse extends SpeakeasyBase {
  @SpeakeasyMetadata()
  contentType: string;

  @SpeakeasyMetadata()
  headers?: Record<string, string[]>;

  /**
   * OK
   */
  @SpeakeasyMetadata()
  searchResponse?: shared.SearchResponse;

  @SpeakeasyMetadata()
  statusCode: number;

  @SpeakeasyMetadata()
  rawResponse?: AxiosResponse;
}
