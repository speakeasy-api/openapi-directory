<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class Files 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * Creates a copy of a file and applies any requested updates with patch semantics. Folders cannot be copied.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DriveFilesCopyRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\DriveFilesCopySecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\DriveFilesCopyResponse
     */
	public function driveFilesCopy(
        \OpenAPI\OpenAPI\Models\Operations\DriveFilesCopyRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\DriveFilesCopySecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\DriveFilesCopyResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/files/{fileId}/copy', \OpenAPI\OpenAPI\Models\Operations\DriveFilesCopyRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "fileInput", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DriveFilesCopyRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DriveFilesCopyResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->file = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\File', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Creates a file.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DriveFilesCreateRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\DriveFilesCreateSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\DriveFilesCreateResponse
     */
	public function driveFilesCreate(
        \OpenAPI\OpenAPI\Models\Operations\DriveFilesCreateRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\DriveFilesCreateSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\DriveFilesCreateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/files');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "raw");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DriveFilesCreateRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DriveFilesCreateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->file = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\File', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Permanently deletes a file owned by the user without moving it to the trash. If the file belongs to a shared drive the user must be an organizer on the parent. If the target is a folder, all descendants owned by the user are also deleted.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DriveFilesDeleteRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\DriveFilesDeleteSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\DriveFilesDeleteResponse
     */
	public function driveFilesDelete(
        \OpenAPI\OpenAPI\Models\Operations\DriveFilesDeleteRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\DriveFilesDeleteSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\DriveFilesDeleteResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/files/{fileId}', \OpenAPI\OpenAPI\Models\Operations\DriveFilesDeleteRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DriveFilesDeleteRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DriveFilesDeleteResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Permanently deletes all trashed files of a user or shared drive.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DriveFilesEmptyTrashRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\DriveFilesEmptyTrashSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\DriveFilesEmptyTrashResponse
     */
	public function driveFilesEmptyTrash(
        \OpenAPI\OpenAPI\Models\Operations\DriveFilesEmptyTrashRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\DriveFilesEmptyTrashSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\DriveFilesEmptyTrashResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/files/trash');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DriveFilesEmptyTrashRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DriveFilesEmptyTrashResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Exports a Google Workspace document to the requested MIME type and returns exported byte content. Note that the exported content is limited to 10MB.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DriveFilesExportRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\DriveFilesExportSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\DriveFilesExportResponse
     */
	public function driveFilesExport(
        \OpenAPI\OpenAPI\Models\Operations\DriveFilesExportRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\DriveFilesExportSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\DriveFilesExportResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/files/{fileId}/export', \OpenAPI\OpenAPI\Models\Operations\DriveFilesExportRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DriveFilesExportRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DriveFilesExportResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Generates a set of file IDs which can be provided in create or copy requests.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DriveFilesGenerateIdsRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\DriveFilesGenerateIdsSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\DriveFilesGenerateIdsResponse
     */
	public function driveFilesGenerateIds(
        \OpenAPI\OpenAPI\Models\Operations\DriveFilesGenerateIdsRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\DriveFilesGenerateIdsSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\DriveFilesGenerateIdsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/files/generateIds');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DriveFilesGenerateIdsRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DriveFilesGenerateIdsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->generatedIds = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\GeneratedIds', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Gets a file's metadata or content by ID.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DriveFilesGetRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\DriveFilesGetSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\DriveFilesGetResponse
     */
	public function driveFilesGet(
        \OpenAPI\OpenAPI\Models\Operations\DriveFilesGetRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\DriveFilesGetSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\DriveFilesGetResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/files/{fileId}', \OpenAPI\OpenAPI\Models\Operations\DriveFilesGetRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DriveFilesGetRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DriveFilesGetResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->file = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\File', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Lists or searches files.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DriveFilesListRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\DriveFilesListSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\DriveFilesListResponse
     */
	public function driveFilesList(
        \OpenAPI\OpenAPI\Models\Operations\DriveFilesListRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\DriveFilesListSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\DriveFilesListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/files');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DriveFilesListRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DriveFilesListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->fileList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\FileList', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Lists the labels on a file.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DriveFilesListLabelsRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\DriveFilesListLabelsSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\DriveFilesListLabelsResponse
     */
	public function driveFilesListLabels(
        \OpenAPI\OpenAPI\Models\Operations\DriveFilesListLabelsRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\DriveFilesListLabelsSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\DriveFilesListLabelsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/files/{fileId}/listLabels', \OpenAPI\OpenAPI\Models\Operations\DriveFilesListLabelsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DriveFilesListLabelsRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DriveFilesListLabelsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->labelList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\LabelList', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Modifies the set of labels on a file.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DriveFilesModifyLabelsRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\DriveFilesModifyLabelsSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\DriveFilesModifyLabelsResponse
     */
	public function driveFilesModifyLabels(
        \OpenAPI\OpenAPI\Models\Operations\DriveFilesModifyLabelsRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\DriveFilesModifyLabelsSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\DriveFilesModifyLabelsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/files/{fileId}/modifyLabels', \OpenAPI\OpenAPI\Models\Operations\DriveFilesModifyLabelsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "modifyLabelsRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DriveFilesModifyLabelsRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DriveFilesModifyLabelsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->modifyLabelsResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ModifyLabelsResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Updates a file's metadata and/or content. When calling this method, only populate fields in the request that you want to modify. When updating fields, some fields might change automatically, such as modifiedDate. This method supports patch semantics.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DriveFilesUpdateRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\DriveFilesUpdateSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\DriveFilesUpdateResponse
     */
	public function driveFilesUpdate(
        \OpenAPI\OpenAPI\Models\Operations\DriveFilesUpdateRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\DriveFilesUpdateSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\DriveFilesUpdateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/files/{fileId}', \OpenAPI\OpenAPI\Models\Operations\DriveFilesUpdateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "raw");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DriveFilesUpdateRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DriveFilesUpdateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->file = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\File', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Subscribe to changes on a file.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DriveFilesWatchRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\DriveFilesWatchSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\DriveFilesWatchResponse
     */
	public function driveFilesWatch(
        \OpenAPI\OpenAPI\Models\Operations\DriveFilesWatchRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\DriveFilesWatchSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\DriveFilesWatchResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/files/{fileId}/watch', \OpenAPI\OpenAPI\Models\Operations\DriveFilesWatchRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "channel", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DriveFilesWatchRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DriveFilesWatchResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->channel = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Channel', 'json');
            }
        }

        return $response;
    }
}