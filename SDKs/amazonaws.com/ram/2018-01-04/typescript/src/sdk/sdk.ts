/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * Contains the list of servers available to the SDK
 */
export const ServerList = [
  /**
   * The RAM multi-region endpoint
   */
  "http://ram.{region}.amazonaws.com",
  /**
   * The RAM multi-region endpoint
   */
  "https://ram.{region}.amazonaws.com",
  /**
   * The RAM endpoint for China (Beijing) and China (Ningxia)
   */
  "http://ram.{region}.amazonaws.com.cn",
  /**
   * The RAM endpoint for China (Beijing) and China (Ningxia)
   */
  "https://ram.{region}.amazonaws.com.cn",
] as const;

/**
 * The available configuration options for the SDK
 */
export type SDKProps = {
  /**
   * The security details required to authenticate the SDK
   */
  security?: shared.Security;
  /**
   * Allows overriding the default axios client used by the SDK
   */
  defaultClient?: AxiosInstance;
  /**
   * Allows overriding the default server URL used by the SDK
   */
  serverURL?: string;
};

/**
 * <p>This is the <i>Resource Access Manager API Reference</i>. This documentation provides descriptions and syntax for each of the actions and data types in RAM. RAM is a service that helps you securely share your Amazon Web Services resources across Amazon Web Services accounts. If you have multiple Amazon Web Services accounts, you can use RAM to share those resources with other accounts. If you use Organizations to manage your accounts, then you share your resources with your organization or organizational units (OUs). For supported resource types, you can also share resources with individual Identity and Access Management (IAM) roles an users. </p> <p>To learn more about RAM, see the following resources:</p> <ul> <li> <p> <a href="http://aws.amazon.com/ram">Resource Access Manager product page</a> </p> </li> <li> <p> <a href="https://docs.aws.amazon.com/ram/latest/userguide/">Resource Access Manager User Guide</a> </p> </li> </ul>
 *
 * @see {@link https://docs.aws.amazon.com/ram/} - Amazon Web Services documentation
 */
export class SDK {
  public _defaultClient: AxiosInstance;
  public _securityClient: AxiosInstance;
  public _serverURL: string;
  private _language = "typescript";
  private _sdkVersion = "0.0.1";
  private _genVersion = "internal";
  private _globals: any;

  constructor(props?: SDKProps) {
    this._serverURL = props?.serverURL ?? ServerList[0];

    this._defaultClient =
      props?.defaultClient ?? axios.create({ baseURL: this._serverURL });
    if (props?.security) {
      let security: shared.Security = props.security;
      if (!(props.security instanceof utils.SpeakeasyBase))
        security = new shared.Security(props.security);
      this._securityClient = utils.createSecurityClient(
        this._defaultClient,
        security
      );
    } else {
      this._securityClient = this._defaultClient;
    }
  }

  /**
   * Accepts an invitation to a resource share from another Amazon Web Services account. After you accept the invitation, the resources included in the resource share are available to interact with in the relevant Amazon Web Services Management Consoles and tools.
   */
  acceptResourceShareInvitation(
    req: operations.AcceptResourceShareInvitationRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.AcceptResourceShareInvitationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AcceptResourceShareInvitationRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/acceptresourceshareinvitation";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AcceptResourceShareInvitationResponse =
        new operations.AcceptResourceShareInvitationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.acceptResourceShareInvitationResponse = utils.objectToClass(
              httpRes?.data,
              shared.AcceptResourceShareInvitationResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.malformedArnException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationNotPermittedException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceShareInvitationArnNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceShareInvitationAlreadyAcceptedException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceShareInvitationAlreadyRejectedException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceShareInvitationExpiredException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serverInternalException = httpRes?.data;
          }
          break;
        case httpRes?.status == 487:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 488:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidClientTokenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 489:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.idempotentParameterMismatchException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Adds the specified list of principals and list of resources to a resource share. Principals that already have access to this resource share immediately receive access to the added resources. Newly added principals immediately receive access to the resources shared in this resource share.
   */
  associateResourceShare(
    req: operations.AssociateResourceShareRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.AssociateResourceShareResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AssociateResourceShareRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/associateresourceshare";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AssociateResourceShareResponse =
        new operations.AssociateResourceShareResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.associateResourceShareResponse = utils.objectToClass(
              httpRes?.data,
              shared.AssociateResourceShareResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.idempotentParameterMismatchException = httpRes?.data;
          }
          break;
        case [481, 491].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.unknownResourceException = httpRes?.data;
          }
          break;
        case [482, 485].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidStateTransitionException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceShareLimitExceededException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.malformedArnException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidClientTokenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 487:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidParameterException = httpRes?.data;
          }
          break;
        case httpRes?.status == 488:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationNotPermittedException = httpRes?.data;
          }
          break;
        case httpRes?.status == 489:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serverInternalException = httpRes?.data;
          }
          break;
        case httpRes?.status == 490:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 492:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.throttlingException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Adds or replaces the RAM permission for a resource type included in a resource share. You can have exactly one permission associated with each resource type in the resource share. You can add a new RAM permission only if there are currently no resources of that resource type currently in the resource share.
   */
  associateResourceSharePermission(
    req: operations.AssociateResourceSharePermissionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.AssociateResourceSharePermissionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AssociateResourceSharePermissionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/associateresourcesharepermission";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AssociateResourceSharePermissionResponse =
        new operations.AssociateResourceSharePermissionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.associateResourceSharePermissionResponse = utils.objectToClass(
              httpRes?.data,
              shared.AssociateResourceSharePermissionResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.malformedArnException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.unknownResourceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidParameterException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidClientTokenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serverInternalException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationNotPermittedException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * <p>Creates a resource share. You can provide a list of the <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)</a> for the resources that you want to share, a list of principals you want to share the resources with, and the permissions to grant those principals.</p> <note> <p>Sharing a resource makes it available for use by principals outside of the Amazon Web Services account that created the resource. Sharing doesn't change any permissions or quotas that apply to the resource in the account that created it.</p> </note>
   */
  createResourceShare(
    req: operations.CreateResourceShareRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateResourceShareResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateResourceShareRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/createresourceshare";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateResourceShareResponse =
        new operations.CreateResourceShareResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.createResourceShareResponse = utils.objectToClass(
              httpRes?.data,
              shared.CreateResourceShareResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.idempotentParameterMismatchException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidStateTransitionException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.unknownResourceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.malformedArnException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidClientTokenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidParameterException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationNotPermittedException = httpRes?.data;
          }
          break;
        case httpRes?.status == 487:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceShareLimitExceededException = httpRes?.data;
          }
          break;
        case httpRes?.status == 488:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tagPolicyViolationException = httpRes?.data;
          }
          break;
        case httpRes?.status == 489:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serverInternalException = httpRes?.data;
          }
          break;
        case httpRes?.status == 490:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes the specified resource share. This doesn't delete any of the resources that were associated with the resource share; it only stops the sharing of those resources outside of the Amazon Web Services account that created them.
   */
  deleteResourceShare(
    req: operations.DeleteResourceShareRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteResourceShareResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteResourceShareRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/deleteresourceshare#resourceShareArn";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteResourceShareResponse =
        new operations.DeleteResourceShareResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deleteResourceShareResponse = utils.objectToClass(
              httpRes?.data,
              shared.DeleteResourceShareResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationNotPermittedException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.idempotentParameterMismatchException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidStateTransitionException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.unknownResourceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.malformedArnException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidClientTokenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidParameterException = httpRes?.data;
          }
          break;
        case httpRes?.status == 487:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serverInternalException = httpRes?.data;
          }
          break;
        case httpRes?.status == 488:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Disassociates the specified principals or resources from the specified resource share.
   */
  disassociateResourceShare(
    req: operations.DisassociateResourceShareRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DisassociateResourceShareResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DisassociateResourceShareRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/disassociateresourceshare";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DisassociateResourceShareResponse =
        new operations.DisassociateResourceShareResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.disassociateResourceShareResponse = utils.objectToClass(
              httpRes?.data,
              shared.DisassociateResourceShareResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.idempotentParameterMismatchException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceShareLimitExceededException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.malformedArnException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidStateTransitionException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidClientTokenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidParameterException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationNotPermittedException = httpRes?.data;
          }
          break;
        case httpRes?.status == 487:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serverInternalException = httpRes?.data;
          }
          break;
        case httpRes?.status == 488:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 489:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.unknownResourceException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Disassociates an RAM permission from a resource share. Permission changes take effect immediately. You can remove a RAM permission from a resource share only if there are currently no resources of the relevant resource type currently attached to the resource share.
   */
  disassociateResourceSharePermission(
    req: operations.DisassociateResourceSharePermissionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DisassociateResourceSharePermissionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DisassociateResourceSharePermissionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/disassociateresourcesharepermission";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DisassociateResourceSharePermissionResponse =
        new operations.DisassociateResourceSharePermissionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.disassociateResourceSharePermissionResponse =
              utils.objectToClass(
                httpRes?.data,
                shared.DisassociateResourceSharePermissionResponse
              );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.malformedArnException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.unknownResourceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidParameterException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidClientTokenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serverInternalException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationNotPermittedException = httpRes?.data;
          }
          break;
        case httpRes?.status == 487:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidStateTransitionException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * <p>Enables resource sharing within your organization in Organizations. Calling this operation enables RAM to retrieve information about the organization and its structure. This lets you share resources with all of the accounts in an organization by specifying the organization's ID, or all of the accounts in an organizational unit (OU) by specifying the OU's ID. Until you enable sharing within the organization, you can specify only individual Amazon Web Services accounts, or for supported resource types, IAM users and roles.</p> <p>You must call this operation from an IAM user or role in the organization's management account.</p>
   */
  enableSharingWithAwsOrganization(
    req: operations.EnableSharingWithAwsOrganizationRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.EnableSharingWithAwsOrganizationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.EnableSharingWithAwsOrganizationRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/enablesharingwithawsorganization";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.EnableSharingWithAwsOrganizationResponse =
        new operations.EnableSharingWithAwsOrganizationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.enableSharingWithAwsOrganizationResponse = utils.objectToClass(
              httpRes?.data,
              shared.EnableSharingWithAwsOrganizationResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationNotPermittedException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serverInternalException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets the contents of an RAM permission in JSON format.
   */
  getPermission(
    req: operations.GetPermissionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetPermissionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetPermissionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/getpermission";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetPermissionResponse =
        new operations.GetPermissionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getPermissionResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetPermissionResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidParameterException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.malformedArnException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.unknownResourceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serverInternalException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationNotPermittedException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves the resource policies for the specified resources that you own and have shared.
   */
  getResourcePolicies(
    req: operations.GetResourcePoliciesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetResourcePoliciesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetResourcePoliciesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/getresourcepolicies";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetResourcePoliciesResponse =
        new operations.GetResourcePoliciesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getResourcePoliciesResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetResourcePoliciesResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.malformedArnException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidNextTokenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidParameterException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceArnNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serverInternalException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves the resource and principal associations for resource shares that you own.
   */
  getResourceShareAssociations(
    req: operations.GetResourceShareAssociationsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetResourceShareAssociationsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetResourceShareAssociationsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/getresourceshareassociations";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetResourceShareAssociationsResponse =
        new operations.GetResourceShareAssociationsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getResourceShareAssociationsResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetResourceShareAssociationsResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.unknownResourceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.malformedArnException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidNextTokenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidParameterException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationNotPermittedException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serverInternalException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves details about invitations that you have received for resource shares.
   */
  getResourceShareInvitations(
    req: operations.GetResourceShareInvitationsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetResourceShareInvitationsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetResourceShareInvitationsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/getresourceshareinvitations";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetResourceShareInvitationsResponse =
        new operations.GetResourceShareInvitationsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getResourceShareInvitationsResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetResourceShareInvitationsResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceShareInvitationArnNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidMaxResultsException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.malformedArnException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.unknownResourceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidNextTokenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidParameterException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serverInternalException = httpRes?.data;
          }
          break;
        case httpRes?.status == 487:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves details about the resource shares that you own or that are shared with you.
   */
  getResourceShares(
    req: operations.GetResourceSharesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetResourceSharesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetResourceSharesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/getresourceshares";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetResourceSharesResponse =
        new operations.GetResourceSharesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getResourceSharesResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetResourceSharesResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.unknownResourceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.malformedArnException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidNextTokenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidParameterException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serverInternalException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists the resources in a resource share that is shared with you but for which the invitation is still <code>PENDING</code>. That means that you haven't accepted or rejected the invitation and the invitation hasn't expired.
   */
  listPendingInvitationResources(
    req: operations.ListPendingInvitationResourcesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListPendingInvitationResourcesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListPendingInvitationResourcesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/listpendinginvitationresources";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListPendingInvitationResourcesResponse =
        new operations.ListPendingInvitationResourcesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listPendingInvitationResourcesResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListPendingInvitationResourcesResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.malformedArnException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidNextTokenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidParameterException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serverInternalException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceShareInvitationArnNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.missingRequiredParameterException = httpRes?.data;
          }
          break;
        case httpRes?.status == 487:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceShareInvitationAlreadyRejectedException = httpRes?.data;
          }
          break;
        case httpRes?.status == 488:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceShareInvitationExpiredException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists the available versions of the specified RAM permission.
   */
  listPermissionVersions(
    req: operations.ListPermissionVersionsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListPermissionVersionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListPermissionVersionsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/listpermissionversions";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListPermissionVersionsResponse =
        new operations.ListPermissionVersionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listPermissionVersionsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListPermissionVersionsResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.malformedArnException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.unknownResourceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidNextTokenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serverInternalException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationNotPermittedException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidParameterException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves a list of available RAM permissions that you can use for the supported resource types.
   */
  listPermissions(
    req: operations.ListPermissionsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListPermissionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListPermissionsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/listpermissions";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListPermissionsResponse =
        new operations.ListPermissionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listPermissionsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListPermissionsResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidParameterException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidNextTokenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serverInternalException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationNotPermittedException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists the principals that you are sharing resources with or that are sharing resources with you.
   */
  listPrincipals(
    req: operations.ListPrincipalsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListPrincipalsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListPrincipalsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/listprincipals";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListPrincipalsResponse =
        new operations.ListPrincipalsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listPrincipalsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListPrincipalsResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.malformedArnException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.unknownResourceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidNextTokenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidParameterException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serverInternalException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists the RAM permissions that are associated with a resource share.
   */
  listResourceSharePermissions(
    req: operations.ListResourceSharePermissionsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListResourceSharePermissionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListResourceSharePermissionsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/listresourcesharepermissions";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListResourceSharePermissionsResponse =
        new operations.ListResourceSharePermissionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listResourceSharePermissionsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListResourceSharePermissionsResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidParameterException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.malformedArnException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.unknownResourceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidNextTokenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serverInternalException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationNotPermittedException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists the resource types that can be shared by RAM.
   */
  listResourceTypes(
    req: operations.ListResourceTypesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListResourceTypesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListResourceTypesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/listresourcetypes";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListResourceTypesResponse =
        new operations.ListResourceTypesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listResourceTypesResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListResourceTypesResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidNextTokenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidParameterException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serverInternalException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists the resources that you added to a resource share or the resources that are shared with you.
   */
  listResources(
    req: operations.ListResourcesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListResourcesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListResourcesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/listresources";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListResourcesResponse =
        new operations.ListResourcesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listResourcesResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListResourcesResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidResourceTypeException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.unknownResourceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.malformedArnException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidNextTokenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidParameterException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serverInternalException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * <p>When you attach a resource-based permission policy to a resource, it automatically creates a resource share. However, resource shares created this way are visible only to the resource share owner, and the resource share can't be modified in RAM.</p> <p>You can use this operation to promote the resource share to a full RAM resource share. When you promote a resource share, you can then manage the resource share in RAM and it becomes visible to all of the principals you shared it with.</p>
   */
  promoteResourceShareCreatedFromPolicy(
    req: operations.PromoteResourceShareCreatedFromPolicyRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PromoteResourceShareCreatedFromPolicyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PromoteResourceShareCreatedFromPolicyRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/promoteresourcesharecreatedfrompolicy#resourceShareArn";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PromoteResourceShareCreatedFromPolicyResponse =
        new operations.PromoteResourceShareCreatedFromPolicyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.promoteResourceShareCreatedFromPolicyResponse =
              utils.objectToClass(
                httpRes?.data,
                shared.PromoteResourceShareCreatedFromPolicyResponse
              );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.malformedArnException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceShareLimitExceededException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationNotPermittedException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidParameterException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.missingRequiredParameterException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serverInternalException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 487:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.unknownResourceException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Rejects an invitation to a resource share from another Amazon Web Services account.
   */
  rejectResourceShareInvitation(
    req: operations.RejectResourceShareInvitationRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RejectResourceShareInvitationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RejectResourceShareInvitationRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/rejectresourceshareinvitation";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RejectResourceShareInvitationResponse =
        new operations.RejectResourceShareInvitationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.rejectResourceShareInvitationResponse = utils.objectToClass(
              httpRes?.data,
              shared.RejectResourceShareInvitationResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.malformedArnException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationNotPermittedException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceShareInvitationArnNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceShareInvitationAlreadyAcceptedException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceShareInvitationAlreadyRejectedException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceShareInvitationExpiredException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serverInternalException = httpRes?.data;
          }
          break;
        case httpRes?.status == 487:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 488:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidClientTokenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 489:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.idempotentParameterMismatchException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Adds the specified tag keys and values to the specified resource share. The tags are attached only to the resource share, not to the resources that are in the resource share.
   */
  tagResource(
    req: operations.TagResourceRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.TagResourceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TagResourceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/tagresource";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TagResourceResponse =
        new operations.TagResourceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tagResourceResponse = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidParameterException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.malformedArnException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.unknownResourceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tagLimitExceededException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceArnNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tagPolicyViolationException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serverInternalException = httpRes?.data;
          }
          break;
        case httpRes?.status == 487:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Removes the specified tag key and value pairs from the specified resource share.
   */
  untagResource(
    req: operations.UntagResourceRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UntagResourceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UntagResourceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/untagresource";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UntagResourceResponse =
        new operations.UntagResourceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.untagResourceResponse = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidParameterException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serverInternalException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Modifies some of the properties of the specified resource share.
   */
  updateResourceShare(
    req: operations.UpdateResourceShareRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateResourceShareResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateResourceShareRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/updateresourceshare";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateResourceShareResponse =
        new operations.UpdateResourceShareResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateResourceShareResponse = utils.objectToClass(
              httpRes?.data,
              shared.UpdateResourceShareResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.idempotentParameterMismatchException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.missingRequiredParameterException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.unknownResourceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.malformedArnException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidClientTokenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidParameterException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationNotPermittedException = httpRes?.data;
          }
          break;
        case httpRes?.status == 487:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serverInternalException = httpRes?.data;
          }
          break;
        case httpRes?.status == 488:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }
}
