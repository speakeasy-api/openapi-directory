<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class Networks 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * Adds a peering to the specified network.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksAddPeeringRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksAddPeeringSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksAddPeeringResponse
     */
	public function computeNetworksAddPeering(
        \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksAddPeeringRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksAddPeeringSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksAddPeeringResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/projects/{project}/global/networks/{network}/addPeering', \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksAddPeeringRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "networksAddPeeringRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ComputeNetworksAddPeeringRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksAddPeeringResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->operation = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Operation', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Deletes the specified network.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksDeleteRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksDeleteSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksDeleteResponse
     */
	public function computeNetworksDelete(
        \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksDeleteRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksDeleteSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksDeleteResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/projects/{project}/global/networks/{network}', \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksDeleteRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ComputeNetworksDeleteRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksDeleteResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->operation = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Operation', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Returns the specified network.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksGetRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksGetSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksGetResponse
     */
	public function computeNetworksGet(
        \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksGetRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksGetSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksGetResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/projects/{project}/global/networks/{network}', \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksGetRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ComputeNetworksGetRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksGetResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->network = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Network', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Returns the effective firewalls on a given network.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksGetEffectiveFirewallsRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksGetEffectiveFirewallsSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksGetEffectiveFirewallsResponse
     */
	public function computeNetworksGetEffectiveFirewalls(
        \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksGetEffectiveFirewallsRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksGetEffectiveFirewallsSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksGetEffectiveFirewallsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/projects/{project}/global/networks/{network}/getEffectiveFirewalls', \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksGetEffectiveFirewallsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ComputeNetworksGetEffectiveFirewallsRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksGetEffectiveFirewallsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->networksGetEffectiveFirewallsResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\NetworksGetEffectiveFirewallsResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Creates a network in the specified project using the data included in the request.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksInsertRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksInsertSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksInsertResponse
     */
	public function computeNetworksInsert(
        \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksInsertRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksInsertSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksInsertResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/projects/{project}/global/networks', \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksInsertRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "network", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ComputeNetworksInsertRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksInsertResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->operation = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Operation', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Retrieves the list of networks available to the specified project.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksListRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksListSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksListResponse
     */
	public function computeNetworksList(
        \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksListRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksListSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/projects/{project}/global/networks', \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksListRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ComputeNetworksListRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->networkList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\NetworkList', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Lists the peering routes exchanged over peering connection.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksListPeeringRoutesRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksListPeeringRoutesSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksListPeeringRoutesResponse
     */
	public function computeNetworksListPeeringRoutes(
        \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksListPeeringRoutesRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksListPeeringRoutesSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksListPeeringRoutesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/projects/{project}/global/networks/{network}/listPeeringRoutes', \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksListPeeringRoutesRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ComputeNetworksListPeeringRoutesRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksListPeeringRoutesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->exchangedPeeringRoutesList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ExchangedPeeringRoutesList', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Patches the specified network with the data included in the request. Only the following fields can be modified: routingConfig.routingMode.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksPatchRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksPatchSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksPatchResponse
     */
	public function computeNetworksPatch(
        \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksPatchRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksPatchSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksPatchResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/projects/{project}/global/networks/{network}', \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksPatchRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "network1", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ComputeNetworksPatchRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksPatchResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->operation = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Operation', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Removes a peering from the specified network.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksRemovePeeringRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksRemovePeeringSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksRemovePeeringResponse
     */
	public function computeNetworksRemovePeering(
        \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksRemovePeeringRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksRemovePeeringSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksRemovePeeringResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/projects/{project}/global/networks/{network}/removePeering', \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksRemovePeeringRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "networksRemovePeeringRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ComputeNetworksRemovePeeringRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksRemovePeeringResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->operation = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Operation', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Switches the network mode from auto subnet mode to custom subnet mode.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksSwitchToCustomModeRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksSwitchToCustomModeSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksSwitchToCustomModeResponse
     */
	public function computeNetworksSwitchToCustomMode(
        \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksSwitchToCustomModeRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksSwitchToCustomModeSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksSwitchToCustomModeResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/projects/{project}/global/networks/{network}/switchToCustomMode', \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksSwitchToCustomModeRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ComputeNetworksSwitchToCustomModeRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksSwitchToCustomModeResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->operation = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Operation', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Updates the specified network peering with the data included in the request. You can only modify the NetworkPeering.export_custom_routes field and the NetworkPeering.import_custom_routes field.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksUpdatePeeringRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksUpdatePeeringSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksUpdatePeeringResponse
     */
	public function computeNetworksUpdatePeering(
        \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksUpdatePeeringRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksUpdatePeeringSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksUpdatePeeringResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/projects/{project}/global/networks/{network}/updatePeering', \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksUpdatePeeringRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "networksUpdatePeeringRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ComputeNetworksUpdatePeeringRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ComputeNetworksUpdatePeeringResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->operation = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Operation', 'json');
            }
        }

        return $response;
    }
}