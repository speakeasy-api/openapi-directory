"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
from ..shared import daterangevalues as shared_daterangevalues
from ..shared import reportrow as shared_reportrow
from dataclasses_json import Undefined, dataclass_json
from sdk import utils
from typing import Optional


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class ReportData:
    r"""The data part of the report."""
    
    data_last_refreshed: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('dataLastRefreshed'), 'exclude': lambda f: f is None }})
    r"""The last time the data in the report was refreshed. All the hits received before this timestamp are included in the calculation of the report."""  
    empty_reason: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('emptyReason'), 'exclude': lambda f: f is None }})
    r"""If empty reason is specified, the report is empty for this reason."""  
    is_data_golden: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('isDataGolden'), 'exclude': lambda f: f is None }})
    r"""Indicates if response to this request is golden or not. Data is golden when the exact same request will not produce any new results if asked at a later point in time."""  
    maximums: Optional[list[shared_daterangevalues.DateRangeValues]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('maximums'), 'exclude': lambda f: f is None }})
    r"""Minimum and maximum values seen over all matching rows. These are both empty when `hideValueRanges` in the request is false, or when rowCount is zero."""  
    minimums: Optional[list[shared_daterangevalues.DateRangeValues]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('minimums'), 'exclude': lambda f: f is None }})
    r"""Minimum and maximum values seen over all matching rows. These are both empty when `hideValueRanges` in the request is false, or when rowCount is zero."""  
    row_count: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('rowCount'), 'exclude': lambda f: f is None }})
    r"""Total number of matching rows for this query."""  
    rows: Optional[list[shared_reportrow.ReportRow]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('rows'), 'exclude': lambda f: f is None }})
    r"""There's one ReportRow for every unique combination of dimensions."""  
    samples_read_counts: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('samplesReadCounts'), 'exclude': lambda f: f is None }})
    r"""If the results are [sampled](https://support.google.com/analytics/answer/2637192), this returns the total number of samples read, one entry per date range. If the results are not sampled this field will not be defined. See [developer guide](/analytics/devguides/reporting/core/v4/basics#sampling) for details."""  
    sampling_space_sizes: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('samplingSpaceSizes'), 'exclude': lambda f: f is None }})
    r"""If the results are [sampled](https://support.google.com/analytics/answer/2637192), this returns the total number of samples present, one entry per date range. If the results are not sampled this field will not be defined. See [developer guide](/analytics/devguides/reporting/core/v4/basics#sampling) for details."""  
    totals: Optional[list[shared_daterangevalues.DateRangeValues]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('totals'), 'exclude': lambda f: f is None }})
    r"""For each requested date range, for the set of all rows that match the query, every requested value format gets a total. The total for a value format is computed by first totaling the metrics mentioned in the value format and then evaluating the value format as a scalar expression. E.g., The \\"totals\\" for `3 / (ga:sessions + 2)` we compute `3 / ((sum of all relevant ga:sessions) + 2)`. Totals are computed before pagination."""  
    