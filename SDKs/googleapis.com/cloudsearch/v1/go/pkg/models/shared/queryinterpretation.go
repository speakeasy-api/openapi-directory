// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
)

type QueryInterpretationInterpretationTypeEnum string

const (
	QueryInterpretationInterpretationTypeEnumNone    QueryInterpretationInterpretationTypeEnum = "NONE"
	QueryInterpretationInterpretationTypeEnumBlend   QueryInterpretationInterpretationTypeEnum = "BLEND"
	QueryInterpretationInterpretationTypeEnumReplace QueryInterpretationInterpretationTypeEnum = "REPLACE"
)

func (e *QueryInterpretationInterpretationTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "NONE":
		fallthrough
	case "BLEND":
		fallthrough
	case "REPLACE":
		*e = QueryInterpretationInterpretationTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for QueryInterpretationInterpretationTypeEnum: %s", s)
	}
}

// QueryInterpretationReasonEnum - The reason for interpretation of the query. This field will not be UNSPECIFIED if the interpretation type is not NONE.
type QueryInterpretationReasonEnum string

const (
	QueryInterpretationReasonEnumUnspecified                       QueryInterpretationReasonEnum = "UNSPECIFIED"
	QueryInterpretationReasonEnumQueryHasNaturalLanguageIntent     QueryInterpretationReasonEnum = "QUERY_HAS_NATURAL_LANGUAGE_INTENT"
	QueryInterpretationReasonEnumNotEnoughResultsFoundForUserQuery QueryInterpretationReasonEnum = "NOT_ENOUGH_RESULTS_FOUND_FOR_USER_QUERY"
)

func (e *QueryInterpretationReasonEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "UNSPECIFIED":
		fallthrough
	case "QUERY_HAS_NATURAL_LANGUAGE_INTENT":
		fallthrough
	case "NOT_ENOUGH_RESULTS_FOUND_FOR_USER_QUERY":
		*e = QueryInterpretationReasonEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for QueryInterpretationReasonEnum: %s", s)
	}
}

type QueryInterpretation struct {
	InterpretationType *QueryInterpretationInterpretationTypeEnum `json:"interpretationType,omitempty"`
	// The interpretation of the query used in search. For example, queries with natural language intent like "email from john" will be interpreted as "from:john source:mail". This field will not be filled when the reason is NOT_ENOUGH_RESULTS_FOUND_FOR_USER_QUERY.
	InterpretedQuery *string `json:"interpretedQuery,omitempty"`
	// The reason for interpretation of the query. This field will not be UNSPECIFIED if the interpretation type is not NONE.
	Reason *QueryInterpretationReasonEnum `json:"reason,omitempty"`
}
