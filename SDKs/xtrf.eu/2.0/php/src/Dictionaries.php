<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class Dictionaries 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * Returns active dictionary entities for all types.
     * 
     * Returns active dictionary entities for all types.
     * 
     * @return \OpenAPI\OpenAPI\Models\Operations\GetActiveResponse
     */
	public function getActive(
    ): \OpenAPI\OpenAPI\Models\Operations\GetActiveResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/dictionaries/active');
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetActiveResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if (true) { /** @phpstan-ignore-line */
            if (Utils\Utils::matchContentType($contentType, 'application/vnd.xtrf-v1+json;charset=UTF-8')) {
                $serializer = Utils\JSON::createSerializer();
                $response->manyValuesPerTypeDTO = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ManyValuesPerTypeDTO', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Returns active values from a given dictionary.
     * 
     * Returns active values from a given dictionary.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetActiveByTypeRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetActiveByTypeResponse
     */
	public function getActiveByType(
        \OpenAPI\OpenAPI\Models\Operations\GetActiveByTypeRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetActiveByTypeResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/dictionaries/{type}/active', \OpenAPI\OpenAPI\Models\Operations\GetActiveByTypeRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetActiveByTypeRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetActiveByTypeResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if (true) { /** @phpstan-ignore-line */
            if (Utils\Utils::matchContentType($contentType, 'application/vnd.xtrf-v1+json;charset=UTF-8')) {
                $serializer = Utils\JSON::createSerializer();
                $response->dictionaryEntity = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\DictionaryEntity', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Returns active services list
     * 
     * Returns active workflows list
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetAllActiveRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetAllActiveResponse
     */
	public function getAllActive(
        \OpenAPI\OpenAPI\Models\Operations\GetAllActiveRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetAllActiveResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/services/active');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetAllActiveRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetAllActiveResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if (true) { /** @phpstan-ignore-line */
            if (Utils\Utils::matchContentType($contentType, 'application/vnd.xtrf-v1+json;charset=UTF-8')) {
                $serializer = Utils\JSON::createSerializer();
                $response->serviceDTO = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ServiceDTO', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Returns all values (both active and not active) from a given dictionary.
     * 
     * Returns all values (both active and not active) from a given dictionary.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetAllByTypeRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetAllByTypeResponse
     */
	public function getAllByType(
        \OpenAPI\OpenAPI\Models\Operations\GetAllByTypeRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetAllByTypeResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/dictionaries/{type}/all', \OpenAPI\OpenAPI\Models\Operations\GetAllByTypeRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetAllByTypeRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetAllByTypeResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if (true) { /** @phpstan-ignore-line */
            if (Utils\Utils::matchContentType($contentType, 'application/vnd.xtrf-v1+json;charset=UTF-8')) {
                $serializer = Utils\JSON::createSerializer();
                $response->dictionaryEntity = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\DictionaryEntity', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Returns dictionary entities for all types. Both active and not active ones.
     * 
     * <div>
     *   <p>
     *     XTRF holds many user-defined dictionaries (ie. countries).
     *     Each dictionary contains a set of values (ie. Poland or Germany).
     *     A default value may be defined for a dictionary.
     *   </p>
     *   <p>
     *     Dictionary values are identified using internal identifier which is constant and unique among other values from the same dictionary.
     *     Please note that name used in dictionary values is presented in the locale of the current identity.
     *     The same dictionary value can have different names, ie. "Poland" for one user, "Polska" for another one.
     *   </p>
     *   <p>
     *     Possible dictionary types with short explanation:
     *     <ul>
     *       <li>calculationUnit - predefined values of how to calculate the volume of work into the price</li>
     *       <li>category - labels to organize data on the platform</li>
     *       <li>country - list of countries used on the platform</li>
     *       <li>currency - currencies used in financial operations in the system</li>
     *       <li>industry - industry sectors which clients specialize in</li>
     *       <li>jobType - services offered by a company used in customized workflows</li>
     *       <li>language - list of languages and its values used on the platform</li>
     *       <li>leadSource - lead/recruitment places where new clients and vendors may be found</li>
     *       <li>personDepartment - departments in which contact person may be assigned to</li>
     *       <li>personPosition - positions in which user may be associated with</li>
     *       <li>province - states and provinces used in various documents on the platform</li>
     *       <li>specialization - list of specific qualifications required to perform a specific job in the task, for ex. medical, military</li>
     *     </ul>
     *   </p>
     * </div>
     * 
     * @return \OpenAPI\OpenAPI\Models\Operations\GetAll1Response
     */
	public function getAll1(
    ): \OpenAPI\OpenAPI\Models\Operations\GetAll1Response
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/dictionaries/all');
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetAll1Response();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if (true) { /** @phpstan-ignore-line */
            if (Utils\Utils::matchContentType($contentType, 'application/vnd.xtrf-v1+json;charset=UTF-8')) {
                $serializer = Utils\JSON::createSerializer();
                $response->manyValuesPerTypeDTO = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ManyValuesPerTypeDTO', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Returns services list
     * 
     * Returns workflows list. Both active and not active ones.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetAll3Request $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetAll3Response
     */
	public function getAll3(
        \OpenAPI\OpenAPI\Models\Operations\GetAll3Request $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetAll3Response
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/services/all');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetAll3Request::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetAll3Response();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if (true) { /** @phpstan-ignore-line */
            if (Utils\Utils::matchContentType($contentType, 'application/vnd.xtrf-v1+json;charset=UTF-8')) {
                $serializer = Utils\JSON::createSerializer();
                $response->serviceDTO = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ServiceDTO', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Returns specific value from a given dictionary.
     * 
     * Returns specific value from a given dictionary.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetByTypeAndIdRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetByTypeAndIdResponse
     */
	public function getByTypeAndId(
        \OpenAPI\OpenAPI\Models\Operations\GetByTypeAndIdRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetByTypeAndIdResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/dictionaries/{type}/{id}', \OpenAPI\OpenAPI\Models\Operations\GetByTypeAndIdRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetByTypeAndIdResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if (true) { /** @phpstan-ignore-line */
            if (Utils\Utils::matchContentType($contentType, 'application/vnd.xtrf-v1+json;charset=UTF-8')) {
                $serializer = Utils\JSON::createSerializer();
                $response->dictionaryEntity = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\DictionaryEntity', 'json');
            }
        }

        return $response;
    }
}