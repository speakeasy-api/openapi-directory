/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Administration {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Delete a client
   */
  deleteClientsIdClient(
    req: operations.DeleteClientsIdClientRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteClientsIdClientResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteClientsIdClientRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/clients/{id_client}", req);

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteClientsIdClientResponse =
        new operations.DeleteClientsIdClientResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.client = utils.objectToClass(httpRes?.data, shared.Client);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete the client logo
   */
  deleteClientsIdClientLogo(
    req: operations.DeleteClientsIdClientLogoRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteClientsIdClientLogoResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteClientsIdClientLogoRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/clients/{id_client}/logo",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteClientsIdClientLogoResponse =
        new operations.DeleteClientsIdClientLogoResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.file = utils.objectToClass(httpRes?.data, shared.File);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes all webhooks
   *
   * @remarks
   * Updates the deleted field with the date of the deletion<br><br>
   */
  deleteWebhooks(
    req: operations.DeleteWebhooksRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteWebhooksResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteWebhooksRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/webhooks";

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteWebhooksResponse =
        new operations.DeleteWebhooksResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.webhook = utils.objectToClass(httpRes?.data, shared.Webhook);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes all webhook authentication types
   */
  deleteWebhooksAuth(
    req: operations.DeleteWebhooksAuthRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteWebhooksAuthResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteWebhooksAuthRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/webhooks/auth";

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteWebhooksAuthResponse =
        new operations.DeleteWebhooksAuthResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.authProvider = utils.objectToClass(
              httpRes?.data,
              shared.AuthProvider
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes the webhook authentication type
   *
   * @remarks
   * Updates the deleted field with the date of the deletion<br><br>
   */
  deleteWebhooksAuthIdAuth(
    req: operations.DeleteWebhooksAuthIdAuthRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteWebhooksAuthIdAuthResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteWebhooksAuthIdAuthRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/webhooks/auth/{id_auth}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteWebhooksAuthIdAuthResponse =
        new operations.DeleteWebhooksAuthIdAuthResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.authProvider = utils.objectToClass(
              httpRes?.data,
              shared.AuthProvider
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes a webhook
   *
   * @remarks
   * Updates the deleted field with the date of the deletion<br><br>
   */
  deleteWebhooksIdWebhook(
    req: operations.DeleteWebhooksIdWebhookRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteWebhooksIdWebhookResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteWebhooksIdWebhookRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/webhooks/{id_webhook}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteWebhooksIdWebhookResponse =
        new operations.DeleteWebhooksIdWebhookResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.webhook = utils.objectToClass(httpRes?.data, shared.Webhook);
          }
          break;
      }

      return res;
    });
  }

  /**
   * delete all entries
   */
  deleteWebhooksIdWebhookAddToData(
    req: operations.DeleteWebhooksIdWebhookAddToDataRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteWebhooksIdWebhookAddToDataResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteWebhooksIdWebhookAddToDataRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/webhooks/{id_webhook}/add_to_data",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteWebhooksIdWebhookAddToDataResponse =
        new operations.DeleteWebhooksIdWebhookAddToDataResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.webhook = utils.objectToClass(httpRes?.data, shared.Webhook);
          }
          break;
      }

      return res;
    });
  }

  /**
   * delete the requested entry
   */
  deleteWebhooksIdWebhookAddToDataKey(
    req: operations.DeleteWebhooksIdWebhookAddToDataKeyRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteWebhooksIdWebhookAddToDataKeyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteWebhooksIdWebhookAddToDataKeyRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/webhooks/{id_webhook}/add_to_data/{key}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteWebhooksIdWebhookAddToDataKeyResponse =
        new operations.DeleteWebhooksIdWebhookAddToDataKeyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.webhook = utils.objectToClass(httpRes?.data, shared.Webhook);
          }
          break;
      }

      return res;
    });
  }

  /**
   * List clients
   */
  getClients(
    req: operations.GetClientsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetClientsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetClientsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/clients";

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetClientsResponse =
        new operations.GetClientsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getClients200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.GetClients200ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get information about a client
   *
   * @remarks
   * If you use the manage_token or a configuration token, you will get also the client secret.<br><br>
   */
  getClientsIdClient(
    req: operations.GetClientsIdClientRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetClientsIdClientResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetClientsIdClientRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/clients/{id_client}", req);

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetClientsIdClientResponse =
        new operations.GetClientsIdClientResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.client = utils.objectToClass(httpRes?.data, shared.Client);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get configuration of the API.
   *
   * @remarks
   * <br><br>
   */
  getConfig(
    req: operations.GetConfigRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetConfigResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetConfigRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/config";

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetConfigResponse =
        new operations.GetConfigResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Get configuration change history of the API.
   *
   * @remarks
   * <br><br>
   */
  getConfigLogs(
    req: operations.GetConfigLogsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetConfigLogsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetConfigLogsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/config/logs";

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetConfigLogsResponse =
        new operations.GetConfigLogsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getConfigLogs200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.GetConfigLogs200ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * get performances stats on this instance
   */
  getMonitoring(
    req: operations.GetMonitoringRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetMonitoringResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetMonitoringRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/monitoring";

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetMonitoringResponse =
        new operations.GetMonitoringResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Get public encryption key of the API.
   */
  getPublickey(
    config?: AxiosRequestConfig
  ): Promise<operations.GetPublickeyResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/publickey";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetPublickeyResponse =
        new operations.GetPublickeyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Get webhooks
   */
  getWebhooks(
    req: operations.GetWebhooksRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetWebhooksResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetWebhooksRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/webhooks";

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetWebhooksResponse =
        new operations.GetWebhooksResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getWebhooks200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.GetWebhooks200ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get webhooks authentication types
   */
  getWebhooksAuth(
    req: operations.GetWebhooksAuthRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetWebhooksAuthResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetWebhooksAuthRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/webhooks/auth";

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetWebhooksAuthResponse =
        new operations.GetWebhooksAuthResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getWebhooksAuth200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.GetWebhooksAuth200ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * retrieve the list of the value to add in webhooks when sending the requested webhook
   */
  getWebhooksIdWebhookAddToData(
    req: operations.GetWebhooksIdWebhookAddToDataRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetWebhooksIdWebhookAddToDataResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetWebhooksIdWebhookAddToDataRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/webhooks/{id_webhook}/add_to_data",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetWebhooksIdWebhookAddToDataResponse =
        new operations.GetWebhooksIdWebhookAddToDataResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getWebhooksIdWebhookAddToData200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetWebhooksIdWebhookAddToData200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * retrieve the value to add in the requested webhook for the requested name
   */
  getWebhooksIdWebhookAddToDataKey(
    req: operations.GetWebhooksIdWebhookAddToDataKeyRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetWebhooksIdWebhookAddToDataKeyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetWebhooksIdWebhookAddToDataKeyRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/webhooks/{id_webhook}/add_to_data/{key}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetWebhooksIdWebhookAddToDataKeyResponse =
        new operations.GetWebhooksIdWebhookAddToDataKeyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.webhook = utils.objectToClass(httpRes?.data, shared.Webhook);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get webhooks logs.
   *
   * @remarks
   * Get logs of the webhooks.<br><br>By default, it selects logs for the last month. You can use "min_date" and "max_date" to change boundary dates.<br><br>
   */
  getWebhooksIdWebhookLogs(
    req: operations.GetWebhooksIdWebhookLogsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetWebhooksIdWebhookLogsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetWebhooksIdWebhookLogsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/webhooks/{id_webhook}/logs",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetWebhooksIdWebhookLogsResponse =
        new operations.GetWebhooksIdWebhookLogsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getWebhooksIdWebhookLogs200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetWebhooksIdWebhookLogs200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a client
   */
  postClients(
    req: operations.PostClientsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PostClientsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostClientsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/clients";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostClientsResponse =
        new operations.PostClientsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.client = utils.objectToClass(httpRes?.data, shared.Client);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update the client logo
   */
  postClientsIdClientLogo(
    req: operations.PostClientsIdClientLogoRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PostClientsIdClientLogoResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostClientsIdClientLogoRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/clients/{id_client}/logo",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostClientsIdClientLogoResponse =
        new operations.PostClientsIdClientLogoResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.file = utils.objectToClass(httpRes?.data, shared.File);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Insert/update configuration key(s)/value(s) on the API.
   */
  postConfig(
    config?: AxiosRequestConfig
  ): Promise<operations.PostConfigResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/config";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostConfigResponse =
        new operations.PostConfigResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Test synchronization on a random connection.
   *
   * @remarks
   * It can be used to test receiving data on your webhooks.<br><br>
   */
  postTestSync(
    config?: AxiosRequestConfig
  ): Promise<operations.PostTestSyncResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/test/sync";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostTestSyncResponse =
        new operations.PostTestSyncResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Test synchronization on a random connection.
   *
   * @remarks
   * It can be used to test receiving data on your webhooks.<br><br>
   */
  postTestWebhooks(
    config?: AxiosRequestConfig
  ): Promise<operations.PostTestWebhooksResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/test/webhooks";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostTestWebhooksResponse =
        new operations.PostTestWebhooksResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Adds a new webhook
   */
  postWebhooks(
    req: operations.PostWebhooksRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PostWebhooksResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostWebhooksRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/webhooks";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostWebhooksResponse =
        new operations.PostWebhooksResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.webhook = utils.objectToClass(httpRes?.data, shared.Webhook);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Adds a new webhook authentication type
   */
  postWebhooksAuth(
    req: operations.PostWebhooksAuthRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PostWebhooksAuthResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostWebhooksAuthRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/webhooks/auth";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostWebhooksAuthResponse =
        new operations.PostWebhooksAuthResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.authProvider = utils.objectToClass(
              httpRes?.data,
              shared.AuthProvider
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates the webhook authentication type
   */
  postWebhooksAuthIdAuth(
    req: operations.PostWebhooksAuthIdAuthRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PostWebhooksAuthIdAuthResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostWebhooksAuthIdAuthRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/webhooks/auth/{id_auth}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostWebhooksAuthIdAuthResponse =
        new operations.PostWebhooksAuthIdAuthResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.authProvider = utils.objectToClass(
              httpRes?.data,
              shared.AuthProvider
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates a webhook
   */
  postWebhooksIdWebhook(
    req: operations.PostWebhooksIdWebhookRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PostWebhooksIdWebhookResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostWebhooksIdWebhookRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/webhooks/{id_webhook}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostWebhooksIdWebhookResponse =
        new operations.PostWebhooksIdWebhookResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.webhook = utils.objectToClass(httpRes?.data, shared.Webhook);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Setup a field to store in user config when calling the endpoint
   *
   * @remarks
   * For each parameter, a value will be added in the webhook data. Use the key to set the name of the field. The values that can be added are to be found in the user configuration.<br><br>
   */
  postWebhooksIdWebhookAddToData(
    req: operations.PostWebhooksIdWebhookAddToDataRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PostWebhooksIdWebhookAddToDataResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostWebhooksIdWebhookAddToDataRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/webhooks/{id_webhook}/add_to_data",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostWebhooksIdWebhookAddToDataResponse =
        new operations.PostWebhooksIdWebhookAddToDataResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.webhook = utils.objectToClass(httpRes?.data, shared.Webhook);
          }
          break;
      }

      return res;
    });
  }

  /**
   * upate the requested field to store in user config when calling the endpoint
   *
   * @remarks
   * For each parameter, a value will be added in the webhook data. Use the key to set the name of the field. The values that can be added are to be found in the user configuration.<br><br>
   */
  postWebhooksIdWebhookAddToDataKey(
    req: operations.PostWebhooksIdWebhookAddToDataKeyRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PostWebhooksIdWebhookAddToDataKeyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostWebhooksIdWebhookAddToDataKeyRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/webhooks/{id_webhook}/add_to_data/{key}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostWebhooksIdWebhookAddToDataKeyResponse =
        new operations.PostWebhooksIdWebhookAddToDataKeyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.webhook = utils.objectToClass(httpRes?.data, shared.Webhook);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update a client
   */
  putClientsIdClient(
    req: operations.PutClientsIdClientRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PutClientsIdClientResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PutClientsIdClientRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/clients/{id_client}", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutClientsIdClientResponse =
        new operations.PutClientsIdClientResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.client = utils.objectToClass(httpRes?.data, shared.Client);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates the webhook authentication type
   */
  putWebhooksAuthIdAuth(
    req: operations.PutWebhooksAuthIdAuthRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PutWebhooksAuthIdAuthResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PutWebhooksAuthIdAuthRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/webhooks/auth/{id_auth}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutWebhooksAuthIdAuthResponse =
        new operations.PutWebhooksAuthIdAuthResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.authProvider = utils.objectToClass(
              httpRes?.data,
              shared.AuthProvider
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates a webhook
   */
  putWebhooksIdWebhook(
    req: operations.PutWebhooksIdWebhookRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PutWebhooksIdWebhookResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PutWebhooksIdWebhookRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/webhooks/{id_webhook}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutWebhooksIdWebhookResponse =
        new operations.PutWebhooksIdWebhookResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.webhook = utils.objectToClass(httpRes?.data, shared.Webhook);
          }
          break;
      }

      return res;
    });
  }
}
