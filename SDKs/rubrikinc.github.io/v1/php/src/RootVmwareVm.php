<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class RootVmwareVm 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * Live mount a snapshot each from a set of virtual machines
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\BatchMountSnapshotJobConfig $request
     * @return \OpenAPI\OpenAPI\Models\Operations\BatchMountSnapshotResponse
     */
	public function batchMountSnapshot(
        \OpenAPI\OpenAPI\Models\Shared\BatchMountSnapshotJobConfig $request,
    ): \OpenAPI\OpenAPI\Models\Operations\BatchMountSnapshotResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/vmware/vm/batch_mount');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\BatchMountSnapshotResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 202) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->batchAsyncRequestStatus = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\BatchAsyncRequestStatus', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List files in VM snapshot
     * 
     * For a virtual machine snapshot, list the directories and files that are beneath a specified file system path.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\BrowseVmwareSnapshotRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\BrowseVmwareSnapshotResponse
     */
	public function browseVmwareSnapshot(
        \OpenAPI\OpenAPI\Models\Operations\BrowseVmwareSnapshotRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\BrowseVmwareSnapshotResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/vmware/vm/snapshot/{id}/browse', \OpenAPI\OpenAPI\Models\Operations\BrowseVmwareSnapshotRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\BrowseVmwareSnapshotRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\BrowseVmwareSnapshotResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->browseResponseListResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\BrowseResponseListResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Take an on-demand snapshot of multiple virtual machines
     * 
     * Bulk operation of taking on-demand snapshot for given virtual machines.
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\BulkOnDemandSnapshotJobConfig $request
     * @return \OpenAPI\OpenAPI\Models\Operations\BulkCreateOnDemandBackupResponse
     */
	public function bulkCreateOnDemandBackup(
        \OpenAPI\OpenAPI\Models\Shared\BulkOnDemandSnapshotJobConfig $request,
    ): \OpenAPI\OpenAPI\Models\Operations\BulkCreateOnDemandBackupResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/vmware/vm/snapshot/bulk');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\BulkCreateOnDemandBackupResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 202) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->batchAsyncRequestStatus = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\BatchAsyncRequestStatus', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Download file from VM snapshot
     * 
     * Create a request to download a file from a virtual machine snapshot.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateDownloadFileJobRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateDownloadFileJobResponse
     */
	public function createDownloadFileJob(
        \OpenAPI\OpenAPI\Models\Operations\CreateDownloadFileJobRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateDownloadFileJobResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/vmware/vm/snapshot/{id}/download_file', \OpenAPI\OpenAPI\Models\Operations\CreateDownloadFileJobRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "downloadFileJobConfig", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateDownloadFileJobResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 202) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->asyncRequestStatus = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AsyncRequestStatus', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Download snapshot from archive
     * 
     * Provides a method for retrieving a snapshot, that is not available locally, from an archival location.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateDownloadSnapshotFromCloudRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateDownloadSnapshotFromCloudResponse
     */
	public function createDownloadSnapshotFromCloud(
        \OpenAPI\OpenAPI\Models\Operations\CreateDownloadSnapshotFromCloudRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateDownloadSnapshotFromCloudResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/vmware/vm/snapshot/{id}/download', \OpenAPI\OpenAPI\Models\Operations\CreateDownloadSnapshotFromCloudRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateDownloadSnapshotFromCloudResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 202) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->asyncRequestStatus = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AsyncRequestStatus', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Export VM snapshot
     * 
     * Export a virtual machine from a snapshot, using a specified hypervisor host as the datastore.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateExportV1Request $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateExportV1Response
     */
	public function createExportV1(
        \OpenAPI\OpenAPI\Models\Operations\CreateExportV1Request $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateExportV1Response
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/vmware/vm/snapshot/{id}/export', \OpenAPI\OpenAPI\Models\Operations\CreateExportV1Request::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "exportSnapshotJobConfigV1", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateExportV1Response();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 202) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->asyncRequestStatus = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AsyncRequestStatus', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Download a snapshot from an archival location, then export a virtual machine using the downloaded snapshot
     * 
     * Download a snapshot from an archival location and then export a virtual machine using the downloaded snapshot.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateExportWithDownloadFromCloudV1Request $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateExportWithDownloadFromCloudV1Response
     */
	public function createExportWithDownloadFromCloudV1(
        \OpenAPI\OpenAPI\Models\Operations\CreateExportWithDownloadFromCloudV1Request $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateExportWithDownloadFromCloudV1Response
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/vmware/vm/snapshot/{id}/export_with_download', \OpenAPI\OpenAPI\Models\Operations\CreateExportWithDownloadFromCloudV1Request::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "exportSnapshotJobConfigV1", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateExportWithDownloadFromCloudV1Response();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 202) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->asyncRequestStatus = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AsyncRequestStatus', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Instantly recover a VM
     * 
     * Instantly recovery a virtual machine from a snapshot. The Instant Recovery request starts the virtual machine with networking enabled and renames and powers off the source virtual machine, if it still exists.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateInstantRecoveryRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateInstantRecoveryResponse
     */
	public function createInstantRecovery(
        \OpenAPI\OpenAPI\Models\Operations\CreateInstantRecoveryRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateInstantRecoveryResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/vmware/vm/snapshot/{id}/instant_recover', \OpenAPI\OpenAPI\Models\Operations\CreateInstantRecoveryRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "instantRecoveryJobConfig", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateInstantRecoveryResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 202) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->asyncRequestStatus = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AsyncRequestStatus', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Live mount a VM from a snapshot
     * 
     * Create a request to Live Mount a virtual machine from a snapshot using a specified configuration.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateMountV1Request $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateMountV1Response
     */
	public function createMountV1(
        \OpenAPI\OpenAPI\Models\Operations\CreateMountV1Request $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateMountV1Response
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/vmware/vm/snapshot/{id}/mount', \OpenAPI\OpenAPI\Models\Operations\CreateMountV1Request::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "mountSnapshotJobConfigV1", "json");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateMountV1Response();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 202) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->asyncRequestStatus = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AsyncRequestStatus', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create an on-demand snapshot for a VM
     * 
     * Use the ID of a virtual machine to create an on-demand snapshot.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateOnDemandBackupRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateOnDemandBackupResponse
     */
	public function createOnDemandBackup(
        \OpenAPI\OpenAPI\Models\Operations\CreateOnDemandBackupRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateOnDemandBackupResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/vmware/vm/{id}/snapshot', \OpenAPI\OpenAPI\Models\Operations\CreateOnDemandBackupRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "baseOnDemandSnapshotConfig", "json");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateOnDemandBackupResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 202) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->asyncRequestStatus = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AsyncRequestStatus', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Restore file from VM snapshot
     * 
     * Create a request to restore a file or folder to the source virtual machine.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateRestoreFileJobRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateRestoreFileJobResponse
     */
	public function createRestoreFileJob(
        \OpenAPI\OpenAPI\Models\Operations\CreateRestoreFileJobRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateRestoreFileJobResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/vmware/vm/snapshot/{id}/restore_file', \OpenAPI\OpenAPI\Models\Operations\CreateRestoreFileJobRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "restoreFileJobConfig", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateRestoreFileJobResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 202) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->asyncRequestStatus = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AsyncRequestStatus', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Delete a Live Mount VM
     * 
     * Create a request to delete a Live Mount virtual machine.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateUnmountRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateUnmountResponse
     */
	public function createUnmount(
        \OpenAPI\OpenAPI\Models\Operations\CreateUnmountRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateUnmountResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/vmware/vm/snapshot/mount/{id}', \OpenAPI\OpenAPI\Models\Operations\CreateUnmountRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\CreateUnmountRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateUnmountResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 202) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->asyncRequestStatus = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AsyncRequestStatus', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Delete VM snapshot
     * 
     * Designate a snapshot as expired and available for garbage collection. The snapshot must be an on-demand snapshot or a snapshot from a virtual machine that is not assigned to an SLA Domain.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteVmwareSnapshotRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteVmwareSnapshotResponse
     */
	public function deleteVmwareSnapshot(
        \OpenAPI\OpenAPI\Models\Operations\DeleteVmwareSnapshotRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteVmwareSnapshotResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/vmware/vm/snapshot/{id}', \OpenAPI\OpenAPI\Models\Operations\DeleteVmwareSnapshotRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DeleteVmwareSnapshotRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteVmwareSnapshotResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
	
    /**
     * Delete all snapshots of VM
     * 
     * Delete all of the snapshots from a virtual machine.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteVmwareSnapshotsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteVmwareSnapshotsResponse
     */
	public function deleteVmwareSnapshots(
        \OpenAPI\OpenAPI\Models\Operations\DeleteVmwareSnapshotsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteVmwareSnapshotsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/vmware/vm/{id}/snapshot', \OpenAPI\OpenAPI\Models\Operations\DeleteVmwareSnapshotsRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteVmwareSnapshotsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
	
    /**
     * Get asynchronous request details for VM
     * 
     * Get the details of an asynchronous request that involves a VMware virtual machine.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetAsyncRequestStatusRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetAsyncRequestStatusResponse
     */
	public function getAsyncRequestStatus(
        \OpenAPI\OpenAPI\Models\Operations\GetAsyncRequestStatusRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetAsyncRequestStatusResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/vmware/vm/request/{id}', \OpenAPI\OpenAPI\Models\Operations\GetAsyncRequestStatusRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetAsyncRequestStatusResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->asyncRequestStatus = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AsyncRequestStatus', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get information for a Live Mount
     * 
     * Retrieve detailed information for a specified Live Mount.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetMountV1Request $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetMountV1Response
     */
	public function getMountV1(
        \OpenAPI\OpenAPI\Models\Operations\GetMountV1Request $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetMountV1Response
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/vmware/vm/snapshot/mount/{id}', \OpenAPI\OpenAPI\Models\Operations\GetMountV1Request::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetMountV1Response();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->vmwareVmMountDetailV1 = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\VmwareVmMountDetailV1', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get VM snapshot details
     * 
     * Retrieve detailed information about a virtual machine snapshot.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetSnapshotRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetSnapshotResponse
     */
	public function getSnapshot(
        \OpenAPI\OpenAPI\Models\Operations\GetSnapshotRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetSnapshotResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/vmware/vm/snapshot/{id}', \OpenAPI\OpenAPI\Models\Operations\GetSnapshotRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetSnapshotResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->vmSnapshotDetail = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\VmSnapshotDetail', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Details about the specific Virtual Disk
     * 
     * Detailed about the specific Virtual Disk.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetVirtualDiskRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetVirtualDiskResponse
     */
	public function getVirtualDisk(
        \OpenAPI\OpenAPI\Models\Operations\GetVirtualDiskRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetVirtualDiskResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/vmware/vm/virtual_disk/{id}', \OpenAPI\OpenAPI\Models\Operations\GetVirtualDiskRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetVirtualDiskResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->virtualDiskDetail = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\VirtualDiskDetail', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get VM details
     * 
     * Retrieve details for a virtual machine.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetVmRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetVmResponse
     */
	public function getVm(
        \OpenAPI\OpenAPI\Models\Operations\GetVmRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetVmResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/vmware/vm/{id}', \OpenAPI\OpenAPI\Models\Operations\GetVmRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetVmResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->virtualMachineDetail = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\VirtualMachineDetail', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Retrieve the configuration for forcing a full snapshot of a VMware virtual machine
     * 
     * Retrieve the configuration that has been set for forcing a full snapshot for a VMware virtual machine.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetVmForceFullSpecRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetVmForceFullSpecResponse
     */
	public function getVmForceFullSpec(
        \OpenAPI\OpenAPI\Models\Operations\GetVmForceFullSpecRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetVmForceFullSpecResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/vmware/vm/{id}/request/force_full_snapshot', \OpenAPI\OpenAPI\Models\Operations\GetVmForceFullSpecRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetVmForceFullSpecResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->vmForceFullResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\VmForceFullResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Returns the live CDP info for a set of CDP-enabled virtual machines
     * 
     * @param array<string> $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetVmwareCdpLiveInfoResponse
     */
	public function getVmwareCdpLiveInfo(
        array $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetVmwareCdpLiveInfoResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/vmware/vm/cdp');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetVmwareCdpLiveInfoResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->batchVmwareCdpLiveInfo = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\BatchVmwareCdpLiveInfo', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Returns CDP state info for a set of virtual machines
     * 
     * @param array<string> $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetVmwareCdpStateInfoResponse
     */
	public function getVmwareCdpStateInfo(
        array $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetVmwareCdpStateInfoResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/vmware/vm/cdp_state');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetVmwareCdpStateInfoResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->batchVmwareCdpStateInfo = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\BatchVmwareCdpStateInfo', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get missed time ranges for point in time recovery
     * 
     * Gets a list of time ranges to which a CDP-enabled virtual machine cannot perform a point-in-time recovery. The time ranges are indicated by start and end timestamps listed as date-time strings.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetVmwareMissedRecoverableRangesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetVmwareMissedRecoverableRangesResponse
     */
	public function getVmwareMissedRecoverableRanges(
        \OpenAPI\OpenAPI\Models\Operations\GetVmwareMissedRecoverableRangesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetVmwareMissedRecoverableRangesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/vmware/vm/{id}/missed_recoverable_range', \OpenAPI\OpenAPI\Models\Operations\GetVmwareMissedRecoverableRangesRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetVmwareMissedRecoverableRangesRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetVmwareMissedRecoverableRangesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->vmwareRecoverableRangeListResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\VmwareRecoverableRangeListResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get available time ranges for point in time recovery
     * 
     * Gets time ranges available for point-in-time recovery. The time ranges are indicated by start and end date-time strings.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetVmwareRecoverableRangesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetVmwareRecoverableRangesResponse
     */
	public function getVmwareRecoverableRanges(
        \OpenAPI\OpenAPI\Models\Operations\GetVmwareRecoverableRangesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetVmwareRecoverableRangesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/vmware/vm/{id}/recoverable_range', \OpenAPI\OpenAPI\Models\Operations\GetVmwareRecoverableRangesRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetVmwareRecoverableRangesRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetVmwareRecoverableRangesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->vmwareRecoverableRangeListResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\VmwareRecoverableRangeListResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Returns the recoverable ranges that were missed for a set of CDP-enabled virtual machines
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\BatchVmwareVmMissedRecoverableRangesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetVmwareVmMissedRecoverableRangesInBatchResponse
     */
	public function getVmwareVmMissedRecoverableRangesInBatch(
        \OpenAPI\OpenAPI\Models\Shared\BatchVmwareVmMissedRecoverableRangesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetVmwareVmMissedRecoverableRangesInBatchResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/vmware/vm/missed_recoverable_range');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetVmwareVmMissedRecoverableRangesInBatchResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->batchVmwareVmMissedRecoverableRanges = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\BatchVmwareVmMissedRecoverableRanges', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Returns the recoverable ranges for a set of CDP-enabled virtual machines
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\BatchVmwareVmRecoverableRangesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetVmwareVmRecoverableRangesInBatchResponse
     */
	public function getVmwareVmRecoverableRangesInBatch(
        \OpenAPI\OpenAPI\Models\Shared\BatchVmwareVmRecoverableRangesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetVmwareVmRecoverableRangesInBatchResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/vmware/vm/recoverable_range');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetVmwareVmRecoverableRangesInBatchResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->batchVmwareVmRecoverableRanges = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\BatchVmwareVmRecoverableRanges', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get details about missed snapshots for a VM
     * 
     * Retrieve details about the missed snapshots for a virtual machine.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\MissedSnapshotsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\MissedSnapshotsResponse
     */
	public function missedSnapshots(
        \OpenAPI\OpenAPI\Models\Operations\MissedSnapshotsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\MissedSnapshotsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/vmware/vm/{id}/missed_snapshot', \OpenAPI\OpenAPI\Models\Operations\MissedSnapshotsRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\MissedSnapshotsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->missedSnapshotListResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\MissedSnapshotListResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get Live Mount information
     * 
     * Retrieve summary information about Live Mount activity.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\QueryMountV1Request $request
     * @return \OpenAPI\OpenAPI\Models\Operations\QueryMountV1Response
     */
	public function queryMountV1(
        \OpenAPI\OpenAPI\Models\Operations\QueryMountV1Request $request,
    ): \OpenAPI\OpenAPI\Models\Operations\QueryMountV1Response
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/vmware/vm/snapshot/mount');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\QueryMountV1Request::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\QueryMountV1Response();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->vmwareVmMountSummaryV1ListResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\VmwareVmMountSummaryV1ListResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get list of snapshots of VM
     * 
     * Retrieve summary information for the snapshots of a virtual machine.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\QuerySnapshotRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\QuerySnapshotResponse
     */
	public function querySnapshot(
        \OpenAPI\OpenAPI\Models\Operations\QuerySnapshotRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\QuerySnapshotResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/vmware/vm/{id}/snapshot', \OpenAPI\OpenAPI\Models\Operations\QuerySnapshotRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\QuerySnapshotResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->vmSnapshotSummaryListResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\VmSnapshotSummaryListResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get snapshot information for a list of virtual machines
     * 
     * Retrieve snapshot summaries for a list of virtual machines.
     * 
     * @param array<string> $request
     * @return \OpenAPI\OpenAPI\Models\Operations\QuerySnapshotsForVmsResponse
     */
	public function querySnapshotsForVms(
        array $request,
    ): \OpenAPI\OpenAPI\Models\Operations\QuerySnapshotsForVmsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/vmware/vm/snapshots');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\QuerySnapshotsForVmsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->batchVmSnapshotSummaries = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\BatchVmSnapshotSummaries', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get list of VMs
     * 
     * Get summary of all the VMs.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\QueryVmRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\QueryVmResponse
     */
	public function queryVm(
        \OpenAPI\OpenAPI\Models\Operations\QueryVmRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\QueryVmResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/vmware/vm');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\QueryVmRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\QueryVmResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->virtualMachineSummaryListResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\VirtualMachineSummaryListResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Relocate a virtual machine to another datastore
     * 
     * Run storage VMotion to relocate a specified Live Mount into another data store.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RelocateMountRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RelocateMountResponse
     */
	public function relocateMount(
        \OpenAPI\OpenAPI\Models\Operations\RelocateMountRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RelocateMountResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/vmware/vm/snapshot/mount/{id}/relocate', \OpenAPI\OpenAPI\Models\Operations\RelocateMountRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "relocateMountConfig", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RelocateMountResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 202) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->asyncRequestStatus = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AsyncRequestStatus', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Request a full snapshot for the next backup job of a VMware virtual machine
     * 
     * Request a full snapshot to be taken for the next backup job of a VMware virtual machine.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RequestVmForceFullSnapshotRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RequestVmForceFullSnapshotResponse
     */
	public function requestVmForceFullSnapshot(
        \OpenAPI\OpenAPI\Models\Operations\RequestVmForceFullSnapshotRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RequestVmForceFullSnapshotResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/vmware/vm/{id}/request/force_full_snapshot', \OpenAPI\OpenAPI\Models\Operations\RequestVmForceFullSnapshotRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "vmForceFullRequest", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RequestVmForceFullSnapshotResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->vmForceFullResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\VmForceFullResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Run guest OS script
     * 
     * Run the specified preBackup, postSnap, or postBackup script in the guest OS of a virtual machine. The script must exist and meet requirements.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RunGuestOsScriptRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RunGuestOsScriptResponse
     */
	public function runGuestOsScript(
        \OpenAPI\OpenAPI\Models\Operations\RunGuestOsScriptRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RunGuestOsScriptResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/vmware/vm/{id}/guest_script/run', \OpenAPI\OpenAPI\Models\Operations\RunGuestOsScriptRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "vmGuestScriptRunConfig", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RunGuestOsScriptResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
	
    /**
     * Search for a file from a VM
     * 
     * Search for a file in the snapshots of a a virtual machine. Specify the file by full path prefix or filename prefix.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\SearchVmRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\SearchVmResponse
     */
	public function searchVm(
        \OpenAPI\OpenAPI\Models\Operations\SearchVmRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\SearchVmResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/vmware/vm/{id}/search', \OpenAPI\OpenAPI\Models\Operations\SearchVmRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\SearchVmRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SearchVmResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->searchResponseListResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\SearchResponseListResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Power a Live Mount on and off
     * 
     * Power a specified Live Mount virtual machine on or off. Pass **_true_** to power the virtual machine on and pass **_false_** to power the virtual machine off.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateMountRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateMountResponse
     */
	public function updateMount(
        \OpenAPI\OpenAPI\Models\Operations\UpdateMountRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateMountResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/vmware/vm/snapshot/mount/{id}', \OpenAPI\OpenAPI\Models\Operations\UpdateMountRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "updateMountConfig", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateMountResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->vmwareVmMountDetailV1 = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\VmwareVmMountDetailV1', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update a specific Virtual Disk
     * 
     * Update a specific Virtual Disk.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateVirtualDiskRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateVirtualDiskResponse
     */
	public function updateVirtualDisk(
        \OpenAPI\OpenAPI\Models\Operations\UpdateVirtualDiskRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateVirtualDiskResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/vmware/vm/virtual_disk/{id}', \OpenAPI\OpenAPI\Models\Operations\UpdateVirtualDiskRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "virtualDiskUpdate", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateVirtualDiskResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->virtualDiskDetail = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\VirtualDiskDetail', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update VM
     * 
     * Update a virtual machine with specified properties. Use the guestCredential field to update the guest credential for a specified virtual machine.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateVmRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateVmResponse
     */
	public function updateVm(
        \OpenAPI\OpenAPI\Models\Operations\UpdateVmRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateVmResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/vmware/vm/{id}', \OpenAPI\OpenAPI\Models\Operations\UpdateVmRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "virtualMachineUpdateWithSecret", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateVmResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->virtualMachineDetail = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\VirtualMachineDetail', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Make this cluster the primary for agents on a set of VMs
     * 
     * Migrate the primary cluster with which the agent is able to communicate. For disaster recovery when migrating everything over from another cluster, the /host/make_primary endpoint can be used with the oldPrimaryClusterUuid parameter.
     * 
     * @param array<string> $request
     * @return \OpenAPI\OpenAPI\Models\Operations\VmMakePrimaryResponse
     */
	public function vmMakePrimary(
        array $request,
    ): \OpenAPI\OpenAPI\Models\Operations\VmMakePrimaryResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/vmware/vm/make_primary');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\VmMakePrimaryResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 202) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->asyncRequestStatus = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AsyncRequestStatus', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Register Rubrik Backup Service
     * 
     * Register the Rubrik Backup Service that is running on a specified host with the specified Rubrik cluster.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\VmRegisterAgentRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\VmRegisterAgentResponse
     */
	public function vmRegisterAgent(
        \OpenAPI\OpenAPI\Models\Operations\VmRegisterAgentRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\VmRegisterAgentResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/vmware/vm/{id}/register_agent', \OpenAPI\OpenAPI\Models\Operations\VmRegisterAgentRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\VmRegisterAgentResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
}