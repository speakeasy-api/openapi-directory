<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class Posts 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * Bookmark a post
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\BookmarkPostRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\BookmarkPostResponse
     */
	public function bookmarkPost(
        \OpenAPI\OpenAPI\Models\Operations\BookmarkPostRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\BookmarkPostResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/posts/{post_id}/bookmark', \OpenAPI\OpenAPI\Models\Operations\BookmarkPostRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\BookmarkPostResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404) {
        }

        return $response;
    }
	
    /**
     * Delete a post bookmark
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteBookmarkRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteBookmarkResponse
     */
	public function deleteBookmark(
        \OpenAPI\OpenAPI\Models\Operations\DeleteBookmarkRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteBookmarkResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/posts/{post_id}/bookmark', \OpenAPI\OpenAPI\Models\Operations\DeleteBookmarkRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteBookmarkResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 404) {
        }

        return $response;
    }
	
    /**
     * Delete a post
     * 
     * Users can delete posts they have made that have been satisfied or withdrawn or that have expired. Deleting posts isn't intended to be a normal part of the posting process since it makes reposting and viewing old posts harder.
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeletePostRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeletePostResponse
     */
	public function deletePost(
        \OpenAPI\OpenAPI\Models\Operations\DeletePostRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeletePostResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/posts/{post_id}', \OpenAPI\OpenAPI\Models\Operations\DeletePostRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeletePostResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404) {
        }

        return $response;
    }
	
    /**
     * List all posts
     * 
     * This endpoint provides an easy way to get a feed of all the publicly published posts on trash nothing. It provides access to all publicly published offer and wanted posts from the last 30 days. The posts are sorted by date (newest first). <br /><br /> There are fewer options for filtering, sorting and searching posts with this endpoint but there is no 1,000 post limit and posts that are crossposted to multiple groups are not merged together in the response.  In most cases, crossposted posts are easy to detect because they have the same user_id, title and content.
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetAllPostsRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetAllPostsSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetAllPostsResponse
     */
	public function getAllPosts(
        \OpenAPI\OpenAPI\Models\Operations\GetAllPostsRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetAllPostsSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetAllPostsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/posts/all');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetAllPostsRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetAllPostsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getAllPosts200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetAllPosts200ApplicationJSON', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400) {
        }

        return $response;
    }
	
    /**
     * List all post changes
     * 
     * This endpoint provides an easy way to get a feed of all the changes that have been made to publicly published posts on trash nothing.  Similar to the /posts/all endpoint, only data from the last 30 days is available and the changes are sorted by date (newest first).  Every change includes the date of the change, the post_id of the post that was changed and the type of change. <br /><br /> The different types of changes that are returned are listed below. <br /><br /> - deleted<br /> - undeleted<br /> - satisfied<br /> - promised<br /> - unpromised<br /> - withdrawn<br /> - edited<br /> <br /> For edited changes, clients can use the retrieve post API endpoint to get the edits that have been made to the post.
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetAllPostsChangesRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetAllPostsChangesSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetAllPostsChangesResponse
     */
	public function getAllPostsChanges(
        \OpenAPI\OpenAPI\Models\Operations\GetAllPostsChangesRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetAllPostsChangesSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetAllPostsChangesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/posts/all/changes');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetAllPostsChangesRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetAllPostsChangesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getAllPostsChanges200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetAllPostsChanges200ApplicationJSON', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400) {
        }

        return $response;
    }
	
    /**
     * Retrieve a post
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetPostRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetPostSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetPostResponse
     */
	public function getPost(
        \OpenAPI\OpenAPI\Models\Operations\GetPostRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetPostSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetPostResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/posts/{post_id}', \OpenAPI\OpenAPI\Models\Operations\GetPostRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetPostResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->post = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Post', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404) {
        }

        return $response;
    }
	
    /**
     * Retrieve post display data
     * 
     * Retrieve a post and other data related to the post that is useful for displaying the post such as data about the user who posted the post and the groups the post was posted on.
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetPostAndRelatedDataRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetPostAndRelatedDataSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetPostAndRelatedDataResponse
     */
	public function getPostAndRelatedData(
        \OpenAPI\OpenAPI\Models\Operations\GetPostAndRelatedDataRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetPostAndRelatedDataSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetPostAndRelatedDataResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/posts/{post_id}/display', \OpenAPI\OpenAPI\Models\Operations\GetPostAndRelatedDataRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetPostAndRelatedDataResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getPostAndRelatedData200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetPostAndRelatedData200ApplicationJSON', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404) {
        }

        return $response;
    }
	
    /**
     * List posts
     * 
     * NOTE: When paging through the posts returned by this endpoint, there will be at most 1,000 posts that can be returned (eg. 50 pages worth of posts with the default per_page value of 20).  In areas where there are more than 1,000 posts, clients can use more specific query parameters to adjust which posts are returned.
     * NOTE: Passing the latitude, longitude and radius parameters filters all posts by their location and so these parameters will temporarily override the current users' location preferences. When latitude, longitude and radius are not specified, public posts will be filtered by the current users' location preferences.
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetPostsRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetPostsSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetPostsResponse
     */
	public function getPosts(
        \OpenAPI\OpenAPI\Models\Operations\GetPostsRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetPostsSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetPostsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/posts');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetPostsRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetPostsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getPosts200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetPosts200ApplicationJSON', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400) {
        }

        return $response;
    }
	
    /**
     * Retrieve multiple posts
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetPostsByIdsRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetPostsByIdsSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetPostsByIdsResponse
     */
	public function getPostsByIds(
        \OpenAPI\OpenAPI\Models\Operations\GetPostsByIdsRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetPostsByIdsSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetPostsByIdsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/posts/multiple');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetPostsByIdsRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetPostsByIdsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getPostsByIds200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetPostsByIds200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Promise an offer post
     * 
     * Mark an offer by the current user as promised to someone. This helps people viewing the post know that the items being offered may soon be given away as long as the person who was promised the items picks them up.
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PromisePostRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PromisePostResponse
     */
	public function promisePost(
        \OpenAPI\OpenAPI\Models\Operations\PromisePostRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PromisePostResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/posts/{post_id}/promise', \OpenAPI\OpenAPI\Models\Operations\PromisePostRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PromisePostResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->post = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Post', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404) {
        }

        return $response;
    }
	
    /**
     * Reply to a post
     * 
     * Send a reply to a post from the current user to the post author.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ReplyToPostRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ReplyToPostResponse
     */
	public function replyToPost(
        \OpenAPI\OpenAPI\Models\Operations\ReplyToPostRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ReplyToPostResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/posts/{post_id}/reply', \OpenAPI\OpenAPI\Models\Operations\ReplyToPostRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "multipart");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ReplyToPostResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404) {
        }

        return $response;
    }
	
    /**
     * Report a post
     * 
     * Reports a post to be reviewed by the moderators.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ReportPostRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ReportPostResponse
     */
	public function reportPost(
        \OpenAPI\OpenAPI\Models\Operations\ReportPostRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ReportPostResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/posts/{post_id}/report', \OpenAPI\OpenAPI\Models\Operations\ReportPostRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "multipart");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ReportPostResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 404) {
        }

        return $response;
    }
	
    /**
     * Satisfy a post
     * 
     * Mark an offer or wanted post by the current user as satisfied (eg. an offer has been taken or a wanted has been received).
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\SatisfyPostRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\SatisfyPostResponse
     */
	public function satisfyPost(
        \OpenAPI\OpenAPI\Models\Operations\SatisfyPostRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\SatisfyPostResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/posts/{post_id}/satisfy', \OpenAPI\OpenAPI\Models\Operations\SatisfyPostRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SatisfyPostResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->post = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Post', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404) {
        }

        return $response;
    }
	
    /**
     * Search posts
     * 
     * Searching posts takes the same arguments as listing posts except for the addition of the search and sort_by parameters.
     * NOTE: When paging through the posts returned by this endpoint, there will be at most 1,000 posts that can be returned (eg. 50 pages worth of posts with the default per_page value of 20).  In areas where there are more than 1,000 posts, clients can use more specific query parameters to adjust which posts are returned.
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\SearchPostsRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\SearchPostsSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\SearchPostsResponse
     */
	public function searchPosts(
        \OpenAPI\OpenAPI\Models\Operations\SearchPostsRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\SearchPostsSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\SearchPostsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/posts/search');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\SearchPostsRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SearchPostsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->searchPosts200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\SearchPosts200ApplicationJSON', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400) {
        }

        return $response;
    }
	
    /**
     * Share a post
     * 
     * Forwards a copy of the post to the current user so that they can forward it to friends.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\SharePostRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\SharePostResponse
     */
	public function sharePost(
        \OpenAPI\OpenAPI\Models\Operations\SharePostRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\SharePostResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/posts/{post_id}/share', \OpenAPI\OpenAPI\Models\Operations\SharePostRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SharePostResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404) {
        }

        return $response;
    }
	
    /**
     * Submit a post
     * 
     * Submits a new post.
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\SubmitPostRequestBody $request
     * @return \OpenAPI\OpenAPI\Models\Operations\SubmitPostResponse
     */
	public function submitPost(
        \OpenAPI\OpenAPI\Models\Operations\SubmitPostRequestBody $request,
    ): \OpenAPI\OpenAPI\Models\Operations\SubmitPostResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/posts');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "multipart");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SubmitPostResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->submitPost200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\SubmitPost200ApplicationJSON', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400) {
        }

        return $response;
    }
	
    /**
     * Unpromise an offer post
     * 
     * Mark an offer by the current user as unpromised.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UnpromisePostRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UnpromisePostResponse
     */
	public function unpromisePost(
        \OpenAPI\OpenAPI\Models\Operations\UnpromisePostRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UnpromisePostResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/posts/{post_id}/unpromise', \OpenAPI\OpenAPI\Models\Operations\UnpromisePostRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UnpromisePostResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->post = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Post', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404) {
        }

        return $response;
    }
	
    /**
     * Update a post
     * 
     * Users can update posts to fix mistakes with their post, add photos, or add more details about the items. Updates should not be used to say that items in a post have been taken or received since the post satisfy endpoint is designed to do that.
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdatePostRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdatePostResponse
     */
	public function updatePost(
        \OpenAPI\OpenAPI\Models\Operations\UpdatePostRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdatePostResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/posts/{post_id}', \OpenAPI\OpenAPI\Models\Operations\UpdatePostRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "multipart");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdatePostResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->updatePost200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\UpdatePost200ApplicationJSON', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404) {
        }

        return $response;
    }
	
    /**
     * Withdraw a post
     * 
     * Mark an offer or wanted post by the current user as withdrawn.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\WithdrawPostRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\WithdrawPostResponse
     */
	public function withdrawPost(
        \OpenAPI\OpenAPI\Models\Operations\WithdrawPostRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\WithdrawPostResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/posts/{post_id}/withdraw', \OpenAPI\OpenAPI\Models\Operations\WithdrawPostRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\WithdrawPostResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->post = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Post', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404) {
        }

        return $response;
    }
}