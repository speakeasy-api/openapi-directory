// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package operations

import (
	"bytes"
	"encoding/json"
	"errors"
	"net/http"
	"openapi/pkg/models/shared"
)

type GetUsersUserIDPlaylistsSecurity struct {
	AuthHeader string `security:"scheme,type=apiKey,subtype=header,name=Authorization"`
	ClientID   string `security:"scheme,type=apiKey,subtype=query,name=client_id"`
}

type GetUsersUserIDPlaylistsRequest struct {
	// Filters content by level of access the user (logged in or anonymous) has to the track. The result list will include only tracks with the specified access. Include all options if you'd like to see all possible tracks. See `Track#access` schema for more details.
	//
	Access []shared.AccessEnum `queryParam:"style=form,explode=false,name=access"`
	// Number of results to return in the collection.
	Limit *int64 `queryParam:"style=form,explode=true,name=limit"`
	// Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)
	LinkedPartitioning *bool `queryParam:"style=form,explode=true,name=linked_partitioning"`
	// SoundCloud User id
	UserID int64 `pathParam:"style=simple,explode=false,name=user_id"`
}

type GetUsersUserIDPlaylists200ApplicationJSONType string

const (
	GetUsersUserIDPlaylists200ApplicationJSONTypePlaylists       GetUsersUserIDPlaylists200ApplicationJSONType = "Playlists"
	GetUsersUserIDPlaylists200ApplicationJSONTypeArrayOfPlaylist GetUsersUserIDPlaylists200ApplicationJSONType = "arrayOfPlaylist"
)

type GetUsersUserIDPlaylists200ApplicationJSON struct {
	Playlists       *shared.Playlists
	ArrayOfPlaylist []shared.Playlist

	Type GetUsersUserIDPlaylists200ApplicationJSONType
}

func CreateGetUsersUserIDPlaylists200ApplicationJSONPlaylists(playlists shared.Playlists) GetUsersUserIDPlaylists200ApplicationJSON {
	typ := GetUsersUserIDPlaylists200ApplicationJSONTypePlaylists

	return GetUsersUserIDPlaylists200ApplicationJSON{
		Playlists: &playlists,
		Type:      typ,
	}
}

func CreateGetUsersUserIDPlaylists200ApplicationJSONArrayOfPlaylist(arrayOfPlaylist []shared.Playlist) GetUsersUserIDPlaylists200ApplicationJSON {
	typ := GetUsersUserIDPlaylists200ApplicationJSONTypeArrayOfPlaylist

	return GetUsersUserIDPlaylists200ApplicationJSON{
		ArrayOfPlaylist: arrayOfPlaylist,
		Type:            typ,
	}
}

func (u *GetUsersUserIDPlaylists200ApplicationJSON) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	playlists := new(shared.Playlists)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&playlists); err == nil {
		u.Playlists = playlists
		u.Type = GetUsersUserIDPlaylists200ApplicationJSONTypePlaylists
		return nil
	}

	arrayOfPlaylist := []shared.Playlist{}
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&arrayOfPlaylist); err == nil {
		u.ArrayOfPlaylist = arrayOfPlaylist
		u.Type = GetUsersUserIDPlaylists200ApplicationJSONTypeArrayOfPlaylist
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u GetUsersUserIDPlaylists200ApplicationJSON) MarshalJSON() ([]byte, error) {
	if u.Playlists != nil {
		return json.Marshal(u.Playlists)
	}

	if u.ArrayOfPlaylist != nil {
		return json.Marshal(u.ArrayOfPlaylist)
	}

	return nil, nil
}

type GetUsersUserIDPlaylistsResponse struct {
	ContentType string
	// Unauthorized
	Error       *shared.Error
	StatusCode  int
	RawResponse *http.Response
	// Success
	GetUsersUserIDPlaylists200ApplicationJSONOneOf *GetUsersUserIDPlaylists200ApplicationJSON
}
