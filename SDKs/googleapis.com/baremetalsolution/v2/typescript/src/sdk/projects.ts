/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Projects {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Get instance provisioning settings for a given project. This is hidden method used by UI only.
   */
  baremetalsolutionProjectsLocationsInstanceProvisioningSettingsFetch(
    req: operations.BaremetalsolutionProjectsLocationsInstanceProvisioningSettingsFetchRequest,
    security: operations.BaremetalsolutionProjectsLocationsInstanceProvisioningSettingsFetchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.BaremetalsolutionProjectsLocationsInstanceProvisioningSettingsFetchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.BaremetalsolutionProjectsLocationsInstanceProvisioningSettingsFetchRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/{location}/instanceProvisioningSettings:fetch",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.BaremetalsolutionProjectsLocationsInstanceProvisioningSettingsFetchSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BaremetalsolutionProjectsLocationsInstanceProvisioningSettingsFetchResponse =
        new operations.BaremetalsolutionProjectsLocationsInstanceProvisioningSettingsFetchResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.fetchInstanceProvisioningSettingsResponse = utils.objectToClass(
              httpRes?.data,
              shared.FetchInstanceProvisioningSettingsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create an Instance.
   */
  baremetalsolutionProjectsLocationsInstancesCreate(
    req: operations.BaremetalsolutionProjectsLocationsInstancesCreateRequest,
    security: operations.BaremetalsolutionProjectsLocationsInstancesCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.BaremetalsolutionProjectsLocationsInstancesCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.BaremetalsolutionProjectsLocationsInstancesCreateRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/{parent}/instances",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "instanceInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.BaremetalsolutionProjectsLocationsInstancesCreateSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BaremetalsolutionProjectsLocationsInstancesCreateResponse =
        new operations.BaremetalsolutionProjectsLocationsInstancesCreateResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Detach LUN from Instance.
   */
  baremetalsolutionProjectsLocationsInstancesDetachLun(
    req: operations.BaremetalsolutionProjectsLocationsInstancesDetachLunRequest,
    security: operations.BaremetalsolutionProjectsLocationsInstancesDetachLunSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.BaremetalsolutionProjectsLocationsInstancesDetachLunResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.BaremetalsolutionProjectsLocationsInstancesDetachLunRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/{instance}:detachLun",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "detachLunRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.BaremetalsolutionProjectsLocationsInstancesDetachLunSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BaremetalsolutionProjectsLocationsInstancesDetachLunResponse =
        new operations.BaremetalsolutionProjectsLocationsInstancesDetachLunResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Disable the interactive serial console feature on an instance.
   */
  baremetalsolutionProjectsLocationsInstancesDisableInteractiveSerialConsole(
    req: operations.BaremetalsolutionProjectsLocationsInstancesDisableInteractiveSerialConsoleRequest,
    security: operations.BaremetalsolutionProjectsLocationsInstancesDisableInteractiveSerialConsoleSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.BaremetalsolutionProjectsLocationsInstancesDisableInteractiveSerialConsoleResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.BaremetalsolutionProjectsLocationsInstancesDisableInteractiveSerialConsoleRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/{name}:disableInteractiveSerialConsole",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.BaremetalsolutionProjectsLocationsInstancesDisableInteractiveSerialConsoleSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BaremetalsolutionProjectsLocationsInstancesDisableInteractiveSerialConsoleResponse =
        new operations.BaremetalsolutionProjectsLocationsInstancesDisableInteractiveSerialConsoleResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Enable the interactive serial console feature on an instance.
   */
  baremetalsolutionProjectsLocationsInstancesEnableInteractiveSerialConsole(
    req: operations.BaremetalsolutionProjectsLocationsInstancesEnableInteractiveSerialConsoleRequest,
    security: operations.BaremetalsolutionProjectsLocationsInstancesEnableInteractiveSerialConsoleSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.BaremetalsolutionProjectsLocationsInstancesEnableInteractiveSerialConsoleResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.BaremetalsolutionProjectsLocationsInstancesEnableInteractiveSerialConsoleRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/{name}:enableInteractiveSerialConsole",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.BaremetalsolutionProjectsLocationsInstancesEnableInteractiveSerialConsoleSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BaremetalsolutionProjectsLocationsInstancesEnableInteractiveSerialConsoleResponse =
        new operations.BaremetalsolutionProjectsLocationsInstancesEnableInteractiveSerialConsoleResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List servers in a given project and location.
   */
  baremetalsolutionProjectsLocationsInstancesList(
    req: operations.BaremetalsolutionProjectsLocationsInstancesListRequest,
    security: operations.BaremetalsolutionProjectsLocationsInstancesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.BaremetalsolutionProjectsLocationsInstancesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.BaremetalsolutionProjectsLocationsInstancesListRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/{parent}/instances",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.BaremetalsolutionProjectsLocationsInstancesListSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BaremetalsolutionProjectsLocationsInstancesListResponse =
        new operations.BaremetalsolutionProjectsLocationsInstancesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listInstancesResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListInstancesResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Perform an ungraceful, hard reset on a server. Equivalent to shutting the power off and then turning it back on.
   */
  baremetalsolutionProjectsLocationsInstancesReset(
    req: operations.BaremetalsolutionProjectsLocationsInstancesResetRequest,
    security: operations.BaremetalsolutionProjectsLocationsInstancesResetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.BaremetalsolutionProjectsLocationsInstancesResetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.BaremetalsolutionProjectsLocationsInstancesResetRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v2/{name}:reset", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.BaremetalsolutionProjectsLocationsInstancesResetSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BaremetalsolutionProjectsLocationsInstancesResetResponse =
        new operations.BaremetalsolutionProjectsLocationsInstancesResetResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Starts a server that was shutdown.
   */
  baremetalsolutionProjectsLocationsInstancesStart(
    req: operations.BaremetalsolutionProjectsLocationsInstancesStartRequest,
    security: operations.BaremetalsolutionProjectsLocationsInstancesStartSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.BaremetalsolutionProjectsLocationsInstancesStartResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.BaremetalsolutionProjectsLocationsInstancesStartRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v2/{name}:start", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.BaremetalsolutionProjectsLocationsInstancesStartSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BaremetalsolutionProjectsLocationsInstancesStartResponse =
        new operations.BaremetalsolutionProjectsLocationsInstancesStartResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Stop a running server.
   */
  baremetalsolutionProjectsLocationsInstancesStop(
    req: operations.BaremetalsolutionProjectsLocationsInstancesStopRequest,
    security: operations.BaremetalsolutionProjectsLocationsInstancesStopSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.BaremetalsolutionProjectsLocationsInstancesStopResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.BaremetalsolutionProjectsLocationsInstancesStopRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v2/{name}:stop", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.BaremetalsolutionProjectsLocationsInstancesStopSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BaremetalsolutionProjectsLocationsInstancesStopResponse =
        new operations.BaremetalsolutionProjectsLocationsInstancesStopResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists information about the supported locations for this service.
   */
  baremetalsolutionProjectsLocationsList(
    req: operations.BaremetalsolutionProjectsLocationsListRequest,
    security: operations.BaremetalsolutionProjectsLocationsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.BaremetalsolutionProjectsLocationsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.BaremetalsolutionProjectsLocationsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v2/{name}/locations", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.BaremetalsolutionProjectsLocationsListSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BaremetalsolutionProjectsLocationsListResponse =
        new operations.BaremetalsolutionProjectsLocationsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listLocationsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListLocationsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List network in a given project and location.
   */
  baremetalsolutionProjectsLocationsNetworksList(
    req: operations.BaremetalsolutionProjectsLocationsNetworksListRequest,
    security: operations.BaremetalsolutionProjectsLocationsNetworksListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.BaremetalsolutionProjectsLocationsNetworksListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.BaremetalsolutionProjectsLocationsNetworksListRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/{parent}/networks",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.BaremetalsolutionProjectsLocationsNetworksListSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BaremetalsolutionProjectsLocationsNetworksListResponse =
        new operations.BaremetalsolutionProjectsLocationsNetworksListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listNetworksResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListNetworksResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List all Networks (and used IPs for each Network) in the vendor account associated with the specified project.
   */
  baremetalsolutionProjectsLocationsNetworksListNetworkUsage(
    req: operations.BaremetalsolutionProjectsLocationsNetworksListNetworkUsageRequest,
    security: operations.BaremetalsolutionProjectsLocationsNetworksListNetworkUsageSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.BaremetalsolutionProjectsLocationsNetworksListNetworkUsageResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.BaremetalsolutionProjectsLocationsNetworksListNetworkUsageRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/{location}/networks:listNetworkUsage",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.BaremetalsolutionProjectsLocationsNetworksListNetworkUsageSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BaremetalsolutionProjectsLocationsNetworksListNetworkUsageResponse =
        new operations.BaremetalsolutionProjectsLocationsNetworksListNetworkUsageResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listNetworkUsageResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListNetworkUsageResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create an NFS share.
   */
  baremetalsolutionProjectsLocationsNfsSharesCreate(
    req: operations.BaremetalsolutionProjectsLocationsNfsSharesCreateRequest,
    security: operations.BaremetalsolutionProjectsLocationsNfsSharesCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.BaremetalsolutionProjectsLocationsNfsSharesCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.BaremetalsolutionProjectsLocationsNfsSharesCreateRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/{parent}/nfsShares",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "nfsShareInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.BaremetalsolutionProjectsLocationsNfsSharesCreateSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BaremetalsolutionProjectsLocationsNfsSharesCreateResponse =
        new operations.BaremetalsolutionProjectsLocationsNfsSharesCreateResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List NFS shares.
   */
  baremetalsolutionProjectsLocationsNfsSharesList(
    req: operations.BaremetalsolutionProjectsLocationsNfsSharesListRequest,
    security: operations.BaremetalsolutionProjectsLocationsNfsSharesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.BaremetalsolutionProjectsLocationsNfsSharesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.BaremetalsolutionProjectsLocationsNfsSharesListRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/{parent}/nfsShares",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.BaremetalsolutionProjectsLocationsNfsSharesListSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BaremetalsolutionProjectsLocationsNfsSharesListResponse =
        new operations.BaremetalsolutionProjectsLocationsNfsSharesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listNfsSharesResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListNfsSharesResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create new ProvisioningConfig.
   */
  baremetalsolutionProjectsLocationsProvisioningConfigsCreate(
    req: operations.BaremetalsolutionProjectsLocationsProvisioningConfigsCreateRequest,
    security: operations.BaremetalsolutionProjectsLocationsProvisioningConfigsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.BaremetalsolutionProjectsLocationsProvisioningConfigsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.BaremetalsolutionProjectsLocationsProvisioningConfigsCreateRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/{parent}/provisioningConfigs",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "provisioningConfigInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.BaremetalsolutionProjectsLocationsProvisioningConfigsCreateSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BaremetalsolutionProjectsLocationsProvisioningConfigsCreateResponse =
        new operations.BaremetalsolutionProjectsLocationsProvisioningConfigsCreateResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.provisioningConfig = utils.objectToClass(
              httpRes?.data,
              shared.ProvisioningConfig
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Submit a provisiong configuration for a given project.
   */
  baremetalsolutionProjectsLocationsProvisioningConfigsSubmit(
    req: operations.BaremetalsolutionProjectsLocationsProvisioningConfigsSubmitRequest,
    security: operations.BaremetalsolutionProjectsLocationsProvisioningConfigsSubmitSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.BaremetalsolutionProjectsLocationsProvisioningConfigsSubmitResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.BaremetalsolutionProjectsLocationsProvisioningConfigsSubmitRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/{parent}/provisioningConfigs:submit",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "submitProvisioningConfigRequestInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.BaremetalsolutionProjectsLocationsProvisioningConfigsSubmitSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BaremetalsolutionProjectsLocationsProvisioningConfigsSubmitResponse =
        new operations.BaremetalsolutionProjectsLocationsProvisioningConfigsSubmitResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.submitProvisioningConfigResponse = utils.objectToClass(
              httpRes?.data,
              shared.SubmitProvisioningConfigResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List the budget details to provision resources on a given project.
   */
  baremetalsolutionProjectsLocationsProvisioningQuotasList(
    req: operations.BaremetalsolutionProjectsLocationsProvisioningQuotasListRequest,
    security: operations.BaremetalsolutionProjectsLocationsProvisioningQuotasListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.BaremetalsolutionProjectsLocationsProvisioningQuotasListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.BaremetalsolutionProjectsLocationsProvisioningQuotasListRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/{parent}/provisioningQuotas",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.BaremetalsolutionProjectsLocationsProvisioningQuotasListSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BaremetalsolutionProjectsLocationsProvisioningQuotasListResponse =
        new operations.BaremetalsolutionProjectsLocationsProvisioningQuotasListResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listProvisioningQuotasResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListProvisioningQuotasResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Register a public SSH key in the specified project for use with the interactive serial console feature.
   */
  baremetalsolutionProjectsLocationsSshKeysCreate(
    req: operations.BaremetalsolutionProjectsLocationsSshKeysCreateRequest,
    security: operations.BaremetalsolutionProjectsLocationsSshKeysCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.BaremetalsolutionProjectsLocationsSshKeysCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.BaremetalsolutionProjectsLocationsSshKeysCreateRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v2/{parent}/sshKeys", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "sshKeyInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.BaremetalsolutionProjectsLocationsSshKeysCreateSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BaremetalsolutionProjectsLocationsSshKeysCreateResponse =
        new operations.BaremetalsolutionProjectsLocationsSshKeysCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.sshKey = utils.objectToClass(httpRes?.data, shared.SSHKey);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists the public SSH keys registered for the specified project. These SSH keys are used only for the interactive serial console feature.
   */
  baremetalsolutionProjectsLocationsSshKeysList(
    req: operations.BaremetalsolutionProjectsLocationsSshKeysListRequest,
    security: operations.BaremetalsolutionProjectsLocationsSshKeysListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.BaremetalsolutionProjectsLocationsSshKeysListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.BaremetalsolutionProjectsLocationsSshKeysListRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v2/{parent}/sshKeys", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.BaremetalsolutionProjectsLocationsSshKeysListSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BaremetalsolutionProjectsLocationsSshKeysListResponse =
        new operations.BaremetalsolutionProjectsLocationsSshKeysListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listSSHKeysResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListSSHKeysResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List storage volumes in a given project and location.
   */
  baremetalsolutionProjectsLocationsVolumesList(
    req: operations.BaremetalsolutionProjectsLocationsVolumesListRequest,
    security: operations.BaremetalsolutionProjectsLocationsVolumesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.BaremetalsolutionProjectsLocationsVolumesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.BaremetalsolutionProjectsLocationsVolumesListRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v2/{parent}/volumes", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.BaremetalsolutionProjectsLocationsVolumesListSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BaremetalsolutionProjectsLocationsVolumesListResponse =
        new operations.BaremetalsolutionProjectsLocationsVolumesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listVolumesResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListVolumesResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Skips lun's cooloff and deletes it now. Lun must be in cooloff state.
   */
  baremetalsolutionProjectsLocationsVolumesLunsEvict(
    req: operations.BaremetalsolutionProjectsLocationsVolumesLunsEvictRequest,
    security: operations.BaremetalsolutionProjectsLocationsVolumesLunsEvictSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.BaremetalsolutionProjectsLocationsVolumesLunsEvictResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.BaremetalsolutionProjectsLocationsVolumesLunsEvictRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v2/{name}:evict", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.BaremetalsolutionProjectsLocationsVolumesLunsEvictSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BaremetalsolutionProjectsLocationsVolumesLunsEvictResponse =
        new operations.BaremetalsolutionProjectsLocationsVolumesLunsEvictResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List storage volume luns for given storage volume.
   */
  baremetalsolutionProjectsLocationsVolumesLunsList(
    req: operations.BaremetalsolutionProjectsLocationsVolumesLunsListRequest,
    security: operations.BaremetalsolutionProjectsLocationsVolumesLunsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.BaremetalsolutionProjectsLocationsVolumesLunsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.BaremetalsolutionProjectsLocationsVolumesLunsListRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v2/{parent}/luns", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.BaremetalsolutionProjectsLocationsVolumesLunsListSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BaremetalsolutionProjectsLocationsVolumesLunsListResponse =
        new operations.BaremetalsolutionProjectsLocationsVolumesLunsListResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listLunsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListLunsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update details of a single storage volume.
   */
  baremetalsolutionProjectsLocationsVolumesPatch(
    req: operations.BaremetalsolutionProjectsLocationsVolumesPatchRequest,
    security: operations.BaremetalsolutionProjectsLocationsVolumesPatchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.BaremetalsolutionProjectsLocationsVolumesPatchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.BaremetalsolutionProjectsLocationsVolumesPatchRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v2/{name}", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "volumeInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.BaremetalsolutionProjectsLocationsVolumesPatchSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BaremetalsolutionProjectsLocationsVolumesPatchResponse =
        new operations.BaremetalsolutionProjectsLocationsVolumesPatchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * RenameVolume sets a new name for a volume. Use with caution, previous names become immediately invalidated.
   */
  baremetalsolutionProjectsLocationsVolumesRename(
    req: operations.BaremetalsolutionProjectsLocationsVolumesRenameRequest,
    security: operations.BaremetalsolutionProjectsLocationsVolumesRenameSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.BaremetalsolutionProjectsLocationsVolumesRenameResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.BaremetalsolutionProjectsLocationsVolumesRenameRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v2/{name}:rename", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "renameVolumeRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.BaremetalsolutionProjectsLocationsVolumesRenameSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BaremetalsolutionProjectsLocationsVolumesRenameResponse =
        new operations.BaremetalsolutionProjectsLocationsVolumesRenameResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.volume = utils.objectToClass(httpRes?.data, shared.Volume);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Emergency Volume resize.
   */
  baremetalsolutionProjectsLocationsVolumesResize(
    req: operations.BaremetalsolutionProjectsLocationsVolumesResizeRequest,
    security: operations.BaremetalsolutionProjectsLocationsVolumesResizeSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.BaremetalsolutionProjectsLocationsVolumesResizeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.BaremetalsolutionProjectsLocationsVolumesResizeRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v2/{volume}:resize", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "resizeVolumeRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.BaremetalsolutionProjectsLocationsVolumesResizeSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BaremetalsolutionProjectsLocationsVolumesResizeResponse =
        new operations.BaremetalsolutionProjectsLocationsVolumesResizeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Takes a snapshot of a boot volume. Returns INVALID_ARGUMENT if called for a non-boot volume.
   */
  baremetalsolutionProjectsLocationsVolumesSnapshotsCreate(
    req: operations.BaremetalsolutionProjectsLocationsVolumesSnapshotsCreateRequest,
    security: operations.BaremetalsolutionProjectsLocationsVolumesSnapshotsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.BaremetalsolutionProjectsLocationsVolumesSnapshotsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.BaremetalsolutionProjectsLocationsVolumesSnapshotsCreateRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/{parent}/snapshots",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "volumeSnapshotInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.BaremetalsolutionProjectsLocationsVolumesSnapshotsCreateSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BaremetalsolutionProjectsLocationsVolumesSnapshotsCreateResponse =
        new operations.BaremetalsolutionProjectsLocationsVolumesSnapshotsCreateResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.volumeSnapshot = utils.objectToClass(
              httpRes?.data,
              shared.VolumeSnapshot
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes a volume snapshot. Returns INVALID_ARGUMENT if called for a non-boot volume.
   */
  baremetalsolutionProjectsLocationsVolumesSnapshotsDelete(
    req: operations.BaremetalsolutionProjectsLocationsVolumesSnapshotsDeleteRequest,
    security: operations.BaremetalsolutionProjectsLocationsVolumesSnapshotsDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.BaremetalsolutionProjectsLocationsVolumesSnapshotsDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.BaremetalsolutionProjectsLocationsVolumesSnapshotsDeleteRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v2/{name}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.BaremetalsolutionProjectsLocationsVolumesSnapshotsDeleteSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BaremetalsolutionProjectsLocationsVolumesSnapshotsDeleteResponse =
        new operations.BaremetalsolutionProjectsLocationsVolumesSnapshotsDeleteResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.empty = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns the specified snapshot resource. Returns INVALID_ARGUMENT if called for a non-boot volume.
   */
  baremetalsolutionProjectsLocationsVolumesSnapshotsGet(
    req: operations.BaremetalsolutionProjectsLocationsVolumesSnapshotsGetRequest,
    security: operations.BaremetalsolutionProjectsLocationsVolumesSnapshotsGetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.BaremetalsolutionProjectsLocationsVolumesSnapshotsGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.BaremetalsolutionProjectsLocationsVolumesSnapshotsGetRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v2/{name}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.BaremetalsolutionProjectsLocationsVolumesSnapshotsGetSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BaremetalsolutionProjectsLocationsVolumesSnapshotsGetResponse =
        new operations.BaremetalsolutionProjectsLocationsVolumesSnapshotsGetResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.volumeSnapshot = utils.objectToClass(
              httpRes?.data,
              shared.VolumeSnapshot
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves the list of snapshots for the specified volume. Returns a response with an empty list of snapshots if called for a non-boot volume.
   */
  baremetalsolutionProjectsLocationsVolumesSnapshotsList(
    req: operations.BaremetalsolutionProjectsLocationsVolumesSnapshotsListRequest,
    security: operations.BaremetalsolutionProjectsLocationsVolumesSnapshotsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.BaremetalsolutionProjectsLocationsVolumesSnapshotsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.BaremetalsolutionProjectsLocationsVolumesSnapshotsListRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/{parent}/snapshots",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.BaremetalsolutionProjectsLocationsVolumesSnapshotsListSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BaremetalsolutionProjectsLocationsVolumesSnapshotsListResponse =
        new operations.BaremetalsolutionProjectsLocationsVolumesSnapshotsListResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listVolumeSnapshotsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListVolumeSnapshotsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Uses the specified snapshot to restore its parent volume. Returns INVALID_ARGUMENT if called for a non-boot volume.
   */
  baremetalsolutionProjectsLocationsVolumesSnapshotsRestoreVolumeSnapshot(
    req: operations.BaremetalsolutionProjectsLocationsVolumesSnapshotsRestoreVolumeSnapshotRequest,
    security: operations.BaremetalsolutionProjectsLocationsVolumesSnapshotsRestoreVolumeSnapshotSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.BaremetalsolutionProjectsLocationsVolumesSnapshotsRestoreVolumeSnapshotResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.BaremetalsolutionProjectsLocationsVolumesSnapshotsRestoreVolumeSnapshotRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/{volumeSnapshot}:restoreVolumeSnapshot",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.BaremetalsolutionProjectsLocationsVolumesSnapshotsRestoreVolumeSnapshotSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BaremetalsolutionProjectsLocationsVolumesSnapshotsRestoreVolumeSnapshotResponse =
        new operations.BaremetalsolutionProjectsLocationsVolumesSnapshotsRestoreVolumeSnapshotResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }
}
