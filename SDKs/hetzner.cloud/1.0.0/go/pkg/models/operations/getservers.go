// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"fmt"
	"net/http"
)

// GetServersSortEnum - Can be used multiple times.
type GetServersSortEnum string

const (
	GetServersSortEnumID          GetServersSortEnum = "id"
	GetServersSortEnumIDAsc       GetServersSortEnum = "id:asc"
	GetServersSortEnumIDDesc      GetServersSortEnum = "id:desc"
	GetServersSortEnumName        GetServersSortEnum = "name"
	GetServersSortEnumNameAsc     GetServersSortEnum = "name:asc"
	GetServersSortEnumNameDesc    GetServersSortEnum = "name:desc"
	GetServersSortEnumCreated     GetServersSortEnum = "created"
	GetServersSortEnumCreatedAsc  GetServersSortEnum = "created:asc"
	GetServersSortEnumCreatedDesc GetServersSortEnum = "created:desc"
)

func (e *GetServersSortEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "id":
		fallthrough
	case "id:asc":
		fallthrough
	case "id:desc":
		fallthrough
	case "name":
		fallthrough
	case "name:asc":
		fallthrough
	case "name:desc":
		fallthrough
	case "created":
		fallthrough
	case "created:asc":
		fallthrough
	case "created:desc":
		*e = GetServersSortEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for GetServersSortEnum: %s", s)
	}
}

// GetServersStatusEnum - Can be used multiple times. The response will only contain Server matching the status
type GetServersStatusEnum string

const (
	GetServersStatusEnumInitializing GetServersStatusEnum = "initializing"
	GetServersStatusEnumStarting     GetServersStatusEnum = "starting"
	GetServersStatusEnumRunning      GetServersStatusEnum = "running"
	GetServersStatusEnumStopping     GetServersStatusEnum = "stopping"
	GetServersStatusEnumOff          GetServersStatusEnum = "off"
	GetServersStatusEnumDeleting     GetServersStatusEnum = "deleting"
	GetServersStatusEnumRebuilding   GetServersStatusEnum = "rebuilding"
	GetServersStatusEnumMigrating    GetServersStatusEnum = "migrating"
	GetServersStatusEnumUnknown      GetServersStatusEnum = "unknown"
)

func (e *GetServersStatusEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "initializing":
		fallthrough
	case "starting":
		fallthrough
	case "running":
		fallthrough
	case "stopping":
		fallthrough
	case "off":
		fallthrough
	case "deleting":
		fallthrough
	case "rebuilding":
		fallthrough
	case "migrating":
		fallthrough
	case "unknown":
		*e = GetServersStatusEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for GetServersStatusEnum: %s", s)
	}
}

type GetServersQueryParams struct {
	// Can be used to filter resources by labels. The response will only contain resources matching the label selector.
	LabelSelector *string `queryParam:"style=form,explode=true,name=label_selector"`
	// Can be used to filter resources by their name. The response will only contain the resources matching the specified name
	Name *string `queryParam:"style=form,explode=true,name=name"`
	// Can be used multiple times.
	Sort *GetServersSortEnum `queryParam:"style=form,explode=true,name=sort"`
	// Can be used multiple times. The response will only contain Server matching the status
	Status *GetServersStatusEnum `queryParam:"style=form,explode=true,name=status"`
}

type GetServersRequest struct {
	QueryParams GetServersQueryParams
}

type GetServers200ApplicationJSONMetaPagination struct {
	// ID of the last page available. Can be null if the current page is the last one.
	LastPage float64 `json:"last_page"`
	// ID of the next page. Can be null if the current page is the last one.
	NextPage float64 `json:"next_page"`
	// Current page number
	Page float64 `json:"page"`
	// Maximum number of items shown per page in the response
	PerPage float64 `json:"per_page"`
	// ID of the previous page. Can be null if the current page is the first one.
	PreviousPage float64 `json:"previous_page"`
	// The total number of entries that exist in the database for this query. Nullable if unknown.
	TotalEntries float64 `json:"total_entries"`
}

type GetServers200ApplicationJSONMeta struct {
	Pagination GetServers200ApplicationJSONMetaPagination `json:"pagination"`
}

type GetServers200ApplicationJSONServersDatacenterLocation struct {
	// City the Location is closest to
	City string `json:"city"`
	// ISO 3166-1 alpha-2 code of the country the Location resides in
	Country string `json:"country"`
	// Description of the Location
	Description string `json:"description"`
	// ID of the Location
	ID float64 `json:"id"`
	// Latitude of the city closest to the Location
	Latitude float64 `json:"latitude"`
	// Longitude of the city closest to the Location
	Longitude float64 `json:"longitude"`
	// Unique identifier of the Location
	Name string `json:"name"`
	// Name of network zone this Location resides in
	NetworkZone string `json:"network_zone"`
}

// GetServers200ApplicationJSONServersDatacenterServerTypes - The Server types the Datacenter can handle
type GetServers200ApplicationJSONServersDatacenterServerTypes struct {
	// IDs of Server types that are supported and for which the Datacenter has enough resources left
	Available []float64 `json:"available"`
	// IDs of Server types that are supported and for which the Datacenter has enough resources left
	AvailableForMigration []float64 `json:"available_for_migration"`
	// IDs of Server types that are supported in the Datacenter
	Supported []float64 `json:"supported"`
}

// GetServers200ApplicationJSONServersDatacenter - Datacenter this Resource is located at
type GetServers200ApplicationJSONServersDatacenter struct {
	// Description of the Datacenter
	Description string `json:"description"`
	// ID of the Resource
	ID       int64                                                 `json:"id"`
	Location GetServers200ApplicationJSONServersDatacenterLocation `json:"location"`
	// Unique identifier of the Datacenter
	Name string `json:"name"`
	// The Server types the Datacenter can handle
	ServerTypes GetServers200ApplicationJSONServersDatacenterServerTypes `json:"server_types"`
}

// GetServers200ApplicationJSONServersImageCreatedFrom - Information about the Server the Image was created from
type GetServers200ApplicationJSONServersImageCreatedFrom struct {
	// ID of the Server the Image was created from
	ID int64 `json:"id"`
	// Server name at the time the Image was created
	Name string `json:"name"`
}

// GetServers200ApplicationJSONServersImageOsFlavorEnum - Flavor of operating system contained in the Image
type GetServers200ApplicationJSONServersImageOsFlavorEnum string

const (
	GetServers200ApplicationJSONServersImageOsFlavorEnumUbuntu  GetServers200ApplicationJSONServersImageOsFlavorEnum = "ubuntu"
	GetServers200ApplicationJSONServersImageOsFlavorEnumCentos  GetServers200ApplicationJSONServersImageOsFlavorEnum = "centos"
	GetServers200ApplicationJSONServersImageOsFlavorEnumDebian  GetServers200ApplicationJSONServersImageOsFlavorEnum = "debian"
	GetServers200ApplicationJSONServersImageOsFlavorEnumFedora  GetServers200ApplicationJSONServersImageOsFlavorEnum = "fedora"
	GetServers200ApplicationJSONServersImageOsFlavorEnumUnknown GetServers200ApplicationJSONServersImageOsFlavorEnum = "unknown"
)

func (e *GetServers200ApplicationJSONServersImageOsFlavorEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "ubuntu":
		fallthrough
	case "centos":
		fallthrough
	case "debian":
		fallthrough
	case "fedora":
		fallthrough
	case "unknown":
		*e = GetServers200ApplicationJSONServersImageOsFlavorEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for GetServers200ApplicationJSONServersImageOsFlavorEnum: %s", s)
	}
}

// GetServers200ApplicationJSONServersImageProtection - Protection configuration for the Resource
type GetServers200ApplicationJSONServersImageProtection struct {
	// If true, prevents the Resource from being deleted
	Delete bool `json:"delete"`
}

// GetServers200ApplicationJSONServersImageStatusEnum - Whether the Image can be used or if it's still being created or unavailable
type GetServers200ApplicationJSONServersImageStatusEnum string

const (
	GetServers200ApplicationJSONServersImageStatusEnumAvailable   GetServers200ApplicationJSONServersImageStatusEnum = "available"
	GetServers200ApplicationJSONServersImageStatusEnumCreating    GetServers200ApplicationJSONServersImageStatusEnum = "creating"
	GetServers200ApplicationJSONServersImageStatusEnumUnavailable GetServers200ApplicationJSONServersImageStatusEnum = "unavailable"
)

func (e *GetServers200ApplicationJSONServersImageStatusEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "available":
		fallthrough
	case "creating":
		fallthrough
	case "unavailable":
		*e = GetServers200ApplicationJSONServersImageStatusEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for GetServers200ApplicationJSONServersImageStatusEnum: %s", s)
	}
}

// GetServers200ApplicationJSONServersImageTypeEnum - Type of the Image
type GetServers200ApplicationJSONServersImageTypeEnum string

const (
	GetServers200ApplicationJSONServersImageTypeEnumSystem    GetServers200ApplicationJSONServersImageTypeEnum = "system"
	GetServers200ApplicationJSONServersImageTypeEnumApp       GetServers200ApplicationJSONServersImageTypeEnum = "app"
	GetServers200ApplicationJSONServersImageTypeEnumSnapshot  GetServers200ApplicationJSONServersImageTypeEnum = "snapshot"
	GetServers200ApplicationJSONServersImageTypeEnumBackup    GetServers200ApplicationJSONServersImageTypeEnum = "backup"
	GetServers200ApplicationJSONServersImageTypeEnumTemporary GetServers200ApplicationJSONServersImageTypeEnum = "temporary"
)

func (e *GetServers200ApplicationJSONServersImageTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "system":
		fallthrough
	case "app":
		fallthrough
	case "snapshot":
		fallthrough
	case "backup":
		fallthrough
	case "temporary":
		*e = GetServers200ApplicationJSONServersImageTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for GetServers200ApplicationJSONServersImageTypeEnum: %s", s)
	}
}

type GetServers200ApplicationJSONServersImage struct {
	// ID of Server the Image is bound to. Only set for Images of type `backup`.
	BoundTo int64 `json:"bound_to"`
	// Point in time when the Resource was created (in ISO-8601 format)
	Created string `json:"created"`
	// Information about the Server the Image was created from
	CreatedFrom GetServers200ApplicationJSONServersImageCreatedFrom `json:"created_from"`
	// Point in time where the Image was deleted (in ISO-8601 format)
	Deleted string `json:"deleted"`
	// Point in time when the Image is considered to be deprecated (in ISO-8601 format)
	Deprecated string `json:"deprecated"`
	// Description of the Image
	Description string `json:"description"`
	// Size of the disk contained in the Image in GB
	DiskSize float64 `json:"disk_size"`
	// ID of the Resource
	ID int64 `json:"id"`
	// Size of the Image file in our storage in GB. For snapshot Images this is the value relevant for calculating costs for the Image.
	ImageSize float64 `json:"image_size"`
	// User-defined labels (key-value pairs)
	Labels map[string]string `json:"labels"`
	// Unique identifier of the Image. This value is only set for system Images.
	Name string `json:"name"`
	// Flavor of operating system contained in the Image
	OsFlavor GetServers200ApplicationJSONServersImageOsFlavorEnum `json:"os_flavor"`
	// Operating system version
	OsVersion string `json:"os_version"`
	// Protection configuration for the Resource
	Protection GetServers200ApplicationJSONServersImageProtection `json:"protection"`
	// Indicates that rapid deploy of the Image is available
	RapidDeploy *bool `json:"rapid_deploy,omitempty"`
	// Whether the Image can be used or if it's still being created or unavailable
	Status GetServers200ApplicationJSONServersImageStatusEnum `json:"status"`
	// Type of the Image
	Type GetServers200ApplicationJSONServersImageTypeEnum `json:"type"`
}

// GetServers200ApplicationJSONServersIsoTypeEnum - Type of the ISO
type GetServers200ApplicationJSONServersIsoTypeEnum string

const (
	GetServers200ApplicationJSONServersIsoTypeEnumPublic  GetServers200ApplicationJSONServersIsoTypeEnum = "public"
	GetServers200ApplicationJSONServersIsoTypeEnumPrivate GetServers200ApplicationJSONServersIsoTypeEnum = "private"
)

func (e *GetServers200ApplicationJSONServersIsoTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "public":
		fallthrough
	case "private":
		*e = GetServers200ApplicationJSONServersIsoTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for GetServers200ApplicationJSONServersIsoTypeEnum: %s", s)
	}
}

// GetServers200ApplicationJSONServersIso - ISO Image that is attached to this Server. Null if no ISO is attached.
type GetServers200ApplicationJSONServersIso struct {
	// ISO 8601 timestamp of deprecation, null if ISO is still available. After the deprecation time it will no longer be possible to attach the ISO to Servers.
	Deprecated string `json:"deprecated"`
	// Description of the ISO
	Description string `json:"description"`
	// ID of the Resource
	ID int64 `json:"id"`
	// Unique identifier of the ISO. Only set for public ISOs
	Name string `json:"name"`
	// Type of the ISO
	Type GetServers200ApplicationJSONServersIsoTypeEnum `json:"type"`
}

// GetServers200ApplicationJSONServersPlacementGroupNullableTypeEnum - Type of the Placement Group
type GetServers200ApplicationJSONServersPlacementGroupNullableTypeEnum string

const (
	GetServers200ApplicationJSONServersPlacementGroupNullableTypeEnumSpread GetServers200ApplicationJSONServersPlacementGroupNullableTypeEnum = "spread"
)

func (e *GetServers200ApplicationJSONServersPlacementGroupNullableTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "spread":
		*e = GetServers200ApplicationJSONServersPlacementGroupNullableTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for GetServers200ApplicationJSONServersPlacementGroupNullableTypeEnum: %s", s)
	}
}

type GetServers200ApplicationJSONServersPlacementGroupNullable struct {
	// Point in time when the Resource was created (in ISO-8601 format)
	Created string `json:"created"`
	// ID of the Resource
	ID int64 `json:"id"`
	// User-defined labels (key-value pairs)
	Labels map[string]string `json:"labels"`
	// Name of the Resource. Must be unique per Project.
	Name string `json:"name"`
	// Array of IDs of Servers that are part of this Placement Group
	Servers []int64 `json:"servers"`
	// Type of the Placement Group
	Type GetServers200ApplicationJSONServersPlacementGroupNullableTypeEnum `json:"type"`
}

type GetServers200ApplicationJSONServersPrivateNet struct {
	AliasIps   []string `json:"alias_ips,omitempty"`
	IP         *string  `json:"ip,omitempty"`
	MacAddress *string  `json:"mac_address,omitempty"`
	Network    *int64   `json:"network,omitempty"`
}

// GetServers200ApplicationJSONServersProtection - Protection configuration for the Server
type GetServers200ApplicationJSONServersProtection struct {
	// If true, prevents the Server from being deleted
	Delete bool `json:"delete"`
	// If true, prevents the Server from being rebuilt
	Rebuild bool `json:"rebuild"`
}

// GetServers200ApplicationJSONServersPublicNetServerPublicNetFirewallStatusEnum - Status of the Firewall on the Server
type GetServers200ApplicationJSONServersPublicNetServerPublicNetFirewallStatusEnum string

const (
	GetServers200ApplicationJSONServersPublicNetServerPublicNetFirewallStatusEnumApplied GetServers200ApplicationJSONServersPublicNetServerPublicNetFirewallStatusEnum = "applied"
	GetServers200ApplicationJSONServersPublicNetServerPublicNetFirewallStatusEnumPending GetServers200ApplicationJSONServersPublicNetServerPublicNetFirewallStatusEnum = "pending"
)

func (e *GetServers200ApplicationJSONServersPublicNetServerPublicNetFirewallStatusEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "applied":
		fallthrough
	case "pending":
		*e = GetServers200ApplicationJSONServersPublicNetServerPublicNetFirewallStatusEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for GetServers200ApplicationJSONServersPublicNetServerPublicNetFirewallStatusEnum: %s", s)
	}
}

type GetServers200ApplicationJSONServersPublicNetServerPublicNetFirewall struct {
	// ID of the Resource
	ID *int64 `json:"id,omitempty"`
	// Status of the Firewall on the Server
	Status *GetServers200ApplicationJSONServersPublicNetServerPublicNetFirewallStatusEnum `json:"status,omitempty"`
}

// GetServers200ApplicationJSONServersPublicNetIpv4 - IP address (v4) and its reverse DNS entry of this Server
type GetServers200ApplicationJSONServersPublicNetIpv4 struct {
	// If the IP is blocked by our anti abuse dept
	Blocked bool `json:"blocked"`
	// Reverse DNS PTR entry for the IPv4 addresses of this Server
	DNSPtr string `json:"dns_ptr"`
	// ID of the Resource
	ID *int64 `json:"id,omitempty"`
	// IP address (v4) of this Server
	IP string `json:"ip"`
}

type GetServers200ApplicationJSONServersPublicNetIpv6DNSPtr struct {
	// DNS pointer for the specific IP address
	DNSPtr string `json:"dns_ptr"`
	// Single IPv6 address of this Server for which the reverse DNS entry has been set up
	IP string `json:"ip"`
}

// GetServers200ApplicationJSONServersPublicNetIpv6 - IPv6 network assigned to this Server and its reverse DNS entry
type GetServers200ApplicationJSONServersPublicNetIpv6 struct {
	// If the IP is blocked by our anti abuse dept
	Blocked bool `json:"blocked"`
	// Reverse DNS PTR entries for the IPv6 addresses of this Server, `null` by default
	DNSPtr []GetServers200ApplicationJSONServersPublicNetIpv6DNSPtr `json:"dns_ptr"`
	// ID of the Resource
	ID *int64 `json:"id,omitempty"`
	// IP address (v6) of this Server
	IP string `json:"ip"`
}

// GetServers200ApplicationJSONServersPublicNet - Public network information. The Server's IPv4 address can be found in `public_net->ipv4->ip`
type GetServers200ApplicationJSONServersPublicNet struct {
	// Firewalls applied to the public network interface of this Server
	Firewalls []GetServers200ApplicationJSONServersPublicNetServerPublicNetFirewall `json:"firewalls,omitempty"`
	// IDs of Floating IPs assigned to this Server
	FloatingIps []int64 `json:"floating_ips"`
	// IP address (v4) and its reverse DNS entry of this Server
	Ipv4 GetServers200ApplicationJSONServersPublicNetIpv4 `json:"ipv4"`
	// IPv6 network assigned to this Server and its reverse DNS entry
	Ipv6 GetServers200ApplicationJSONServersPublicNetIpv6 `json:"ipv6"`
}

// GetServers200ApplicationJSONServersServerTypeCPUTypeEnum - Type of cpu
type GetServers200ApplicationJSONServersServerTypeCPUTypeEnum string

const (
	GetServers200ApplicationJSONServersServerTypeCPUTypeEnumShared    GetServers200ApplicationJSONServersServerTypeCPUTypeEnum = "shared"
	GetServers200ApplicationJSONServersServerTypeCPUTypeEnumDedicated GetServers200ApplicationJSONServersServerTypeCPUTypeEnum = "dedicated"
)

func (e *GetServers200ApplicationJSONServersServerTypeCPUTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "shared":
		fallthrough
	case "dedicated":
		*e = GetServers200ApplicationJSONServersServerTypeCPUTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for GetServers200ApplicationJSONServersServerTypeCPUTypeEnum: %s", s)
	}
}

// GetServers200ApplicationJSONServersServerTypePricesPriceHourly - Hourly costs for a Server type in this Location
type GetServers200ApplicationJSONServersServerTypePricesPriceHourly struct {
	// Price with VAT added
	Gross string `json:"gross"`
	// Price without VAT
	Net string `json:"net"`
}

// GetServers200ApplicationJSONServersServerTypePricesPriceMonthly - Monthly costs for a Server type in this Location
type GetServers200ApplicationJSONServersServerTypePricesPriceMonthly struct {
	// Price with VAT added
	Gross string `json:"gross"`
	// Price without VAT
	Net string `json:"net"`
}

type GetServers200ApplicationJSONServersServerTypePrices struct {
	// Name of the Location the price is for
	Location string `json:"location"`
	// Hourly costs for a Server type in this Location
	PriceHourly GetServers200ApplicationJSONServersServerTypePricesPriceHourly `json:"price_hourly"`
	// Monthly costs for a Server type in this Location
	PriceMonthly GetServers200ApplicationJSONServersServerTypePricesPriceMonthly `json:"price_monthly"`
}

// GetServers200ApplicationJSONServersServerTypeStorageTypeEnum - Type of Server boot drive. Local has higher speed. Network has better availability.
type GetServers200ApplicationJSONServersServerTypeStorageTypeEnum string

const (
	GetServers200ApplicationJSONServersServerTypeStorageTypeEnumLocal   GetServers200ApplicationJSONServersServerTypeStorageTypeEnum = "local"
	GetServers200ApplicationJSONServersServerTypeStorageTypeEnumNetwork GetServers200ApplicationJSONServersServerTypeStorageTypeEnum = "network"
)

func (e *GetServers200ApplicationJSONServersServerTypeStorageTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "local":
		fallthrough
	case "network":
		*e = GetServers200ApplicationJSONServersServerTypeStorageTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for GetServers200ApplicationJSONServersServerTypeStorageTypeEnum: %s", s)
	}
}

// GetServers200ApplicationJSONServersServerType - Type of Server - determines how much ram, disk and cpu a Server has
type GetServers200ApplicationJSONServersServerType struct {
	// Number of cpu cores a Server of this type will have
	Cores float64 `json:"cores"`
	// Type of cpu
	CPUType GetServers200ApplicationJSONServersServerTypeCPUTypeEnum `json:"cpu_type"`
	// True if Server type is deprecated
	Deprecated bool `json:"deprecated"`
	// Description of the Server type
	Description string `json:"description"`
	// Disk size a Server of this type will have in GB
	Disk float64 `json:"disk"`
	// ID of the Server type
	ID int64 `json:"id"`
	// Memory a Server of this type will have in GB
	Memory float64 `json:"memory"`
	// Unique identifier of the Server type
	Name string `json:"name"`
	// Prices in different Locations
	Prices []GetServers200ApplicationJSONServersServerTypePrices `json:"prices"`
	// Type of Server boot drive. Local has higher speed. Network has better availability.
	StorageType GetServers200ApplicationJSONServersServerTypeStorageTypeEnum `json:"storage_type"`
}

// GetServers200ApplicationJSONServersStatusEnum - Status of the Server
type GetServers200ApplicationJSONServersStatusEnum string

const (
	GetServers200ApplicationJSONServersStatusEnumRunning      GetServers200ApplicationJSONServersStatusEnum = "running"
	GetServers200ApplicationJSONServersStatusEnumInitializing GetServers200ApplicationJSONServersStatusEnum = "initializing"
	GetServers200ApplicationJSONServersStatusEnumStarting     GetServers200ApplicationJSONServersStatusEnum = "starting"
	GetServers200ApplicationJSONServersStatusEnumStopping     GetServers200ApplicationJSONServersStatusEnum = "stopping"
	GetServers200ApplicationJSONServersStatusEnumOff          GetServers200ApplicationJSONServersStatusEnum = "off"
	GetServers200ApplicationJSONServersStatusEnumDeleting     GetServers200ApplicationJSONServersStatusEnum = "deleting"
	GetServers200ApplicationJSONServersStatusEnumMigrating    GetServers200ApplicationJSONServersStatusEnum = "migrating"
	GetServers200ApplicationJSONServersStatusEnumRebuilding   GetServers200ApplicationJSONServersStatusEnum = "rebuilding"
	GetServers200ApplicationJSONServersStatusEnumUnknown      GetServers200ApplicationJSONServersStatusEnum = "unknown"
)

func (e *GetServers200ApplicationJSONServersStatusEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "running":
		fallthrough
	case "initializing":
		fallthrough
	case "starting":
		fallthrough
	case "stopping":
		fallthrough
	case "off":
		fallthrough
	case "deleting":
		fallthrough
	case "migrating":
		fallthrough
	case "rebuilding":
		fallthrough
	case "unknown":
		*e = GetServers200ApplicationJSONServersStatusEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for GetServers200ApplicationJSONServersStatusEnum: %s", s)
	}
}

type GetServers200ApplicationJSONServers struct {
	// Time window (UTC) in which the backup will run, or null if the backups are not enabled
	BackupWindow string `json:"backup_window"`
	// Point in time when the Resource was created (in ISO-8601 format)
	Created string `json:"created"`
	// Datacenter this Resource is located at
	Datacenter GetServers200ApplicationJSONServersDatacenter `json:"datacenter"`
	// ID of the Resource
	ID    int64                                    `json:"id"`
	Image GetServers200ApplicationJSONServersImage `json:"image"`
	// Free Traffic for the current billing period in bytes
	IncludedTraffic float64 `json:"included_traffic"`
	// Inbound Traffic for the current billing period in bytes
	IngoingTraffic float64 `json:"ingoing_traffic"`
	// ISO Image that is attached to this Server. Null if no ISO is attached.
	Iso GetServers200ApplicationJSONServersIso `json:"iso"`
	// User-defined labels (key-value pairs)
	Labels        map[string]string `json:"labels"`
	LoadBalancers []int64           `json:"load_balancers,omitempty"`
	// True if Server has been locked and is not available to user
	Locked bool `json:"locked"`
	// Name of the Server (must be unique per Project and a valid hostname as per RFC 1123)
	Name string `json:"name"`
	// Outbound Traffic for the current billing period in bytes
	OutgoingTraffic float64                                                    `json:"outgoing_traffic"`
	PlacementGroup  *GetServers200ApplicationJSONServersPlacementGroupNullable `json:"placement_group,omitempty"`
	// Size of the primary Disk
	PrimaryDiskSize float64 `json:"primary_disk_size"`
	// Private networks information
	PrivateNet []GetServers200ApplicationJSONServersPrivateNet `json:"private_net"`
	// Protection configuration for the Server
	Protection GetServers200ApplicationJSONServersProtection `json:"protection"`
	// Public network information. The Server's IPv4 address can be found in `public_net->ipv4->ip`
	PublicNet GetServers200ApplicationJSONServersPublicNet `json:"public_net"`
	// True if rescue mode is enabled. Server will then boot into rescue system on next reboot
	RescueEnabled bool `json:"rescue_enabled"`
	// Type of Server - determines how much ram, disk and cpu a Server has
	ServerType GetServers200ApplicationJSONServersServerType `json:"server_type"`
	// Status of the Server
	Status GetServers200ApplicationJSONServersStatusEnum `json:"status"`
	// IDs of Volumes assigned to this Server
	Volumes []int64 `json:"volumes,omitempty"`
}

// GetServers200ApplicationJSON - A paged array of servers
type GetServers200ApplicationJSON struct {
	Meta    *GetServers200ApplicationJSONMeta     `json:"meta,omitempty"`
	Servers []GetServers200ApplicationJSONServers `json:"servers"`
}

type GetServersResponse struct {
	ContentType string
	StatusCode  int
	RawResponse *http.Response
	// A paged array of servers
	GetServers200ApplicationJSONObject *GetServers200ApplicationJSON
}
