<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class PublicT 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * Cancel file upload
     * 
     * ### Description:
     * Abort (chunked) upload via Upload Share.
     * 
     * ### Precondition:
     * Valid Upload ID.
     * 
     * ### Postcondition:
     * Aborts upload and invalidates upload ID / token.
     * 
     * ### Further Information:
     * None.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CancelFileUploadViaShareRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CancelFileUploadViaShareResponse
     */
	public function cancelFileUploadViaShare(
        \OpenAPI\OpenAPI\Models\Operations\CancelFileUploadViaShareRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CancelFileUploadViaShareResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/public/shares/uploads/{access_key}/{upload_id}', \OpenAPI\OpenAPI\Models\Operations\CancelFileUploadViaShareRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CancelFileUploadViaShareResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 504 or $httpResponse->getStatusCode() === 507) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Check public Download Share password
     * 
     * <h3 style='padding: 5px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px; display: table-cell;'>&#128640; Since v4.36.0</h3>
     * 
     * ### Description:
     * Check password for a public Download Share
     * 
     * ### Precondition:
     * None.
     * 
     * ### Postcondition:
     * None.
     * 
     * ### Further Information:
     * None.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CheckPublicDownloadSharePasswordRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CheckPublicDownloadSharePasswordResponse
     */
	public function checkPublicDownloadSharePassword(
        \OpenAPI\OpenAPI\Models\Operations\CheckPublicDownloadSharePasswordRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CheckPublicDownloadSharePasswordResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/public/shares/downloads/{access_key}', \OpenAPI\OpenAPI\Models\Operations\CheckPublicDownloadSharePasswordRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\CheckPublicDownloadSharePasswordRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('HEAD', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CheckPublicDownloadSharePasswordResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406) {
        }

        return $response;
    }
	
    /**
     * Complete file upload
     * 
     * ### Description:
     * Finalize (chunked) upload via Upload Share.
     * 
     * ### Precondition:
     * Valid upload ID.  
     * Only returns users that owns one of the following permissions: <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; manage</span>, <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; read</span>, <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; manage download share</span>, <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; manage upload share</span>
     * 
     * ### Postcondition:
     * Finalizes upload.
     * 
     * ### Further Information:
     * Chunked uploads (range requests) are supported.  
     * 
     * Please ensure that all chunks have been transferred correctly before finishing the upload.  
     * If file hash has been created in time a `201 Created` will be responded and hash will be part of response, otherwise it will be a `202 Accepted` without it.
     * 
     * https://tools.ietf.org/html/rfc7233 - Range Requests
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CompleteFileUploadViaShareRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CompleteFileUploadViaShareResponse
     * @see https://tools.ietf.org/html/rfc7233
     */
	public function completeFileUploadViaShare(
        \OpenAPI\OpenAPI\Models\Operations\CompleteFileUploadViaShareRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CompleteFileUploadViaShareResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/public/shares/uploads/{access_key}/{upload_id}', \OpenAPI\OpenAPI\Models\Operations\CompleteFileUploadViaShareRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "userFileKeyList", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CompleteFileUploadViaShareResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201 or $httpResponse->getStatusCode() === 202) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->publicUploadedFileData = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\PublicUploadedFileData', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 412 or $httpResponse->getStatusCode() === 504 or $httpResponse->getStatusCode() === 507) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Complete S3 file upload
     * 
     * <h3 style='padding: 5px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px; display: table-cell;'>&#128640; Since v4.15.0</h3>
     * 
     * ### Description:
     * Finishes a S3 file upload and closes the corresponding upload channel.
     * 
     * ### Precondition:
     * Valid upload ID.  
     * Only returns users that owns one of the following permissions: <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; manage</span>, <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; read</span>, <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; manage download share</span>, <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; manage upload share</span>
     * 
     * ### Postcondition:
     * Upload channel is closed. S3 multipart upload request is completed.
     * 
     * ### Further Information:
     * None.
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CompleteS3FileUploadViaShareRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CompleteS3FileUploadViaShareResponse
     */
	public function completeS3FileUploadViaShare(
        \OpenAPI\OpenAPI\Models\Operations\CompleteS3FileUploadViaShareRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CompleteS3FileUploadViaShareResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/public/shares/uploads/{access_key}/{upload_id}/s3', \OpenAPI\OpenAPI\Models\Operations\CompleteS3FileUploadViaShareRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "completeS3ShareUploadRequest", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CompleteS3FileUploadViaShareResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 202) {
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 412) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create new file upload channel
     * 
     * ### Description:  
     * Create a new upload channel.
     * 
     * ### Precondition:
     * None.
     * 
     * ### Postcondition:
     * Upload channel is created and corresponding upload URL, token & upload ID are returned.
     * 
     * ### Further Information:
     * Use `uploadUrl` the upload `token` is deprecated.  
     * 
     * Please provide the size of the intended upload so that the quota can be checked in advanced and no data is transferred unnecessarily.
     * 
     * ### Node naming convention:
     * * Node (room, folder, file) names are limited to **150** characters.
     * * Illegal names:  
     * `'CON', 'PRN', 'AUX', 'NUL', 'COM1', 'COM2', 'COM3', 'COM4', 'COM5', 'COM6', 'COM7', 'COM8', 'COM9', 'LPT1', 'LPT2', 'LPT3', 'LPT4', 'LPT5', 'LPT6', 'LPT7', 'LPT8', 'LPT9', (and any of those with an extension)`
     * * Illegal characters in names:  
     * `'\\', '<','>', ':', '\"', '|', '?', '*', '/', leading '-', trailing '.' `
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateShareUploadChannelRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateShareUploadChannelResponse
     */
	public function createShareUploadChannel(
        \OpenAPI\OpenAPI\Models\Operations\CreateShareUploadChannelRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateShareUploadChannelResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/public/shares/uploads/{access_key}', \OpenAPI\OpenAPI\Models\Operations\CreateShareUploadChannelRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "createShareUploadChannelRequest", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateShareUploadChannelResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->createShareUploadChannelResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CreateShareUploadChannelResponse', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 412 or $httpResponse->getStatusCode() === 504 or $httpResponse->getStatusCode() === 507) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Download file with token
     * 
     * ### Description:  
     * Download a file (or zip archive if target is a folder or room).
     * 
     * ### Precondition:
     * Valid download token.
     * 
     * ### Postcondition:
     * Stream is returned.
     * 
     * ### Further Information:
     * Range requests are supported.  
     * Range requests are illegal for zip archive download.
     * https://tools.ietf.org/html/rfc7233 - Range Requests
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DownloadFileViaTokenPublicRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DownloadFileViaTokenPublicResponse
     * @see https://tools.ietf.org/html/rfc7233
     */
	public function downloadFileViaTokenPublic(
        \OpenAPI\OpenAPI\Models\Operations\DownloadFileViaTokenPublicRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DownloadFileViaTokenPublicResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/public/shares/downloads/{access_key}/{token}', \OpenAPI\OpenAPI\Models\Operations\DownloadFileViaTokenPublicRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DownloadFileViaTokenPublicRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DownloadFileViaTokenPublicResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 206) {
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 416) {
            if (Utils\Utils::matchContentType($contentType, 'application/octet-stream')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * Download file with token
     * 
     * ### Description:  
     * Download a file (or zip archive if target is a folder or room).
     * 
     * ### Precondition:
     * Valid download token.
     * 
     * ### Postcondition:
     * Stream is returned.
     * 
     * ### Further Information:
     * Range requests are supported.  
     * Range requests are illegal for zip archive download.
     * https://tools.ietf.org/html/rfc7233 - Range Requests
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DownloadFileViaTokenPublic1Request $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DownloadFileViaTokenPublic1Response
     * @see https://tools.ietf.org/html/rfc7233
     */
	public function downloadFileViaTokenPublic1(
        \OpenAPI\OpenAPI\Models\Operations\DownloadFileViaTokenPublic1Request $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DownloadFileViaTokenPublic1Response
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/public/shares/downloads/{access_key}/{token}', \OpenAPI\OpenAPI\Models\Operations\DownloadFileViaTokenPublic1Request::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DownloadFileViaTokenPublic1Request::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('HEAD', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DownloadFileViaTokenPublic1Response();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 206) {
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 416) {
            if (Utils\Utils::matchContentType($contentType, 'application/octet-stream')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * Generate download URL
     * 
     * ### Description:
     * Generate a download URL to retrieve a shared file.
     * 
     * ### Precondition:
     * None.
     * 
     * ### Postcondition:
     * Download URL and token are generated and returned.
     * 
     * ### Further Information:
     * Use `downloadUrl` the download `token` is deprecated.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GenerateDownloadUrlPublicRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GenerateDownloadUrlPublicResponse
     */
	public function generateDownloadUrlPublic(
        \OpenAPI\OpenAPI\Models\Operations\GenerateDownloadUrlPublicRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GenerateDownloadUrlPublicResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/public/shares/downloads/{access_key}', \OpenAPI\OpenAPI\Models\Operations\GenerateDownloadUrlPublicRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "publicDownloadTokenGenerateRequest", "json");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GenerateDownloadUrlPublicResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->publicDownloadTokenGenerateResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\PublicDownloadTokenGenerateResponse', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Generate presigned URLs for S3 file upload
     * 
     * <h3 style='padding: 5px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px; display: table-cell;'>&#128640; Since v4.15.0</h3>
     * 
     * ### Description:
     * Generate presigned URLs for S3 file upload.
     * 
     * ### Precondition:
     * Valid upload ID
     * 
     * ### Postcondition:
     * List of presigned URLs is returned.
     * 
     * ### Further Information:
     * The size for each part must be >= 5 MB, except for the last part.  
     * The part number of the first part in S3 is 1 (not 0).  
     * Use HTTP method `PUT` for uploading bytes via presigned URL.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GeneratePresignedUrlsPublicRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GeneratePresignedUrlsPublicResponse
     */
	public function generatePresignedUrlsPublic(
        \OpenAPI\OpenAPI\Models\Operations\GeneratePresignedUrlsPublicRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GeneratePresignedUrlsPublicResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/public/shares/uploads/{access_key}/{upload_id}/s3_urls', \OpenAPI\OpenAPI\Models\Operations\GeneratePresignedUrlsPublicRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "generatePresignedUrlsRequest", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GeneratePresignedUrlsPublicResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->presignedUrlList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\PresignedUrlList', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 412 or $httpResponse->getStatusCode() === 504 or $httpResponse->getStatusCode() === 507) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Request Active Directory authentication information
     * 
     * ### Description:  
     * Provides information about Active Directory authentication options.
     * 
     * ### Precondition:
     * None.
     * 
     * ### Postcondition:
     * Active Directory authentication options information is returned.
     * 
     * ### Further Information:
     * None.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RequestActiveDirectoryAuthInfoRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RequestActiveDirectoryAuthInfoResponse
     */
	public function requestActiveDirectoryAuthInfo(
        \OpenAPI\OpenAPI\Models\Operations\RequestActiveDirectoryAuthInfoRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RequestActiveDirectoryAuthInfoResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/public/system/info/auth/ad');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\RequestActiveDirectoryAuthInfoRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RequestActiveDirectoryAuthInfoResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->activeDirectoryAuthInfo = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ActiveDirectoryAuthInfo', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 406) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Request OpenID Connect provider authentication information
     * 
     * ### Description:  
     * Provides information about OpenID Connect authentication options.
     * 
     * ### Precondition:
     * None.
     * 
     * ### Postcondition:
     * OpenID Connect authentication options information is returned.
     * 
     * ### Further Information:
     * None.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RequestOpenIdAuthInfoRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RequestOpenIdAuthInfoResponse
     */
	public function requestOpenIdAuthInfo(
        \OpenAPI\OpenAPI\Models\Operations\RequestOpenIdAuthInfoRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RequestOpenIdAuthInfoResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/public/system/info/auth/openid');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\RequestOpenIdAuthInfoRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RequestOpenIdAuthInfoResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->openIdAuthInfo = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\OpenIdAuthInfo', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 406) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Request public Download Share information
     * 
     * ### Description:  
     * Retrieve the public information of a Download Share.
     * 
     * ### Precondition:
     * None.
     * 
     * ### Postcondition:
     * Download Share information is returned.
     * 
     * ### Further Information:
     * None.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RequestPublicDownloadShareInfoRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RequestPublicDownloadShareInfoResponse
     */
	public function requestPublicDownloadShareInfo(
        \OpenAPI\OpenAPI\Models\Operations\RequestPublicDownloadShareInfoRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RequestPublicDownloadShareInfoResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/public/shares/downloads/{access_key}', \OpenAPI\OpenAPI\Models\Operations\RequestPublicDownloadShareInfoRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RequestPublicDownloadShareInfoResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->publicDownloadShare = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\PublicDownloadShare', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Request public Upload Share information
     * 
     * ### Description:  
     * Provides information about the desired Upload Share.
     * 
     * ### Precondition:
     * Only `userUserPublicKeyList` is returned to the users who owns one of the following permissions: <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; manage</span>, <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; read</span>, <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; manage download share</span>, <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; manage upload share</span>
     * 
     * ### Postcondition:
     * None.
     * 
     * ### Further Information:
     * If no password is set, the returned information is reduced to the following attributes (if available):
     * 
     * * `name`
     * * `createdAt`
     * * `isProtected`
     * * `isEncrypted`
     * * `showUploadedFiles`
     * * `userUserPublicKeyList` (if parent is end-to-end encrypted)
     * 
     * Only if the password is transmitted as `X-Sds-Share-Password` header, all values are returned.
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RequestPublicUploadShareInfoRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RequestPublicUploadShareInfoResponse
     */
	public function requestPublicUploadShareInfo(
        \OpenAPI\OpenAPI\Models\Operations\RequestPublicUploadShareInfoRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RequestPublicUploadShareInfoResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/public/shares/uploads/{access_key}', \OpenAPI\OpenAPI\Models\Operations\RequestPublicUploadShareInfoRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RequestPublicUploadShareInfoResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->publicUploadShare = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\PublicUploadShare', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Request software version information
     * 
     * ### Description:  
     * Public software version information.
     * 
     * ### Precondition:
     * None.
     * 
     * ### Postcondition:
     * Sofware version information is returned.
     * 
     * ### Further Information:
     * The version of DRACOON Server consists of two components:
     * * **API**
     * * **Core** (referred to as _"Server"_)
     * 
     * which are versioned individually.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RequestSoftwareVersionRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RequestSoftwareVersionResponse
     */
	public function requestSoftwareVersion(
        \OpenAPI\OpenAPI\Models\Operations\RequestSoftwareVersionRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RequestSoftwareVersionResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/public/software/version');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RequestSoftwareVersionResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->softwareVersionData = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\SoftwareVersionData', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 406) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Request system information
     * 
     * ### Description:  
     * Provides information about system.
     * 
     * ### Precondition:
     * None.
     * 
     * ### Postcondition:
     * System information is returned.
     * 
     * ### Further Information:
     * Authentication methods are sorted by **priority** attribute.  
     * Smaller values have higher priority.  
     * Authentication method with highest priority is considered as default.
     * 
     * ### System information:
     * <details style="padding: 10px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px;">
     * <summary style="cursor: pointer; outline: none"><strong>Expand</strong></summary>
     * 
     * | Setting | Description | Value |
     * | :--- | :--- | :--- |
     * | `languageDefault` | Defines which language should be default. | `ISO 639-1 code` |
     * | `hideLoginInputFields` | Defines if login fields should be hidden. | `true or false` |
     * | `s3Hosts` | List of available S3 hosts. | `String array` |
     * | `s3EnforceDirectUpload` | Determines whether S3 direct upload is enforced or not. | `true or false` |
     * | `useS3Storage` | Determines whether S3 Storage enabled and used. | `true or false` |
     * 
     * </details>
     * 
     * ### Authentication methods:
     * <details style="padding: 10px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px;">
     * <summary style="cursor: pointer; outline: none"><strong>Expand</strong></summary>
     * 
     * | Authentication Method | Description |
     * | :--- | :--- |
     * | `basic` | **Basic** authentication globally allowed.<br>This option **MUST** be activated to allow users to log in with their credentials stored in the database.<br>Formerly known as `sql`. |
     * | `active_directory` | **Active Directory** authentication globally allowed.<br>This option **MUST** be activated to allow users to log in with their Active Directory credentials. |
     * | `radius` | **RADIUS** authentication globally allowed.<br>This option **MUST** be activated to allow users to log in with their RADIUS username, their PIN and a token password. |
     * | `openid` | **OpenID Connect** authentication globally allowed.This option **MUST** be activated to allow users to log in with their OpenID Connect identity. |
     * | `hideLoginInputFields` | Determines whether input fields for login should be enabled | `true or false` |
     * 
     * </details>
     * https://tools.ietf.org/html/rfc5646 - Tags for Identifying Languages
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RequestSystemInfoRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RequestSystemInfoResponse
     * @see https://tools.ietf.org/html/rfc5646
     */
	public function requestSystemInfo(
        \OpenAPI\OpenAPI\Models\Operations\RequestSystemInfoRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RequestSystemInfoResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/public/system/info');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\RequestSystemInfoRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RequestSystemInfoResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->systemInfo = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\SystemInfo', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 406) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Request system time
     * 
     * ### Description:  
     * Retrieve the actual server time.
     * 
     * ### Precondition:
     * None.
     * 
     * ### Postcondition:
     * Server time is returned.
     * 
     * ### Further Information:
     * None.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RequestSystemTimeRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RequestSystemTimeResponse
     */
	public function requestSystemTime(
        \OpenAPI\OpenAPI\Models\Operations\RequestSystemTimeRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RequestSystemTimeResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/public/time');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RequestSystemTimeResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->sdsServerTime = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\SdsServerTime', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 406) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Request third-party software dependencies
     * 
     * <h3 style='padding: 5px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px; display: table-cell;'>&#128640; Since v4.9.0</h3>
     * 
     * ### Description:  
     * Provides information about used third-party software dependencies.
     * 
     * ### Precondition:
     * None.
     * 
     * ### Postcondition:
     * List of the third-party software dependencies used by **DRACOON Core** (referred to as _"Server"_) is returned.
     * 
     * ### Further Information:
     * None.
     * 
     * 
     * 
     * @return \OpenAPI\OpenAPI\Models\Operations\RequestThirdPartyDependenciesResponse
     */
	public function requestThirdPartyDependencies(
    ): \OpenAPI\OpenAPI\Models\Operations\RequestThirdPartyDependenciesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/public/software/third_party_dependencies');
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RequestThirdPartyDependenciesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->thirdPartyDependenciesData = $serializer->deserialize((string)$httpResponse->getBody(), 'array<OpenAPI\OpenAPI\Models\Shared\ThirdPartyDependenciesData>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 406) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Request status of S3 file upload
     * 
     * <h3 style='padding: 5px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px; display: table-cell;'>&#128640; Since v4.15.0</h3>
     * 
     * ### Description:
     * Request status of a S3 file upload.
     * 
     * ### Precondition:
     * An upload channel has been created and the user has <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; create</span> permissions in the parent container (room or folder).
     * 
     * ### Postcondition:
     * Status of S3 multipart upload request is returned.
     * 
     * ### Further Information:
     * None.
     * 
     * ### Possible errors:
     * <details style="padding: 10px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px;">
     * <summary style="cursor: pointer; outline: none"><strong>Expand</strong></summary>
     * 
     * | Http Status | Error Code | Description |
     * | :--- | :--- | :--- |
     * | `400 Bad Request` | `-80000` | Mandatory fields cannot be empty |
     * | `400 Bad Request` | `-80001` | Invalid positive number |
     * | `400 Bad Request` | `-80002` | Invalid number |
     * | `400 Bad Request` | `-40001` | (Target) room is not encrypted |
     * | `400 Bad Request` | `-40755` | Bad file name |
     * | `400 Bad Request` | `-40763` | File key must be set for an upload into encrypted room |
     * | `400 Bad Request` | `-50506` | Exceeds the number of files for this Upload Share |
     * | `403 Forbidden` |  | Access denied |
     * | `404 Not Found` | `-20501` | Upload not found |
     * | `404 Not Found` | `-40000` | Container not found |
     * | `404 Not Found` | `-41000` | Node not found |
     * | `404 Not Found` | `-70501` | User not found |
     * | `409 Conflict` | `-40010` | Container cannot be overwritten |
     * | `409 Conflict` |  | File cannot be overwritten |
     * | `500 Internal Server Error` |  | System Error |
     * | `502 Bad Gateway` |  | S3 Error |
     * | `502 Insufficient Storage` | `-50504` | Exceeds the quota for this Upload Share |
     * | `502 Insufficient Storage` | `-40200` | Exceeds the free node quota in room |
     * | `502 Insufficient Storage` | `-90200` | Exceeds the free customer quota |
     * | `502 Insufficient Storage` | `-90201` | Exceeds the free customer physical disk space |
     * 
     * </details>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RequestUploadStatusPublicRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RequestUploadStatusPublicResponse
     */
	public function requestUploadStatusPublic(
        \OpenAPI\OpenAPI\Models\Operations\RequestUploadStatusPublicRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RequestUploadStatusPublicResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/public/shares/uploads/{access_key}/{upload_id}', \OpenAPI\OpenAPI\Models\Operations\RequestUploadStatusPublicRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RequestUploadStatusPublicResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->s3ShareUploadStatus = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\S3ShareUploadStatus', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 412) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Upload file
     * 
     * ### Description:  
     * Chunked upload of files via Upload Share.
     * 
     * ### Precondition:
     * Valid upload ID.
     * 
     * ### Postcondition:
     * Chunk of file is uploaded.
     * 
     * ### Further Information:
     * Chunked uploads (range requests) are supported.
     * 
     * Following `Content-Types` are supported by this API:
     * * `multipart/form-data`
     * * provided `Content-Type`  
     * 
     * For both file upload types set the correct `Content-Type` header and body.  
     * 
     * ### Examples:  
     * 
     * * `multipart/form-data`
     * ```
     * POST /api/v4/public/shares/uploads/{access_key}{upload_id} HTTP/1.1
     * 
     * Header:
     * ...
     * Content-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW
     * ...
     * 
     * Body:
     * ------WebKitFormBoundary7MA4YWxkTrZu0gW
     * Content-Disposition: form-data; name="file"; filename="file.txt"
     * Content-Type: text/plain
     * 
     * Content of file.txt
     * ------WebKitFormBoundary7MA4YWxkTrZu0gW--
     * ```
     * 
     * * any other `Content-Type`  
     * ```
     * POST /api/v4/public/shares/uploads/{access_key}{upload_id} HTTP/1.1
     * 
     * Header:
     * ...
     * Content-Type: { ... }
     * ...
     * 
     * Body:
     * raw content
     * ```
     * https://tools.ietf.org/html/rfc7233 - Range Requests
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UploadFileAsMultipartPublic1Request $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UploadFileAsMultipartPublic1Response
     * @see https://tools.ietf.org/html/rfc7233
     */
	public function uploadFileAsMultipartPublic1(
        \OpenAPI\OpenAPI\Models\Operations\UploadFileAsMultipartPublic1Request $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UploadFileAsMultipartPublic1Response
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/public/shares/uploads/{access_key}/{upload_id}', \OpenAPI\OpenAPI\Models\Operations\UploadFileAsMultipartPublic1Request::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "multipart");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UploadFileAsMultipartPublic1Response();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->chunkUploadResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ChunkUploadResponse', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 412 or $httpResponse->getStatusCode() === 507) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
}