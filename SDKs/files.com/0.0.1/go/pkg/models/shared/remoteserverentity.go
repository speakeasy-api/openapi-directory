// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
)

// RemoteServerEntityAuthStatusEnum - Either `in_setup` or `complete`
type RemoteServerEntityAuthStatusEnum string

const (
	RemoteServerEntityAuthStatusEnumNotApplicable  RemoteServerEntityAuthStatusEnum = "not_applicable"
	RemoteServerEntityAuthStatusEnumInSetup        RemoteServerEntityAuthStatusEnum = "in_setup"
	RemoteServerEntityAuthStatusEnumComplete       RemoteServerEntityAuthStatusEnum = "complete"
	RemoteServerEntityAuthStatusEnumReauthenticate RemoteServerEntityAuthStatusEnum = "reauthenticate"
)

func (e *RemoteServerEntityAuthStatusEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "not_applicable":
		fallthrough
	case "in_setup":
		fallthrough
	case "complete":
		fallthrough
	case "reauthenticate":
		*e = RemoteServerEntityAuthStatusEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for RemoteServerEntityAuthStatusEnum: %s", s)
	}
}

// RemoteServerEntityFilesAgentPermissionSetEnum - Local permissions for files agent. read_only, write_only, or read_write
type RemoteServerEntityFilesAgentPermissionSetEnum string

const (
	RemoteServerEntityFilesAgentPermissionSetEnumReadWrite RemoteServerEntityFilesAgentPermissionSetEnum = "read_write"
	RemoteServerEntityFilesAgentPermissionSetEnumReadOnly  RemoteServerEntityFilesAgentPermissionSetEnum = "read_only"
	RemoteServerEntityFilesAgentPermissionSetEnumWriteOnly RemoteServerEntityFilesAgentPermissionSetEnum = "write_only"
)

func (e *RemoteServerEntityFilesAgentPermissionSetEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "read_write":
		fallthrough
	case "read_only":
		fallthrough
	case "write_only":
		*e = RemoteServerEntityFilesAgentPermissionSetEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for RemoteServerEntityFilesAgentPermissionSetEnum: %s", s)
	}
}

// RemoteServerEntityOneDriveAccountTypeEnum - Either personal or business_other account types
type RemoteServerEntityOneDriveAccountTypeEnum string

const (
	RemoteServerEntityOneDriveAccountTypeEnumPersonal      RemoteServerEntityOneDriveAccountTypeEnum = "personal"
	RemoteServerEntityOneDriveAccountTypeEnumBusinessOther RemoteServerEntityOneDriveAccountTypeEnum = "business_other"
)

func (e *RemoteServerEntityOneDriveAccountTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "personal":
		fallthrough
	case "business_other":
		*e = RemoteServerEntityOneDriveAccountTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for RemoteServerEntityOneDriveAccountTypeEnum: %s", s)
	}
}

// RemoteServerEntityServerCertificateEnum - Remote server certificate
type RemoteServerEntityServerCertificateEnum string

const (
	RemoteServerEntityServerCertificateEnumRequireMatch RemoteServerEntityServerCertificateEnum = "require_match"
	RemoteServerEntityServerCertificateEnumAllowAny     RemoteServerEntityServerCertificateEnum = "allow_any"
)

func (e *RemoteServerEntityServerCertificateEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "require_match":
		fallthrough
	case "allow_any":
		*e = RemoteServerEntityServerCertificateEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for RemoteServerEntityServerCertificateEnum: %s", s)
	}
}

// RemoteServerEntityServerTypeEnum - Remote server type.
type RemoteServerEntityServerTypeEnum string

const (
	RemoteServerEntityServerTypeEnumFtp                RemoteServerEntityServerTypeEnum = "ftp"
	RemoteServerEntityServerTypeEnumSftp               RemoteServerEntityServerTypeEnum = "sftp"
	RemoteServerEntityServerTypeEnumS3                 RemoteServerEntityServerTypeEnum = "s3"
	RemoteServerEntityServerTypeEnumGoogleCloudStorage RemoteServerEntityServerTypeEnum = "google_cloud_storage"
	RemoteServerEntityServerTypeEnumWebdav             RemoteServerEntityServerTypeEnum = "webdav"
	RemoteServerEntityServerTypeEnumWasabi             RemoteServerEntityServerTypeEnum = "wasabi"
	RemoteServerEntityServerTypeEnumBackblazeB2        RemoteServerEntityServerTypeEnum = "backblaze_b2"
	RemoteServerEntityServerTypeEnumOneDrive           RemoteServerEntityServerTypeEnum = "one_drive"
	RemoteServerEntityServerTypeEnumRackspace          RemoteServerEntityServerTypeEnum = "rackspace"
	RemoteServerEntityServerTypeEnumBox                RemoteServerEntityServerTypeEnum = "box"
	RemoteServerEntityServerTypeEnumDropbox            RemoteServerEntityServerTypeEnum = "dropbox"
	RemoteServerEntityServerTypeEnumGoogleDrive        RemoteServerEntityServerTypeEnum = "google_drive"
	RemoteServerEntityServerTypeEnumAzure              RemoteServerEntityServerTypeEnum = "azure"
	RemoteServerEntityServerTypeEnumSharepoint         RemoteServerEntityServerTypeEnum = "sharepoint"
	RemoteServerEntityServerTypeEnumS3Compatible       RemoteServerEntityServerTypeEnum = "s3_compatible"
	RemoteServerEntityServerTypeEnumAzureFiles         RemoteServerEntityServerTypeEnum = "azure_files"
	RemoteServerEntityServerTypeEnumFilesAgent         RemoteServerEntityServerTypeEnum = "files_agent"
	RemoteServerEntityServerTypeEnumFilebase           RemoteServerEntityServerTypeEnum = "filebase"
)

func (e *RemoteServerEntityServerTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "ftp":
		fallthrough
	case "sftp":
		fallthrough
	case "s3":
		fallthrough
	case "google_cloud_storage":
		fallthrough
	case "webdav":
		fallthrough
	case "wasabi":
		fallthrough
	case "backblaze_b2":
		fallthrough
	case "one_drive":
		fallthrough
	case "rackspace":
		fallthrough
	case "box":
		fallthrough
	case "dropbox":
		fallthrough
	case "google_drive":
		fallthrough
	case "azure":
		fallthrough
	case "sharepoint":
		fallthrough
	case "s3_compatible":
		fallthrough
	case "azure_files":
		fallthrough
	case "files_agent":
		fallthrough
	case "filebase":
		*e = RemoteServerEntityServerTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for RemoteServerEntityServerTypeEnum: %s", s)
	}
}

// RemoteServerEntitySslEnum - Should we require SSL?
type RemoteServerEntitySslEnum string

const (
	RemoteServerEntitySslEnumIfAvailable     RemoteServerEntitySslEnum = "if_available"
	RemoteServerEntitySslEnumRequire         RemoteServerEntitySslEnum = "require"
	RemoteServerEntitySslEnumRequireImplicit RemoteServerEntitySslEnum = "require_implicit"
	RemoteServerEntitySslEnumNever           RemoteServerEntitySslEnum = "never"
)

func (e *RemoteServerEntitySslEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "if_available":
		fallthrough
	case "require":
		fallthrough
	case "require_implicit":
		fallthrough
	case "never":
		*e = RemoteServerEntitySslEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for RemoteServerEntitySslEnum: %s", s)
	}
}

// RemoteServerEntity - Create Remote Server
type RemoteServerEntity struct {
	// Describes the authorized account
	AuthAccountName *string `json:"auth_account_name,omitempty"`
	// Returns link to login with an Oauth provider
	AuthSetupLink *string `json:"auth_setup_link,omitempty"`
	// Either `in_setup` or `complete`
	AuthStatus *RemoteServerEntityAuthStatusEnum `json:"auth_status,omitempty"`
	// Type of authentication method
	AuthenticationMethod *string `json:"authentication_method,omitempty"`
	// AWS Access Key.
	AwsAccessKey *string `json:"aws_access_key,omitempty"`
	// Azure Blob Storage Account name
	AzureBlobStorageAccount *string `json:"azure_blob_storage_account,omitempty"`
	// Azure Blob Storage Container name
	AzureBlobStorageContainer *string `json:"azure_blob_storage_container,omitempty"`
	// Shared Access Signature (SAS) token
	AzureBlobStorageSasToken *string `json:"azure_blob_storage_sas_token,omitempty"`
	// Azure File Storage Account name
	AzureFilesStorageAccount *string `json:"azure_files_storage_account,omitempty"`
	// Shared Access Signature (SAS) token
	AzureFilesStorageSasToken *string `json:"azure_files_storage_sas_token,omitempty"`
	// Azure File Storage Share name
	AzureFilesStorageShareName *string `json:"azure_files_storage_share_name,omitempty"`
	// Backblaze B2 Cloud Storage Bucket name
	BackblazeB2Bucket *string `json:"backblaze_b2_bucket,omitempty"`
	// Backblaze B2 Cloud Storage S3 Endpoint
	BackblazeB2S3Endpoint *string `json:"backblaze_b2_s3_endpoint,omitempty"`
	// If true, this server has been disabled due to failures.  Make any change or set disabled to false to clear this flag.
	Disabled *bool `json:"disabled,omitempty"`
	// `true` if remote server only accepts connections from dedicated IPs
	EnableDedicatedIps *bool `json:"enable_dedicated_ips,omitempty"`
	// Filebase Access Key.
	FilebaseAccessKey *string `json:"filebase_access_key,omitempty"`
	// Filebase Bucket name
	FilebaseBucket *string `json:"filebase_bucket,omitempty"`
	// Files Agent API Token
	FilesAgentAPIToken *string `json:"files_agent_api_token,omitempty"`
	// Local permissions for files agent. read_only, write_only, or read_write
	FilesAgentPermissionSet *RemoteServerEntityFilesAgentPermissionSetEnum `json:"files_agent_permission_set,omitempty"`
	// Agent local root path
	FilesAgentRoot *string `json:"files_agent_root,omitempty"`
	// Google Cloud Storage bucket name
	GoogleCloudStorageBucket *string `json:"google_cloud_storage_bucket,omitempty"`
	// Google Cloud Project ID
	GoogleCloudStorageProjectID *string `json:"google_cloud_storage_project_id,omitempty"`
	// Hostname or IP address
	Hostname *string `json:"hostname,omitempty"`
	// Remote server ID
	ID *int `json:"id,omitempty"`
	// Max number of parallel connections.  Ignored for S3 connections (we will parallelize these as much as possible).
	MaxConnections *int `json:"max_connections,omitempty"`
	// Internal name for your reference
	Name *string `json:"name,omitempty"`
	// Either personal or business_other account types
	OneDriveAccountType *RemoteServerEntityOneDriveAccountTypeEnum `json:"one_drive_account_type,omitempty"`
	// If true, we will ensure that all communications with this remote server are made through the primary region of the site.  This setting can also be overridden by a sitewide setting which will force it to true.
	PinToSiteRegion *bool `json:"pin_to_site_region,omitempty"`
	// If set, all communciations with this remote server are made through the provided region.
	PinnedRegion *string `json:"pinned_region,omitempty"`
	// Port for remote server.  Not needed for S3.
	Port *int `json:"port,omitempty"`
	// The name of the container (top level directory) where files will sync.
	RackspaceContainer *string `json:"rackspace_container,omitempty"`
	// Three letter airport code for Rackspace region. See https://support.rackspace.com/how-to/about-regions/
	RackspaceRegion *string `json:"rackspace_region,omitempty"`
	// Rackspace username used to login to the Rackspace Cloud Control Panel.
	RackspaceUsername *string `json:"rackspace_username,omitempty"`
	// Initial home folder on remote server
	RemoteHomePath *string `json:"remote_home_path,omitempty"`
	// S3 bucket name
	S3Bucket *string `json:"s3_bucket,omitempty"`
	// S3-compatible Access Key.
	S3CompatibleAccessKey *string `json:"s3_compatible_access_key,omitempty"`
	// S3-compatible Bucket name
	S3CompatibleBucket *string `json:"s3_compatible_bucket,omitempty"`
	// S3-compatible endpoint
	S3CompatibleEndpoint *string `json:"s3_compatible_endpoint,omitempty"`
	// S3-compatible endpoint
	S3CompatibleRegion *string `json:"s3_compatible_region,omitempty"`
	// S3 region
	S3Region *string `json:"s3_region,omitempty"`
	// Remote server certificate
	ServerCertificate *RemoteServerEntityServerCertificateEnum `json:"server_certificate,omitempty"`
	// Remote server SSH Host Key. If provided, we will require that the server host key matches the provided key. Uses OpenSSH format similar to what would go into ~/.ssh/known_hosts
	ServerHostKey *string `json:"server_host_key,omitempty"`
	// Remote server type.
	ServerType *RemoteServerEntityServerTypeEnum `json:"server_type,omitempty"`
	// Should we require SSL?
	Ssl *RemoteServerEntitySslEnum `json:"ssl,omitempty"`
	// Remote server username.  Not needed for S3 buckets.
	Username *string `json:"username,omitempty"`
	// Wasabi access key.
	WasabiAccessKey *string `json:"wasabi_access_key,omitempty"`
	// Wasabi Bucket name
	WasabiBucket *string `json:"wasabi_bucket,omitempty"`
	// Wasabi region
	WasabiRegion *string `json:"wasabi_region,omitempty"`
}
