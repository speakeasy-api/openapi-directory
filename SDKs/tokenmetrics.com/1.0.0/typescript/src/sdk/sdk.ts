/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import axios from "axios";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * Contains the list of servers available to the SDK
 */
export const ServerList = ["https://api.tokenmetrics.com"] as const;

/**
 * The available configuration options for the SDK
 */
export type SDKProps = {
  /**
   * Allows overriding the default axios client used by the SDK
   */
  defaultClient?: AxiosInstance;
  /**
   * Allows overriding the default server URL used by the SDK
   */
  serverURL?: string;
};

export class SDK {
  public _defaultClient: AxiosInstance;
  public _securityClient: AxiosInstance;
  public _serverURL: string;
  private _language = "typescript";
  private _sdkVersion = "0.0.1";
  private _genVersion = "internal";
  private _globals: any;

  constructor(props?: SDKProps) {
    this._serverURL = props?.serverURL ?? ServerList[0];

    this._defaultClient =
      props?.defaultClient ?? axios.create({ baseURL: this._serverURL });
    this._securityClient = this._defaultClient;
  }

  /**
   * Correlation
   *
   * @remarks
   * Correlation
   */
  correlation(
    req: operations.CorrelationRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CorrelationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CorrelationRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v1/correlation";

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CorrelationResponse =
        new operations.CorrelationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Indices
   *
   * @remarks
   * Indices
   */
  indices(
    req: operations.IndicesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IndicesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IndicesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v1/indices";

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IndicesResponse = new operations.IndicesResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Investor Grades
   *
   * @remarks
   * Investor Grades
   */
  investorGrades(
    req: operations.InvestorGradesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.InvestorGradesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.InvestorGradesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v1/investor-grades";

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.InvestorGradesResponse =
        new operations.InvestorGradesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Market Indicator
   *
   * @remarks
   * Market Indicator
   */
  marketIndicator(
    req: operations.MarketIndicatorRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.MarketIndicatorResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.MarketIndicatorRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v1/market-indicator";

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.MarketIndicatorResponse =
        new operations.MarketIndicatorResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Price
   *
   * @remarks
   * Price
   */
  price(
    req: operations.PriceRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PriceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PriceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v1/price";

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PriceResponse = new operations.PriceResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Price Prediction
   *
   * @remarks
   * Price Prediction
   */
  pricePrediction(
    req: operations.PricePredictionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PricePredictionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PricePredictionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v1/price-prediction";

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PricePredictionResponse =
        new operations.PricePredictionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Quantmetrics Tier 1
   *
   * @remarks
   * Quantmetrics Tier 1
   */
  quantmetricsTier1(
    req: operations.QuantmetricsTier1Request,
    config?: AxiosRequestConfig
  ): Promise<operations.QuantmetricsTier1Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.QuantmetricsTier1Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v1/quantmetrics-tier-1";

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.QuantmetricsTier1Response =
        new operations.QuantmetricsTier1Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Quantmetrics Tier 2
   *
   * @remarks
   * Quantmetrics Tier 2
   */
  quantmetricsTier2(
    req: operations.QuantmetricsTier2Request,
    config?: AxiosRequestConfig
  ): Promise<operations.QuantmetricsTier2Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.QuantmetricsTier2Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v1/quantmetrics-tier-2";

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.QuantmetricsTier2Response =
        new operations.QuantmetricsTier2Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Resistance & Support
   *
   * @remarks
   * Resistance & Support
   */
  resistanceSupport(
    req: operations.ResistanceSupportRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ResistanceSupportResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ResistanceSupportRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v1/resistance-support";

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ResistanceSupportResponse =
        new operations.ResistanceSupportResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Scenario Analysis
   *
   * @remarks
   * Scenario Analysis
   */
  scenarioAnalysis(
    req: operations.ScenarioAnalysisRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ScenarioAnalysisResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ScenarioAnalysisRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v1/scenario-analysis";

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ScenarioAnalysisResponse =
        new operations.ScenarioAnalysisResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Sentiments
   *
   * @remarks
   * Sentiments
   */
  sentiments(
    req: operations.SentimentsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.SentimentsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.SentimentsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v1/sentiments";

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SentimentsResponse =
        new operations.SentimentsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Tokens
   *
   * @remarks
   * Tokens
   */
  tokens(
    req: operations.TokensRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.TokensResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TokensRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v1/tokens";

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TokensResponse = new operations.TokensResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Trader Grades
   *
   * @remarks
   * Trader Grades
   */
  traderGrades(
    req: operations.TraderGradesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.TraderGradesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TraderGradesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v1/trader-grades";

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TraderGradesResponse =
        new operations.TraderGradesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Trading Indicator
   *
   * @remarks
   * Trading Indicator
   */
  tradingIndicator(
    req: operations.TradingIndicatorRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.TradingIndicatorResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TradingIndicatorRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v1/trading-indicator";

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TradingIndicatorResponse =
        new operations.TradingIndicatorResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }
}
