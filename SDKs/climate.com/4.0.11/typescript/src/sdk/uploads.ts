/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * General data upload endpoints.
 */
export class Uploads {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Chunked upload of data
   *
   * @remarks
   * Send chunked data for an **Upload**.
   */
  chunkedUpload(
    req: operations.ChunkedUploadRequest,
    security: operations.ChunkedUploadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ChunkedUploadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ChunkedUploadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v4/uploads/{uploadId}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ChunkedUploadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ChunkedUploadResponse =
        new operations.ChunkedUploadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        case [400, 401, 403, 404, 429, 500, 503].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve Upload status
   *
   * @remarks
   * Check the status of an **Upload** by ID.
   */
  fetchUploadStatusById(
    req: operations.FetchUploadStatusByIdRequest,
    security: operations.FetchUploadStatusByIdSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchUploadStatusByIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchUploadStatusByIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v4/uploads/{uploadId}/status",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchUploadStatusByIdSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchUploadStatusByIdResponse =
        new operations.FetchUploadStatusByIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.uploadStatus = utils.objectToClass(
              httpRes?.data,
              shared.UploadStatus
            );
          }
          break;
        case [400, 401, 403, 404, 429, 500, 503].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve Upload statuses in batch
   *
   * @remarks
   * Check the status of multiple **Uploads** (up to 100 per request).
   */
  fetchUploadStatuses(
    req: shared.UploadStatusQuery,
    security: operations.FetchUploadStatusesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchUploadStatusesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.UploadStatusQuery(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v4/uploads/status/query";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchUploadStatusesSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchUploadStatusesResponse =
        new operations.FetchUploadStatusesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.uploadStatuses = utils.objectToClass(
              httpRes?.data,
              shared.UploadStatuses
            );
          }
          break;
        case [400, 401, 403, 404, 429, 500, 503].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Initiate a new upload
   *
   * @remarks
   * Step one in uploading a data product. The method will return an **Upload** ID which the caller will use in subsequent `PUT` requests.
   * The following `contentTypes` may be uploaded:
   *     <details><summary>__image/vnd.climate.thermal.geotiff__</summary>
   *
   *     Allows for the upload of a thermal image. The image is a single band geotiff with 64 bit signed floating point values in degrees Celsius. The Coordinate Reference System (CRS) must be UTM with WGS84 datum.
   *
   *     The following metadata entries are required to be embedded in the geotiff:
   *       * acquisitionStartDate - ISO8601 date
   *       * acquisitionEndDate - ISO8601 date
   *       * isCalibrated - boolean
   *
   *     The following metadata entries are optional:
   *       * sourceId - uuid referencing the asset in the partner's system
   *       * fieldId - uuid referencing a field in the Climate system
   *       * boundaryId - uuid referencing a boundary in the Climate system
   *       * brandId - uuid referencing a partner's branding in the Climate system
   *       * name - name of the layer. The maximum number of characters that will be accepted as input is 20.
   *
   *     Requires either imagery:write or platform scope.
   *   </details>
   *   <details><summary>__image/vnd.climate.ndvi.geotiff__</summary>
   *
   *     Allows for the upload of a NDVI image. The image is a single band geotiff with 64 bit signed floating point values in the range of -1 to 1 inclusive. The Coordinate Reference System (CRS) must be UTM with WGS84 datum.
   *
   *     The following metadata entries are required to be embedded in the geotiff:
   *       * acquisitionStartDate - ISO8601 date
   *       * acquisitionEndDate - ISO8601 date
   *
   *     The following metadata entries are optional:
   *       * sourceId - uuid referencing the asset in the partner's system
   *       * fieldId - uuid referencing a field in the Climate system
   *       * boundaryId - uuid referencing a boundary in the Climate system
   *       * brandId - uuid referencing a partner's branding in the Climate system
   *       * name - name of the layer. The maximum number of characters that will be accepted as input is 20.
   *
   *     Requires either imagery:write or platform scope.
   *   </details>
   *   <details><summary> __image/vnd.climate.rgb.geotiff__</summary>
   *
   *     Allows for the upload of a true color image. The image is a multi band geotiff with 24-bit composite values. Each band is 8 bits with values in the range of 0 to 255. The Coordinate Reference System (CRS) must be UTM with WGS84 datum. The geotiff must contain 3 bands in the order Red, Green, Blue.
   *
   *     The following metadata entries are required to be embedded in the geotiff:
   *       * acquisitionStartDate - ISO8601 date
   *       * acquisitionEndDate - ISO8601 date
   *       * isCalibrated - boolean
   *
   *     The following metadata entries are optional:
   *       * sourceId - uuid referencing the asset in the partner's system
   *       * fieldId - uuid referencing a field in the Climate system
   *       * boundaryId - uuid referencing a boundary in the Climate system
   *       * brandId - uuid referencing a partner's branding in the Climate system
   *       * reflectanceComputeMethod - either TOA or GROUND
   *       * name - name of the layer. The maximum number of characters that will be accepted as input is 20.
   *
   *     Requires either imagery:write or platform scope.
   *   </details>
   *   <details><summary> __image/vnd.climate.rgb-nir.geotiff__</summary>
   *
   *     Allows for the upload of a Near Infrared (NIR) image. The Coordinate Reference System (CRS) must be UTM with WGS84 datum.
   *
   *     The following metadata entries are required to be embedded in the geotiff:
   *       * acquisitionStartDate - ISO8601 date
   *       * acquisitionEndDate - ISO8601 date
   *       * isCalibrated - boolean
   *
   *     The following metadata entries are optional:
   *       * sourceId - uuid referencing the asset in the partner's system
   *       * fieldId - uuid referencing a field in the Climate system
   *       * boundaryId - uuid referencing a boundary in the Climate system
   *       * brandId - uuid referencing a partner's branding in the Climate system
   *       * reflectanceComputeMethod - either TOA or GROUND
   *       * name - name of the layer. The maximum number of characters that will be accepted as input is 20.
   *
   *     Requires either imagery:write or platform scope.
   *   </details>
   *   <details><summary>__image/vnd.climate.rgb-cir.geotiff__</summary>
   *
   *     Allows for the upload of a Color Infrared (CIR) image. The Coordinate Reference System (CRS) must be UTM with WGS84 datum.
   *
   *     The following metadata entries are required to be embedded in the geotiff:
   *       * acquisitionStartDate - ISO8601 date
   *       * acquisitionEndDate - ISO8601 date
   *       * isCalibrated - boolean
   *
   *     The following metadata entries are optional:
   *       * sourceId - uuid referencing the asset in the partner's system
   *       * fieldId - uuid referencing a field in the Climate system
   *       * boundaryId - uuid referencing a boundary in the Climate system
   *       * brandId - uuid referencing a partner's branding in the Climate system
   *       * reflectanceComputeMethod - either TOA or GROUND
   *       * name - name of the layer. The maximum number of characters that will be accepted as input is 20.
   *
   *     Requires either imagery:write or platform scope.
   *   </details>
   *   <details><summary> __application/vnd.climate.rx.planting.shp__</summary>
   *
   *     Allows for the upload of a planting prescription in shapefile format.  The upload must be an archive in the zip format.  It should contain one and only one of each of the following file types:
   *       * .shp
   *       * .shx
   *       * .dbf
   *
   *     All files with the above suffixes must have the same prefix, ie Back40.shp, Back40.shx and Back40.dbf.
   *
   *     Requires either rx:write or platform scope.
   *   </details>
   *   <details><summary> __application/vnd.climate.prescription.zones.shp__</summary>
   *
   *     Allows for the upload of a zones prescription in shapefile format.  The upload must be an archive in the zip format.  It should contain one and only one of each of the following file types:
   *       * .shp
   *       * .shx
   *       * .dbf
   *
   *     All files with the above suffixes must have the same prefix, ie Back40.shp, Back40.shx and Back40.dbf.
   *
   *     The following metadata entries are required:
   *       * fieldId - field identifier for prescription zones.
   *
   *     Requires either rxZones:write or platform scope.
   *   </details>
   *   <details><summary> __application/vnd.climate.modus.xml__</summary>
   *
   *     Allows for the upload of a soil sampling file in the modus 1.0 format with some restrictions.  The upload must be a single xml file.
   *
   *     The following elements are required to be present in the modus file.
   *       * EventCode - Max length of 64 bytes
   *       * EventDate - Must be in ISO8601
   *       * SoilSample - Has a maxOccurs of 20k
   *       * Depth - Has a maxOccurs of 50
   *       * LabName - Must be non-empty.
   *       * StartingDepth - 0 to 36 inclusive, default 0
   *       * EndingDepth - 1 - 36 inclusive, default 1
   *       * ColumnDepth
   *       * DepthUnit - must be inches
   *       * Geometry - point in wgs84
   *
   *     Requires the soil:write scope.
   *    </details>
   *    <details><summary> __application/vnd.climate.stand-count.geojson__</summary>
   *
   *     Allows for the upload of a valid [geojson feature collection](https://tools.ietf.org/html/rfc7946#section-3.3).
   *
   *     Each feature in the collection must contain the following entry in its properties section:
   *       * StandPPA - A count of the number of plants per acre:
   *
   *     Additionally, the type field of each feature's geometry field must be:
   *       * Point
   *
   *     Requires `imagery:write` scope.
   *    </details>
   *    <details><summary> __application/vnd.climate.weed-count.geojson__</summary>
   *
   *     Allows for the upload of a valid [geojson feature collection](https://tools.ietf.org/html/rfc7946#section-3.3).
   *
   *     Each feature in the collection must contain the following entry in its properties section:
   *       * StandPPA - A count of the number of plants per acre:
   *
   *     Additionally, the type field of each feature's geometry field must be:
   *       * Point
   *
   *     Requires `imagery:write` scope.
   *    </details>
   *    <details><summary> __application/vnd.climate.as-applied.zip__</summary>
   *
   *     Allows for the upload of a valid application data [supported formats](https://support.climate.com/kt#/kA02A000000DjvOSAS/en_US).
   *
   *     The following metadata entries are required:
   *       * fileName - name of the file being uploaded.
   *
   *     The following metadata entries are optional:
   *       * resourceOwner - the grower's account email, where dealer/partner wants to upload data. As a prerequisite the grower must share their operation with the dealer/partner.
   *
   *     Requires `asApplied:write` scope.
   *    </details>
   *    <details><summary> __application/vnd.climate.as-planted.zip__</summary>
   *
   *     Allows for the upload of a valid planting data [supported formats](https://support.climate.com/kt#/kA02A000000DjvOSAS/en_US).
   *
   *     The following metadata entries are required:
   *       * fileName - name of the file being uploaded.
   *
   *     The following metadata entries are optional:
   *       * resourceOwner - the grower's account email, where dealer/partner wants to upload data. As a prerequisite the grower must share their operation with the dealer/partner.
   *
   *     Requires `asPlanted:write` scope.
   *    </details>
   *    <details><summary> __application/vnd.climate.as-harvested.zip__</summary>
   *
   *     Allows for the upload of a valid harvest data [supported formats](https://support.climate.com/kt#/kA02A000000DjvOSAS/en_US).
   *
   *     The following metadata entries are required:
   *       * fileName - name of the file being uploaded.
   *
   *     The following metadata entries are optional:
   *       * resourceOwner - the grower's account email, where dealer/partner wants to upload data. As a prerequisite the grower must share their operation with the dealer/partner.
   *
   *     Requires `asHarvested:write` scope.
   *    </details>
   */
  postUpload(
    req: operations.PostUploadRequest,
    security: operations.PostUploadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostUploadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostUploadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v4/uploads";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "upload",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostUploadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostUploadResponse =
        new operations.PostUploadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.createdUpload = JSON.stringify(httpRes?.data);
          }
          break;
        case [400, 401, 403, 429, 500, 503].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }
}
