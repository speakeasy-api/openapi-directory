"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
from ..shared import coverage_enum as shared_coverage_enum
from ..shared import extendedpricingoptions as shared_extendedpricingoptions
from ..shared import travelclass_enum as shared_travelclass_enum
from dataclasses_json import Undefined, dataclass_json
from sdk import utils
from typing import Optional


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class SearchCriteriaAdditionalInformation:
    
    branded_fares: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('brandedFares'), 'exclude': lambda f: f is None }})
    r"""If true, returns the fare family name for each flight-offer which supports fare family"""  
    chargeable_checked_bags: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('chargeableCheckedBags'), 'exclude': lambda f: f is None }})
    r"""If true, returns the price of the first additional bag when the airline is an \\"Amadeus Ancillary Services\\" member."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class SearchCriteriaFlightFiltersCabinRestriction:
    
    cabin: Optional[shared_travelclass_enum.TravelClassEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('cabin'), 'exclude': lambda f: f is None }})
    r"""quality of service offered in the cabin where the seat is located in this flight. Economy, premium economy, business or first class"""  
    coverage: Optional[shared_coverage_enum.CoverageEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('coverage'), 'exclude': lambda f: f is None }})
    r"""part of the trip covered by the travel class restriction (ALL_SEGMENTS if ommited)"""  
    origin_destination_ids: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('originDestinationIds'), 'exclude': lambda f: f is None }})
    r"""The list of originDestination identifiers for which the cabinRestriction applies"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class SearchCriteriaFlightFiltersCarrierRestrictions:
    r"""Restriction towards carriers."""
    
    blacklisted_in_eu_allowed: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('blacklistedInEUAllowed'), 'exclude': lambda f: f is None }})
    r"""This flag enable/disable filtering of blacklisted airline by EU. The list of the banned airlines is published in the Official Journal of the European Union, where they are included as annexes A and B to the Commission Regulation. The blacklist of an airline can concern all its flights or some specific aircraft types pertaining to the airline"""  
    excluded_carrier_codes: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('excludedCarrierCodes'), 'exclude': lambda f: f is None }})
    r"""This option ensures that the system will only consider these airlines."""  
    included_carrier_codes: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('includedCarrierCodes'), 'exclude': lambda f: f is None }})
    r"""This option ensures that the system will only consider these airlines."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class SearchCriteriaFlightFiltersConnectionRestriction:
    r"""Restriction towards number of connections."""
    
    airport_change_allowed: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('airportChangeAllowed'), 'exclude': lambda f: f is None }})
    r"""Allow to change airport during connection"""  
    max_number_of_connections: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('maxNumberOfConnections'), 'exclude': lambda f: f is None }})
    r"""The maximal number of connections for each itinerary. Value can be 0, 1 or 2."""  
    technical_stops_allowed: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('technicalStopsAllowed'), 'exclude': lambda f: f is None }})
    r"""This option allows the single segment to have one or more intermediate stops (technical stops)."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class SearchCriteriaFlightFilters:
    
    bus_segment_allowed: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('busSegmentAllowed'), 'exclude': lambda f: f is None }})
    r"""This flag enable/disable filtering of bus segment"""  
    cabin_restrictions: Optional[list[SearchCriteriaFlightFiltersCabinRestriction]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('cabinRestrictions'), 'exclude': lambda f: f is None }})
    r"""Restriction towards cabins."""  
    carrier_restrictions: Optional[SearchCriteriaFlightFiltersCarrierRestrictions] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('carrierRestrictions'), 'exclude': lambda f: f is None }})
    r"""Restriction towards carriers."""  
    connection_restriction: Optional[SearchCriteriaFlightFiltersConnectionRestriction] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('connectionRestriction'), 'exclude': lambda f: f is None }})
    r"""Restriction towards number of connections."""  
    cross_border_allowed: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('crossBorderAllowed'), 'exclude': lambda f: f is None }})
    r"""Allows to search a location outside the borders when a radius around a location is specified. Default is false."""  
    max_flight_time: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('maxFlightTime'), 'exclude': lambda f: f is None }})
    r"""This option allows to modify the value for the Elapsed Flying Time (EFT) masterPricer option"""  
    more_overnights_allowed: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('moreOvernightsAllowed'), 'exclude': lambda f: f is None }})
    r"""This flag enables/disables the possibility to have more overnight flights in Low Fare Search"""  
    rail_segment_allowed: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('railSegmentAllowed'), 'exclude': lambda f: f is None }})
    r"""This flag enable/disable filtering of rail segment (TGV AIR, RAIL ...)"""  
    return_to_departure_airport: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('returnToDepartureAirport'), 'exclude': lambda f: f is None }})
    r"""This option force to retrieve flight-offer with a departure and a return in the same airport"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class SearchCriteria:
    
    additional_information: Optional[SearchCriteriaAdditionalInformation] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('additionalInformation'), 'exclude': lambda f: f is None }})  
    add_one_way_offers: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('addOneWayOffers'), 'exclude': lambda f: f is None }})
    r"""This option allows activate the one-way combinable feature"""  
    allow_alternative_fare_options: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('allowAlternativeFareOptions'), 'exclude': lambda f: f is None }})
    r"""This option allows to default to a standard fareOption if no offers are found for the selected fareOption."""  
    exclude_allotments: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('excludeAllotments'), 'exclude': lambda f: f is None }})
    r"""This option allows to exclude the isAllotment flag associated to a booking class in the search response when it exist."""  
    flight_filters: Optional[SearchCriteriaFlightFilters] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('flightFilters'), 'exclude': lambda f: f is None }})  
    max_flight_offers: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('maxFlightOffers'), 'exclude': lambda f: f is None }})
    r"""Maximum number of flight offers returned (Max 250)"""  
    max_price: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('maxPrice'), 'exclude': lambda f: f is None }})
    r"""maximum price per traveler. By default, no limit is applied. If specified, the value should be a positive number with no decimals"""  
    one_flight_offer_per_day: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('oneFlightOfferPerDay'), 'exclude': lambda f: f is None }})
    r"""Requests the system to find at least one flight-offer per day, if possible, when a range of dates is specified. Default is false."""  
    pricing_options: Optional[shared_extendedpricingoptions.ExtendedPricingOptions] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('pricingOptions'), 'exclude': lambda f: f is None }})
    r"""fare filter options"""  
    