// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"bytes"
	"encoding/json"
	"errors"
)

// LocationRuleConditions23 - Scope of this rule, e.g. moves at or away from a specific location or towards a specific location.
type LocationRuleConditions23 struct {
	// Url to the individual resource.
	ToLocationURL *string `json:"to_location_url,omitempty"`
}

// LocationRuleConditions22 - Scope of this rule, e.g. moves at or away from a specific location or towards a specific location.
type LocationRuleConditions22 struct {
	// Unique identifier for resource.
	ToLocationID *string `json:"to_location_id,omitempty"`
}

// LocationRuleConditions21 - Scope of this rule, e.g. moves at or away from a specific location or towards a specific location.
type LocationRuleConditions21 struct {
	ToLocation *Location `json:"to_location,omitempty"`
}

type LocationRuleConditions2Type string

const (
	LocationRuleConditions2TypeLocationRuleConditions21 LocationRuleConditions2Type = "LocationRule_conditions_2_1"
	LocationRuleConditions2TypeLocationRuleConditions22 LocationRuleConditions2Type = "LocationRule_conditions_2_2"
	LocationRuleConditions2TypeLocationRuleConditions23 LocationRuleConditions2Type = "LocationRule_conditions_2_3"
)

type LocationRuleConditions2 struct {
	LocationRuleConditions21 *LocationRuleConditions21
	LocationRuleConditions22 *LocationRuleConditions22
	LocationRuleConditions23 *LocationRuleConditions23

	Type LocationRuleConditions2Type
}

func CreateLocationRuleConditions2LocationRuleConditions21(locationRuleConditions21 LocationRuleConditions21) LocationRuleConditions2 {
	typ := LocationRuleConditions2TypeLocationRuleConditions21

	return LocationRuleConditions2{
		LocationRuleConditions21: &locationRuleConditions21,
		Type:                     typ,
	}
}

func CreateLocationRuleConditions2LocationRuleConditions22(locationRuleConditions22 LocationRuleConditions22) LocationRuleConditions2 {
	typ := LocationRuleConditions2TypeLocationRuleConditions22

	return LocationRuleConditions2{
		LocationRuleConditions22: &locationRuleConditions22,
		Type:                     typ,
	}
}

func CreateLocationRuleConditions2LocationRuleConditions23(locationRuleConditions23 LocationRuleConditions23) LocationRuleConditions2 {
	typ := LocationRuleConditions2TypeLocationRuleConditions23

	return LocationRuleConditions2{
		LocationRuleConditions23: &locationRuleConditions23,
		Type:                     typ,
	}
}

func (u *LocationRuleConditions2) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	locationRuleConditions21 := new(LocationRuleConditions21)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&locationRuleConditions21); err == nil {
		u.LocationRuleConditions21 = locationRuleConditions21
		u.Type = LocationRuleConditions2TypeLocationRuleConditions21
		return nil
	}

	locationRuleConditions22 := new(LocationRuleConditions22)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&locationRuleConditions22); err == nil {
		u.LocationRuleConditions22 = locationRuleConditions22
		u.Type = LocationRuleConditions2TypeLocationRuleConditions22
		return nil
	}

	locationRuleConditions23 := new(LocationRuleConditions23)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&locationRuleConditions23); err == nil {
		u.LocationRuleConditions23 = locationRuleConditions23
		u.Type = LocationRuleConditions2TypeLocationRuleConditions23
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u LocationRuleConditions2) MarshalJSON() ([]byte, error) {
	if u.LocationRuleConditions21 != nil {
		return json.Marshal(u.LocationRuleConditions21)
	}

	if u.LocationRuleConditions22 != nil {
		return json.Marshal(u.LocationRuleConditions22)
	}

	if u.LocationRuleConditions23 != nil {
		return json.Marshal(u.LocationRuleConditions23)
	}

	return nil, nil
}

// LocationRuleConditions13 - Scope of this rule, e.g. moves at or away from a specific location or towards a specific location.
type LocationRuleConditions13 struct {
	// Url to the individual resource.
	FromLocationURL *string `json:"from_location_url,omitempty"`
}

// LocationRuleConditions12 - Scope of this rule, e.g. moves at or away from a specific location or towards a specific location.
type LocationRuleConditions12 struct {
	// Unique identifier for resource.
	FromLocationID *string `json:"from_location_id,omitempty"`
}

// LocationRuleConditions11 - Scope of this rule, e.g. moves at or away from a specific location or towards a specific location.
type LocationRuleConditions11 struct {
	FromLocation *Location `json:"from_location,omitempty"`
}

type LocationRuleConditions1Type string

const (
	LocationRuleConditions1TypeLocationRuleConditions11 LocationRuleConditions1Type = "LocationRule_conditions_1_1"
	LocationRuleConditions1TypeLocationRuleConditions12 LocationRuleConditions1Type = "LocationRule_conditions_1_2"
	LocationRuleConditions1TypeLocationRuleConditions13 LocationRuleConditions1Type = "LocationRule_conditions_1_3"
)

type LocationRuleConditions1 struct {
	LocationRuleConditions11 *LocationRuleConditions11
	LocationRuleConditions12 *LocationRuleConditions12
	LocationRuleConditions13 *LocationRuleConditions13

	Type LocationRuleConditions1Type
}

func CreateLocationRuleConditions1LocationRuleConditions11(locationRuleConditions11 LocationRuleConditions11) LocationRuleConditions1 {
	typ := LocationRuleConditions1TypeLocationRuleConditions11

	return LocationRuleConditions1{
		LocationRuleConditions11: &locationRuleConditions11,
		Type:                     typ,
	}
}

func CreateLocationRuleConditions1LocationRuleConditions12(locationRuleConditions12 LocationRuleConditions12) LocationRuleConditions1 {
	typ := LocationRuleConditions1TypeLocationRuleConditions12

	return LocationRuleConditions1{
		LocationRuleConditions12: &locationRuleConditions12,
		Type:                     typ,
	}
}

func CreateLocationRuleConditions1LocationRuleConditions13(locationRuleConditions13 LocationRuleConditions13) LocationRuleConditions1 {
	typ := LocationRuleConditions1TypeLocationRuleConditions13

	return LocationRuleConditions1{
		LocationRuleConditions13: &locationRuleConditions13,
		Type:                     typ,
	}
}

func (u *LocationRuleConditions1) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	locationRuleConditions11 := new(LocationRuleConditions11)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&locationRuleConditions11); err == nil {
		u.LocationRuleConditions11 = locationRuleConditions11
		u.Type = LocationRuleConditions1TypeLocationRuleConditions11
		return nil
	}

	locationRuleConditions12 := new(LocationRuleConditions12)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&locationRuleConditions12); err == nil {
		u.LocationRuleConditions12 = locationRuleConditions12
		u.Type = LocationRuleConditions1TypeLocationRuleConditions12
		return nil
	}

	locationRuleConditions13 := new(LocationRuleConditions13)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&locationRuleConditions13); err == nil {
		u.LocationRuleConditions13 = locationRuleConditions13
		u.Type = LocationRuleConditions1TypeLocationRuleConditions13
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u LocationRuleConditions1) MarshalJSON() ([]byte, error) {
	if u.LocationRuleConditions11 != nil {
		return json.Marshal(u.LocationRuleConditions11)
	}

	if u.LocationRuleConditions12 != nil {
		return json.Marshal(u.LocationRuleConditions12)
	}

	if u.LocationRuleConditions13 != nil {
		return json.Marshal(u.LocationRuleConditions13)
	}

	return nil, nil
}

// LocationRule - A JSON object containing the location rule
type LocationRule struct {
	// Scope of this rule, e.g. moves at or away from a specific location or towards a specific location.
	Conditions interface{} `json:"conditions,omitempty"`
	// Whether this rule should be in effect (`true`) or on hold (`false`).
	Enabled *bool `json:"enabled,omitempty"`
	// Unique identifier for resource.
	ID *string `json:"id,omitempty"`
	// A name or a label for this resource. This is used in the user interface, may be empty.
	Label *string `json:"label,omitempty"`
	// Parameters for this rule; depends on the rule type. Refer to the rule type specification for details.
	Parameters map[string]interface{} `json:"parameters,omitempty"`
	// [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) formatted string for when this resource was created.
	TimeCreated *string `json:"time_created,omitempty"`
	// [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) formatted string for when this resource was updated.
	TimeUpdated *string `json:"time_updated,omitempty"`
	// The type of location rule to be applied.
	// Allow: items at `conditions.from_location` can only move to `conditions.to_location` and locations allowed in other `allow` rules (destination whitelist).
	// Disallow: items at `conditions.from_location` cannot be moved to `conditions.to_location` and locations disallowed in other `disallow` rules (destination blacklist).
	// Disappeared: items disappearing at `conditions.from_location` will be moved to `parameters.location` after `parameters.time_s` seconds.
	// Debounce: items moves from `conditions.from_location` (and optionally to `conditions.to_location`) will be debounced with a period of `parameters.time_s` seconds, for a maximum of `parameters.max_periods` periods.
	//
	Type *LocationRuleTypeEnum `json:"type,omitempty"`
	// Url to the individual resource.
	URL *string `json:"url,omitempty"`
}
