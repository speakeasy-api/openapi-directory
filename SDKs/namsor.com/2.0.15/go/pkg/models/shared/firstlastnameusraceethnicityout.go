// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
)

// FirstLastNameUSRaceEthnicityOutRaceEthnicityEnum - Most likely US 'race'/ethnicity
type FirstLastNameUSRaceEthnicityOutRaceEthnicityEnum string

const (
	FirstLastNameUSRaceEthnicityOutRaceEthnicityEnumWNl  FirstLastNameUSRaceEthnicityOutRaceEthnicityEnum = "W_NL"
	FirstLastNameUSRaceEthnicityOutRaceEthnicityEnumHl   FirstLastNameUSRaceEthnicityOutRaceEthnicityEnum = "HL"
	FirstLastNameUSRaceEthnicityOutRaceEthnicityEnumA    FirstLastNameUSRaceEthnicityOutRaceEthnicityEnum = "A"
	FirstLastNameUSRaceEthnicityOutRaceEthnicityEnumBNl  FirstLastNameUSRaceEthnicityOutRaceEthnicityEnum = "B_NL"
	FirstLastNameUSRaceEthnicityOutRaceEthnicityEnumAiAn FirstLastNameUSRaceEthnicityOutRaceEthnicityEnum = "AI_AN"
	FirstLastNameUSRaceEthnicityOutRaceEthnicityEnumPi   FirstLastNameUSRaceEthnicityOutRaceEthnicityEnum = "PI"
)

func (e *FirstLastNameUSRaceEthnicityOutRaceEthnicityEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "W_NL":
		fallthrough
	case "HL":
		fallthrough
	case "A":
		fallthrough
	case "B_NL":
		fallthrough
	case "AI_AN":
		fallthrough
	case "PI":
		*e = FirstLastNameUSRaceEthnicityOutRaceEthnicityEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for FirstLastNameUSRaceEthnicityOutRaceEthnicityEnum: %s", s)
	}
}

// FirstLastNameUSRaceEthnicityOutRaceEthnicityAltEnum - Second most likely US 'race'/ethnicity
type FirstLastNameUSRaceEthnicityOutRaceEthnicityAltEnum string

const (
	FirstLastNameUSRaceEthnicityOutRaceEthnicityAltEnumWNl  FirstLastNameUSRaceEthnicityOutRaceEthnicityAltEnum = "W_NL"
	FirstLastNameUSRaceEthnicityOutRaceEthnicityAltEnumHl   FirstLastNameUSRaceEthnicityOutRaceEthnicityAltEnum = "HL"
	FirstLastNameUSRaceEthnicityOutRaceEthnicityAltEnumA    FirstLastNameUSRaceEthnicityOutRaceEthnicityAltEnum = "A"
	FirstLastNameUSRaceEthnicityOutRaceEthnicityAltEnumBNl  FirstLastNameUSRaceEthnicityOutRaceEthnicityAltEnum = "B_NL"
	FirstLastNameUSRaceEthnicityOutRaceEthnicityAltEnumAiAn FirstLastNameUSRaceEthnicityOutRaceEthnicityAltEnum = "AI_AN"
	FirstLastNameUSRaceEthnicityOutRaceEthnicityAltEnumPi   FirstLastNameUSRaceEthnicityOutRaceEthnicityAltEnum = "PI"
)

func (e *FirstLastNameUSRaceEthnicityOutRaceEthnicityAltEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "W_NL":
		fallthrough
	case "HL":
		fallthrough
	case "A":
		fallthrough
	case "B_NL":
		fallthrough
	case "AI_AN":
		fallthrough
	case "PI":
		*e = FirstLastNameUSRaceEthnicityOutRaceEthnicityAltEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for FirstLastNameUSRaceEthnicityOutRaceEthnicityAltEnum: %s", s)
	}
}

// FirstLastNameUSRaceEthnicityOut - Represents the output of inferring the LIKELY US 'race/ethnicity' from a personal name, given US country of residence and (optionally) a ZIP5 code.
type FirstLastNameUSRaceEthnicityOut struct {
	// The first name (also known as given name)
	FirstName *string `json:"firstName,omitempty"`
	ID        *string `json:"id,omitempty"`
	// The last name (also known as family name, or surname)
	LastName *string `json:"lastName,omitempty"`
	// The calibrated probability for raceEthnicity OR raceEthnicityAlt to have been guessed correctly.
	ProbabilityAltCalibrated *float64 `json:"probabilityAltCalibrated,omitempty"`
	// The calibrated probability for raceEthnicity to have been guessed correctly.
	ProbabilityCalibrated *float64 `json:"probabilityCalibrated,omitempty"`
	// List 'race'/ethnicities
	RaceEthnicitiesTop []string `json:"raceEthnicitiesTop,omitempty"`
	// Most likely US 'race'/ethnicity
	RaceEthnicity *FirstLastNameUSRaceEthnicityOutRaceEthnicityEnum `json:"raceEthnicity,omitempty"`
	// Second most likely US 'race'/ethnicity
	RaceEthnicityAlt *FirstLastNameUSRaceEthnicityOutRaceEthnicityAltEnum `json:"raceEthnicityAlt,omitempty"`
	// Higher score is better, but score is not normalized. Use calibratedProbability if available.
	Score  *float64 `json:"score,omitempty"`
	Script *string  `json:"script,omitempty"`
}
